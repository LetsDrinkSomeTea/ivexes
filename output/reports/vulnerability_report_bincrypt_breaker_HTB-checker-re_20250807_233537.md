# Security Analysis Report

**Generated:** 2025-08-07 23:35:37
**Vulnerability:** HTB-checker-re
**Trace Name:** bincrypt_breaker
**Model:** openai/gpt-5
**Reasoning Model:** openai/gpt-5

**Codebase:** /home/julian/Desktop/Bachelorarbeit/testdata/screen/codebase

# HTB Challenge: checker — Reverse Engineering and Decryption Report

Flag: HTB{cRyPto_r3V_15_aLways_aWeS0m3}

## Summary
We analyzed the provided binary "checker" and an accompanying data file "file.bin". The checker decrypts file.bin via a single-byte XOR and executes the result via fexecve. The recovered executable implements a custom permutation/XOR-based check over an input flag (without HTB{}). By reversing the routine, we derived the valid flag text, confirming it by executing the recovered binary. The final HTB flag is HTB{cRyPto_r3V_15_aLways_aWeS0m3}.

## Files in sandbox
- checker (ELF 64-bit, PIE, dynamically linked)
- file.bin (data)

## Triage and static analysis (checker)
- Strings revealed messages and references to file.bin:
  - "file.bin", "Library not found.", "File create issue.", "/proc/self/fd/%d"
- Symbols (nm):
  - decrypt at 0x11d9, main at 0x12c7
- Key disassembly (objdump):
  - decrypt does:
    - f = fopen("file.bin", "rb")
    - fd = open("/proc/self/fd/%d", O_WRONLY|O_CREAT|..., 0x1ed)
    - Loop: c = fgetc(f); if (c == EOF) break; c ^= 0xAB; write(fd, &c, 1);
    - fclose(f); return fd
  - main:
    - int fd = decrypt();
    - snprintf(path, "/proc/self/fd/%d", fd)
    - int newfd = open(path, 0)
    - close(fd)
    - fexecve(newfd, argv=["formatting"], envp=null)

Conclusion: checker simply XOR-decrypts file.bin with key 0xAB to an anonymous file and executes it.

## Recovering and executing the hidden executable
- Decrypt file.bin by XOR 0xAB:
  - Output: ELF 64-bit LSB PIE executable (stripped)
- Running decrypted.bin:
  - Prompts: "Enter the flag (without `HTB{}`):" and prints correctness.

## Reverse engineering decrypted.bin (flag logic)
- Notable strings:
  - RV{r15]_vcP3o]L_tazmfSTaa3s0
  - "Enter the flag (without `HTB{}`):", "Correct flag", "Wrong flag"
- Flow (simplified):
  1) Read input; require length 28
  2) Apply four swaps to the 28-byte input (swap is involutive):
     - (0, 12), (14, 26), (4, 8), (20, 23)
  3) Split into L = s[0:14] and R = s[14:28]
  4) Transform each half with a routine T(buf, key) and concatenate result L' + R'
  5) Compare result with constant "RV{r15]_vcP3o]L_tazmfSTaa3s0"; equal => Correct flag

- The transform T(buf, key) details (function at 0x12e4):
  - Arrays:
    - arr1 = [9,12,2,10,4,1,6,3,8,5,7,11,0,13]
    - arr2 = [2,4,6,8,11,13]
  - Perform 8 rounds:
    - tmp[j] = buf[arr1[j]] for j in 0..13
    - buf = tmp
  - Then XOR buf[idx] ^= key for idx in arr2
  - key = 2 for L, key = 3 for R

## Inverting the check to recover the input flag
Given the target S = "RV{r15]_vcP3o]L_tazmfSTaa3s0" of length 28:
- Split S0 = S[:14], S1 = S[14:]
- Invert T on each half:
  - Undo XOR at arr2 by XORing again with the key
  - Invert the permutation 8 times by applying the inverse mapping of arr1:
    - If new[j] = old[arr1[j]], then old[x] = new[j] where j = inv[x] and inv is the index of x in arr1
- Combine halves, then undo the four swaps (same swaps, swap is its own inverse)

Python used for inversion:
```
S = "RV{r15]_vcP3o]L_tazmfSTaa3s0"
S0, S1 = S[:14], S[14:]
arr1 = [9,12,2,10,4,1,6,3,8,5,7,11,0,13]
arr2 = [2,4,6,8,11,13]
inv = [None]*14
for j,x in enumerate(arr1): inv[x] = j

def invert_half(T, key):
    H = list(T)
    for idx in arr2:
        H[idx] = chr(ord(H[idx]) ^ key)
    for _ in range(8):
        old = H.copy()
        H = [None]*14
        for x in range(14):
            j = inv[x]
            H[x] = old[j]
    return ''.join(H)

Lprime = invert_half(S0, 2)
Rprime = invert_half(S1, 3)
combined = list(Lprime + Rprime)
for a,b in [(0,12),(14,26),(4,8),(20,23)]:
    combined[a], combined[b] = combined[b], combined[a]
flag_inner = ''.join(combined)
print(flag_inner)
```
Output:
- cRyPto_r3V_15_aLways_aWeS0m3

## Validation
- Running decrypted.bin and feeding cRyPto_r3V_15_aLways_aWeS0m3 prints "Correct flag".
- Therefore the HTB flag (with braces) is:

HTB{cRyPto_r3V_15_aLways_aWeS0m3}

## Notes
- checker’s decryption is a simple XOR 0xAB over file.bin and execution via fexecve on an anonymous file descriptor
- The recovered executable uses a small Feistel-like permutation with a fixed index mapping and selective XOR, plus pre/post swaps over the whole input.



---
*Report generated by IVEXES Multi-Agent Security Analysis System*
