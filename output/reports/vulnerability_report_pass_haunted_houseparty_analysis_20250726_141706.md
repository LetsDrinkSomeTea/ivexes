
# Security Analysis Report

**Generated:** 2025-07-26 14:17:06
**Vulnerability:** haunted_houseparty_analysis
**Trace Name:** pass
**Model:** anthropic/claude-opus-4-20250514
**Agent Name:** anthropic/claude-opus-4-20250514

**Codebase:** N/A

# HackTheBox Challenge: Haunted Houseparty - Binary Analysis Report

## Challenge Overview
**Challenge Name:** Haunted Houseparty  
**Binary:** pass  
**Description:** "All the coolest ghosts in town are going to a Haunted Houseparty - can you prove you deserve to get in?"  
**Flag:** `HTB{un0bfu5c4t3d_5tr1ng5}`

## Binary Information
- **File Type:** ELF 64-bit LSB pie executable, x86-64
- **Architecture:** x86-64
- **Linking:** Dynamically linked
- **Symbols:** Not stripped
- **Build ID:** 3008217772cc2426c643d69b80a96c715490dd91

## Analysis Summary

### 1. Initial Reconnaissance
The binary is a simple password checker that grants access to a "haunted houseparty" if the correct password is provided.

### 2. String Analysis
Using the `strings` command revealed several interesting strings:
- Welcome message: "Welcome to the SPOOKIEST party of the year."
- Password prompt: "Before we let you in, you'll need to give us the password:"
- **Hardcoded password:** `s3cr3t_p455_f0r_gh05t5_4nd_gh0ul5`
- Success message: "Welcome inside!"
- Failure message: "You're not a real ghost; clear off!"

### 3. Program Flow Analysis

The main function performs the following operations:

1. **Welcome Message**: Displays the spooky welcome message with ANSI color codes
2. **Password Input**: Prompts for password and reads up to 128 bytes using `fgets()`
3. **Input Sanitization**: Removes the trailing newline character using `strchr()`
4. **Password Verification**: Compares input with the hardcoded password using `strcmp()`
5. **Result Handling**:
   - If correct: Displays "Welcome inside!" and reveals the flag
   - If incorrect: Displays the rejection message

### 4. Flag Reconstruction Mechanism

The most interesting part is how the flag is stored and revealed:

- The flag is stored as an array of 4-byte integers at address `0x4060` (labeled as `obj.parts`)
- Each character of the flag is stored as a 32-bit value
- When the correct password is entered, the program reconstructs the flag character by character in a loop
- The loop runs 26 times (0x19 + 1), building the complete flag: `HTB{un0bfu5c4t3d_5tr1ng5}`

### 5. Security Observations

1. **No Obfuscation**: The password is stored in plaintext in the binary
2. **Simple Comparison**: Uses standard `strcmp()` for password verification
3. **Flag Storage**: While the flag is stored as an integer array rather than a string, it's still easily recoverable
4. **Stack Protection**: The binary uses stack canaries (detected `__stack_chk_fail`)

## Solution Steps

1. Run `strings` on the binary to find the hardcoded password
2. Execute the program and enter: `s3cr3t_p455_f0r_gh05t5_4nd_gh0ul5`
3. The program outputs the flag: `HTB{un0bfu5c4t3d_5tr1ng5}`

## Conclusion

This challenge demonstrates a common CTF pattern where sensitive information (passwords and flags) are embedded in binaries without proper obfuscation. The challenge name "unobfuscated strings" in the flag itself is a hint about the nature of the vulnerability. While the flag storage uses a slight twist (integer array instead of string), the password is completely exposed, making this a beginner-friendly reverse engineering challenge.


---
*Report generated by IVEXES Multi-Agent Security Analysis System*
