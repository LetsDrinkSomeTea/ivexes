# CVE Search

The CVE Search module provides comprehensive vulnerability research capabilities with access to multiple vulnerability databases and intelligence sources.

## Overview

The CVE Search functionality enables security analysts to:

- **Search Multiple Databases**: Access CVE, NVD, and vendor-specific databases
- **Intelligence Correlation**: Cross-reference vulnerabilities with threat intelligence
- **Real-time Updates**: Access the latest vulnerability disclosures
- **Advanced Filtering**: Complex search criteria and result refinement
- **Export Capabilities**: Generate reports and export search results

## Data Sources

### Primary Sources
- **National Vulnerability Database (NVD)**: NIST's official CVE database
- **MITRE CVE**: Original CVE database maintained by MITRE
- **Vendor Advisories**: Security bulletins from major vendors
- **Exploit Databases**: Known exploits and proof-of-concepts

### Intelligence Sources
- **Threat Intelligence Feeds**: Commercial and open-source feeds
- **Security Research**: Academic and industry research
- **Bug Bounty Reports**: Publicly disclosed vulnerability reports
- **Dark Web Monitoring**: Underground vulnerability trading

## Basic Usage

### Simple CVE Lookup

```python
from ivexes.cve_search import CVESearch

cve_search = CVESearch()

# Look up specific CVE
cve_info = cve_search.get_cve("CVE-2023-1234")
print(f"Description: {cve_info.description}")
print(f"CVSS Score: {cve_info.cvss_score}")
print(f"Affected Products: {cve_info.affected_products}")
```

### Search by Keywords

```python
# Search for vulnerabilities by keywords
results = cve_search.search_keywords(
    keywords=["buffer overflow", "remote code execution"],
    limit=50
)

for cve in results:
    print(f"{cve.id}: {cve.description}")
```

### Product-Specific Search

```python
# Search for vulnerabilities in specific products
product_vulns = cve_search.search_product(
    vendor="apache",
    product="http_server",
    version_range="2.4.0:2.4.50"
)

print(f"Found {len(product_vulns)} vulnerabilities")
```

## Advanced Search Features

### Complex Queries

```python
from ivexes.cve_search import SearchFilter, DateRange

# Create advanced search filter
search_filter = SearchFilter(
    # CVSS score criteria
    cvss_score_min=7.0,
    cvss_score_max=10.0,
    
    # Date range
    published_date=DateRange(
        start="2023-01-01",
        end="2024-01-01"
    ),
    
    # Attack vectors
    attack_vectors=["network", "adjacent"],
    
    # Impact criteria
    confidentiality_impact=["high"],
    integrity_impact=["high", "partial"],
    availability_impact=["high", "partial"],
    
    # Exploit availability
    exploit_available=True,
    
    # Vendor and product filters
    vendors=["microsoft", "apache", "nginx"],
    products=["windows", "iis", "apache"],
    
    # Vulnerability types
    cwe_ids=["CWE-79", "CWE-89", "CWE-120"]
)

# Execute advanced search
advanced_results = cve_search.advanced_search(search_filter)
```

### Trend Analysis

```python
# Analyze vulnerability trends
trends = cve_search.analyze_trends(
    time_period="2023-01-01:2024-01-01",
    group_by=["month", "severity", "attack_vector"]
)

print("Monthly vulnerability counts:")
for month, count in trends.monthly_counts.items():
    print(f"  {month}: {count}")

print("Top vulnerability types:")
for cwe_id, count in trends.top_cwe_types.items():
    print(f"  {cwe_id}: {count}")
```

### Exploit Intelligence

```python
# Find vulnerabilities with active exploits
exploited_cves = cve_search.find_exploited_cves(
    time_range="last_30_days",
    include_proof_of_concept=True,
    include_weaponized=True
)

# Get exploit details
for cve in exploited_cves:
    exploits = cve_search.get_exploit_details(cve.id)
    print(f"{cve.id}: {len(exploits)} known exploits")
    
    for exploit in exploits:
        print(f"  - {exploit.source}: {exploit.title}")
        print(f"    Reliability: {exploit.reliability}")
        print(f"    Complexity: {exploit.complexity}")
```

## Integration with Other Modules

### Vector Database Integration

```python
from ivexes.vector_db import VectorDatabase

# Combine CVE search with semantic analysis
vector_db = VectorDatabase()

# Search for similar vulnerabilities
search_results = cve_search.search_keywords(["SQL injection"])
similar_vulns = []

for cve in search_results:
    similar = vector_db.find_similar(
        cve_id=cve.id,
        similarity_threshold=0.8
    )
    similar_vulns.extend(similar)

# Remove duplicates and rank by relevance
unique_vulns = cve_search.deduplicate_and_rank(similar_vulns)
```

### Code Browser Integration

```python
from ivexes.code_browser import CodeBrowser

# Analyze code and find related CVEs
code_browser = CodeBrowser()
code_analysis = code_browser.analyze_file("vulnerable_code.c")

# Search for CVEs related to discovered patterns
related_cves = cve_search.find_cves_by_patterns(
    patterns=code_analysis.vulnerability_patterns,
    languages=["c", "c++"]
)

print(f"Found {len(related_cves)} related CVEs")
```

## Threat Intelligence Features

### IoC Correlation

```python
# Correlate CVEs with Indicators of Compromise
ioc_results = cve_search.correlate_iocs(
    cve_list=["CVE-2023-1234", "CVE-2023-5678"],
    ioc_types=["hash", "domain", "ip", "url"]
)

for cve_id, iocs in ioc_results.items():
    print(f"{cve_id} associated IoCs:")
    for ioc in iocs:
        print(f"  {ioc.type}: {ioc.value}")
```

### Campaign Attribution

```python
# Find CVEs associated with threat campaigns
campaign_cves = cve_search.find_campaign_cves(
    campaign_names=["APT29", "Lazarus", "FIN7"],
    time_range="2023-01-01:2024-01-01"
)

# Analyze attack patterns
attack_analysis = cve_search.analyze_attack_patterns(
    cve_list=[cve.id for cve in campaign_cves]
)
```

## Automated Monitoring

### CVE Monitoring Setup

```python
from ivexes.cve_search import CVEMonitor

# Set up automated monitoring
monitor = CVEMonitor()

# Define monitoring criteria
monitor.add_watch(
    name="critical_infrastructure",
    filters={
        "products": ["scada", "plc", "hmi"],
        "cvss_score_min": 7.0,
        "attack_vector": "network"
    },
    notification_channels=["email", "slack"]
)

# Add vendor-specific monitoring
monitor.add_vendor_watch(
    vendors=["microsoft", "apache"],
    severity=["critical", "high"],
    notification_email="security@company.com"
)

# Start monitoring
monitor.start()
```

### Alert Configuration

```python
# Configure alert rules
monitor.add_alert_rule(
    name="zero_day_alert",
    condition={
        "exploit_available": True,
        "public_disclosure": True,
        "cvss_score_min": 9.0
    },
    actions=[
        "send_urgent_email",
        "create_incident_ticket",
        "notify_security_team"
    ]
)

# Real-time CVE feed processing
monitor.process_feed(
    feed_url="https://cve.mitre.org/data/downloads/allitems.xml",
    processing_interval=300  # 5 minutes
)
```

## Reporting and Export

### Report Generation

```python
from ivexes.report import ReportGenerator

# Generate CVE search report
report_gen = ReportGenerator()
search_results = cve_search.search_keywords(["privilege escalation"])

report = report_gen.generate_cve_report(
    search_results=search_results,
    include_statistics=True,
    include_trends=True,
    include_recommendations=True
)

# Export to various formats
report.export_pdf("cve_analysis.pdf")
report.export_excel("cve_analysis.xlsx")
report.export_json("cve_analysis.json")
```

### Custom Export Formats

```python
# Export search results in custom format
export_data = cve_search.export_results(
    results=search_results,
    format="custom",
    fields=[
        "id", "description", "cvss_score",
        "published_date", "affected_products",
        "exploit_available", "patch_available"
    ],
    sort_by="cvss_score",
    sort_order="desc"
)

# Export to STIX format for threat intelligence sharing
stix_export = cve_search.export_stix(
    results=search_results,
    include_relationships=True,
    include_indicators=True
)
```

## Configuration

### API Configuration

```python
from ivexes.cve_search import CVESearchConfig

config = CVESearchConfig(
    # Data source APIs
    nvd_api_key="your_nvd_api_key",
    cve_api_endpoint="https://services.nvd.nist.gov/rest/json/cves/2.0/",
    
    # Rate limiting
    requests_per_second=10,
    max_concurrent_requests=5,
    
    # Caching
    cache_enabled=True,
    cache_duration=3600,  # 1 hour
    cache_size="500MB",
    
    # Data sources
    enable_nvd=True,
    enable_mitre=True,
    enable_vendor_feeds=True,
    enable_exploit_db=True,
    
    # Threat intelligence
    threat_intel_sources=[
        "commercial_feed_1",
        "open_source_feed_1"
    ]
)

cve_search = CVESearch(config)
```

### Database Configuration

```python
# Configure local CVE database
config.database = {
    "type": "postgresql",
    "host": "localhost",
    "port": 5432,
    "database": "cve_database",
    "update_interval": 3600,
    "full_sync_interval": 86400  # 24 hours
}
```

## Performance Optimization

### Search Optimization

```python
# Optimize search performance
cve_search.configure_search(
    # Index configuration
    enable_full_text_search=True,
    index_fields=["description", "summary"],
    
    # Result caching
    cache_search_results=True,
    result_cache_size="1GB",
    
    # Parallel processing
    parallel_searches=True,
    max_workers=4
)
```

### Bulk Operations

```python
# Bulk CVE lookups
cve_ids = ["CVE-2023-1234", "CVE-2023-5678", "CVE-2023-9012"]
bulk_results = cve_search.bulk_lookup(
    cve_ids,
    batch_size=100,
    parallel=True
)

# Bulk product searches
products = [
    {"vendor": "microsoft", "product": "windows"},
    {"vendor": "apache", "product": "httpd"},
    {"vendor": "nginx", "product": "nginx"}
]

bulk_product_results = cve_search.bulk_product_search(
    products,
    date_range="2023-01-01:2024-01-01"
)
```

## Best Practices

### Effective CVE Research

1. **Use Multiple Sources**: Cross-reference findings across databases
2. **Monitor Continuously**: Set up automated monitoring for relevant products
3. **Prioritize by Risk**: Focus on high-CVSS, exploited vulnerabilities
4. **Context Awareness**: Consider your specific environment and attack surface
5. **Timeline Analysis**: Track vulnerability lifecycle and patch timelines

### API Usage Guidelines

1. **Respect Rate Limits**: Follow API rate limiting guidelines
2. **Use Caching**: Implement caching to reduce API calls
3. **Bulk Operations**: Use bulk APIs when available
4. **Error Handling**: Implement robust error handling and retries
5. **API Key Management**: Secure API key storage and rotation

## Troubleshooting

### Common Issues

**API Rate Limiting**
```python
# Handle rate limiting gracefully
try:
    results = cve_search.search_keywords(keywords)
except RateLimitError as e:
    print(f"Rate limit exceeded. Retry after: {e.retry_after}")
    time.sleep(e.retry_after)
    results = cve_search.search_keywords(keywords)
```

**Data Inconsistencies**
```python
# Validate and clean search results
validated_results = cve_search.validate_results(results)
cleaned_results = cve_search.deduplicate_results(validated_results)
```

**Performance Issues**
```python
# Monitor search performance
performance_stats = cve_search.get_performance_stats()
print(f"Average query time: {performance_stats.avg_query_time}")
print(f"Cache hit rate: {performance_stats.cache_hit_rate}")

# Optimize slow queries
cve_search.optimize_query(slow_query)
```

## See Also

- [Vector Database Integration](vector-db.md)
- [Threat Intelligence Feeds](../examples/threat-intelligence.md)
- [API Reference](../api/cve-search.md)
- [Configuration Guide](../getting-started/configuration.md)