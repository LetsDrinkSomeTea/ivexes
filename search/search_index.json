{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IVExES - Intelligent Vulnerability Extraction &amp; Exploit Synthesis","text":"<p>IVExES is an advanced Python framework for cybersecurity vulnerability analysis and exploitation using multi-agent AI systems. It combines comprehensive knowledge bases (CWE, CAPEC, MITRE ATT&amp;CK) with dynamic analysis capabilities to provide automated, intelligent security assessment.</p>"},{"location":"#overview","title":"Overview","text":"<p>IVExES transforms vulnerability analysis from a manual, time-intensive process into an automated, AI-driven workflow. By leveraging multiple specialized AI agents, the framework can analyze complex codebases, identify vulnerabilities, understand exploitation techniques, and generate comprehensive security reports.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Multi-Agent Architecture</p> <p>Specialized AI agents work collaboratively to analyze different aspects of security vulnerabilities, from code analysis to exploitation strategy development.</p> <p>Knowledge Base Integration</p> <p>Seamlessly integrates with industry-standard security frameworks including MITRE ATT&amp;CK, CWE (Common Weakness Enumeration), CAPEC (Common Attack Pattern Enumeration), and CVE databases.</p> <p>Dynamic Code Analysis</p> <p>Container-based sandbox environments with Neovim LSP integration provide safe, intelligent code examination and analysis.</p> <p>Automated Reporting</p> <p>Generates structured vulnerability reports with detailed exploitation procedures, risk assessments, and remediation guidance.</p>"},{"location":"#what-makes-ivexes-unique","title":"What Makes IVExES Unique","text":"<ul> <li>AI-First Approach: Built from the ground up to leverage large language models for security analysis</li> <li>Extensible Architecture: Modular design allows easy integration of custom agents and analysis tools</li> <li>Safe Execution: Containerized environments ensure secure analysis of potentially malicious code</li> <li>Comprehensive Coverage: Analyzes vulnerabilities from multiple perspectives using specialized knowledge bases</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started with IVExES in minutes:</p> <pre><code># Clone and setup\ngit clone https://github.com/LetsDrinkSomeTea/ivexes.git\ncd ivexes\nmake setup\n\n# Configure API key\necho \"LLM_API_KEY=your_openai_api_key\" &gt; .secrets.env\n\n# Run analysis\npython -c \"\nfrom ivexes.agents import SingleAgent\nagent = SingleAgent()\nawait agent.run_interactive()\n\"\n</code></pre> <p>For detailed setup instructions, see the Quick Start Guide.</p>"},{"location":"#core-components","title":"Core Components","text":""},{"location":"#ai-agents","title":"\ud83e\udd16 AI Agents","text":"<p>IVExES provides multiple specialized agents for different analysis scenarios:</p> <ul> <li>SingleAgent: Individual vulnerability assessment with focused analysis</li> <li>MultiAgent: Orchestrated multi-agent analysis for complex vulnerabilities</li> <li>HTBChallengeAgent: Specialized for Hack The Box challenge analysis</li> <li>MVPAgent: Minimal viable product for quick vulnerability checks</li> </ul>"},{"location":"#code-analysis","title":"\ud83d\udd0d Code Analysis","text":"<p>Advanced code analysis capabilities through multiple integrated systems:</p> <ul> <li>Code Browser: Neovim LSP integration for intelligent code navigation</li> <li>Sandbox System: Docker-based execution environments for safe analysis</li> <li>Tree-sitter Parsing: Deep code structure understanding and analysis</li> </ul>"},{"location":"#knowledge-integration","title":"\ud83d\udcca Knowledge Integration","text":"<p>Comprehensive cybersecurity knowledge base integration:</p> <ul> <li>Vector Database: ChromaDB-powered semantic search across security frameworks</li> <li>CVE Search: Real-time vulnerability database integration</li> <li>MITRE ATT&amp;CK: Threat intelligence and attack pattern correlation</li> <li>CWE/CAPEC: Weakness and attack pattern classification</li> </ul>"},{"location":"#configuration-tools","title":"\u2699\ufe0f Configuration &amp; Tools","text":"<p>Flexible configuration and utility systems:</p> <ul> <li>Settings Management: Environment-based configuration with validation</li> <li>Shared Tools: Utilities for token management, container operations, and formatting</li> <li>Logging &amp; Monitoring: Comprehensive observability and debugging capabilities</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#enterprise-security-assessment","title":"\ud83c\udfe2 Enterprise Security Assessment","text":"<ul> <li>Large Codebase Analysis: Multi-agent orchestration for comprehensive security reviews</li> <li>Vulnerability Prioritization: AI-driven risk assessment and remediation planning</li> <li>Compliance Reporting: Automated generation of security compliance documentation</li> </ul>"},{"location":"#educational-security-research","title":"\ud83c\udf93 Educational Security Research","text":"<ul> <li>CTF Challenge Analysis: Specialized agents for capture-the-flag competitions</li> <li>Vulnerability Research: Deep analysis of security weaknesses and exploitation techniques</li> <li>Security Training: Interactive learning through guided vulnerability analysis</li> </ul>"},{"location":"#research-development","title":"\ud83d\udd2c Research &amp; Development","text":"<ul> <li>Novel Vulnerability Discovery: AI-assisted identification of previously unknown weaknesses</li> <li>Exploitation Technique Development: Automated generation of proof-of-concept exploits</li> <li>Security Tool Development: Framework for building custom security analysis tools</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    User[User Interface] --&gt; Agent[AI Agents]\n    Agent --&gt; CodeBrowser[Code Browser]\n    Agent --&gt; Sandbox[Sandbox Environment]\n    Agent --&gt; VectorDB[Vector Database]\n    Agent --&gt; CVE[CVE Search]\n\n    CodeBrowser --&gt; Neovim[Neovim LSP]\n    CodeBrowser --&gt; TreeSitter[Tree-sitter Parser]\n\n    Sandbox --&gt; Docker[Docker Containers]\n    Sandbox --&gt; Kali[Kali Linux Tools]\n\n    VectorDB --&gt; ChromaDB[ChromaDB]\n    VectorDB --&gt; MITRE[MITRE ATT&amp;CK]\n    VectorDB --&gt; CWE[CWE Database]\n    VectorDB --&gt; CAPEC[CAPEC Database]\n\n    CVE --&gt; NIST[NIST NVD]\n    CVE --&gt; GitHub[GitHub Security]</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#1-installation","title":"1. Installation","text":"<p>Follow the installation guide to set up IVExES with all dependencies.</p>"},{"location":"#2-configuration","title":"2. Configuration","text":"<p>Configure IVExES for your environment using the configuration guide.</p>"},{"location":"#3-basic-usage","title":"3. Basic Usage","text":"<p>Learn fundamental workflows with the usage guide.</p>"},{"location":"#4-examples","title":"4. Examples","text":"<p>Explore practical examples in our examples collection.</p>"},{"location":"#5-development","title":"5. Development","text":"<p>Extend IVExES with custom agents using the development guide.</p>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>Documentation: Comprehensive guides and API references</li> <li>Examples: Real-world usage examples and tutorials</li> <li>GitHub: Source code, issues, and contributions</li> <li>Research: Academic papers and research publications</li> </ul>"},{"location":"#license-ethics","title":"License &amp; Ethics","text":"<p>IVExES is licensed under the GNU General Public License v3.0. This framework is designed for:</p> <ul> <li>\u2705 Educational purposes and security research</li> <li>\u2705 Authorized penetration testing and security assessments</li> <li>\u2705 Defensive security tool development</li> <li>\u274c Unauthorized access or malicious activities</li> </ul> <p>Users are responsible for ensuring compliance with applicable laws and regulations.</p> <p>Ready to get started? Jump to the Quick Start Guide or explore our comprehensive documentation.</p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get up and running with IVExES in under 10 minutes. This guide walks you through the essential steps to install, configure, and run your first vulnerability analysis.</p>"},{"location":"quickstart/#1-minute-setup","title":"\ud83d\ude80 1-Minute Setup","text":"<p>The fastest way to get IVExES running:</p> <pre><code># Clone and setup everything\ngit clone https://github.com/LetsDrinkSomeTea/ivexes.git\ncd ivexes\nmake setup\n\n# Add your API key\necho \"LLM_API_KEY=your_openai_api_key_here\" &gt; .secrets.env\n\n# Start analyzing!\npython examples/20_mvp_screen.py\n</code></pre>"},{"location":"quickstart/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.12+ - Check with <code>python --version</code></li> <li>Docker - Check with <code>docker --version</code> </li> <li>Git - Check with <code>git --version</code></li> <li>OpenAI API Key - Get one from OpenAI Platform</li> </ul> <p>Quick Check</p> <p>Run this command to verify all prerequisites: <pre><code>python --version &amp;&amp; docker --version &amp;&amp; git --version\n</code></pre></p>"},{"location":"quickstart/#installation","title":"\ud83d\udee0\ufe0f Installation","text":""},{"location":"quickstart/#option-1-automated-setup-recommended","title":"Option 1: Automated Setup (Recommended)","text":"<p>The <code>make setup</code> command handles everything:</p> <pre><code>git clone https://github.com/LetsDrinkSomeTea/ivexes.git\ncd ivexes\nmake setup\n</code></pre> <p>This will: - \u2705 Build Docker images (nvim-lsp, kali-ssh) - \u2705 Install Python dependencies with uv - \u2705 Start LiteLLM proxy server - \u2705 Initialize vector databases</p>"},{"location":"quickstart/#option-2-manual-setup","title":"Option 2: Manual Setup","text":"<p>For more control over the process:</p> <pre><code># 1. Clone repository\ngit clone https://github.com/LetsDrinkSomeTea/ivexes.git\ncd ivexes\n\n# 2. Install dependencies\nmake sync  # or: uv sync --all-extras --all-packages --group dev\n\n# 3. Build containers\nmake build-images  # or: docker compose --profile images build\n\n# 4. Start services\nmake run-litellm  # or: docker compose up -d\n</code></pre>"},{"location":"quickstart/#configuration","title":"\ud83d\udd11 Configuration","text":""},{"location":"quickstart/#essential-configuration","title":"Essential Configuration","text":"<p>Create your API key configuration:</p> <pre><code># Create secrets file (never commit this!)\ncat &gt; .secrets.env &lt;&lt; EOF\nLLM_API_KEY=your_openai_api_key_here\nOPENAI_API_KEY=your_openai_api_key_here\nLLM_BASE_URL=http://localhost:4000/v1\nEOF\n</code></pre>"},{"location":"quickstart/#basic-settings-optional","title":"Basic Settings (Optional)","text":"<p>Create a <code>.env</code> file for additional settings:</p> <pre><code>cat &gt; .env &lt;&lt; EOF\nMODEL=openai/gpt-4o-mini\nREASONING_MODEL=openai/o4-mini\nTEMPERATURE=0.3\nMAX_TURNS=10\nLOG_LEVEL=INFO\nEOF\n</code></pre>"},{"location":"quickstart/#verification","title":"\u2705 Verification","text":"<p>Verify your installation is working:</p>"},{"location":"quickstart/#1-check-services","title":"1. Check Services","text":"<pre><code># Verify LiteLLM proxy is running\ncurl http://localhost:4000/health/liveliness\n\n# Check Docker containers\ndocker compose ps\n</code></pre>"},{"location":"quickstart/#2-test-import","title":"2. Test Import","text":"<pre><code>python -c \"import ivexes; print('\u2705 IVExES imported successfully')\"\n</code></pre>"},{"location":"quickstart/#3-run-test-suite","title":"3. Run Test Suite","text":"<pre><code>make tests\n</code></pre>"},{"location":"quickstart/#your-first-analysis","title":"\ud83c\udfaf Your First Analysis","text":""},{"location":"quickstart/#example-1-mvp-agent-quickest-start","title":"Example 1: MVP Agent (Quickest Start)","text":"<p>The MVP Agent provides a minimal viable analysis:</p> <pre><code>import asyncio\nfrom ivexes.agents import MVPAgent\nfrom ivexes.config import PartialSettings\n\n# Basic configuration\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    max_turns=10\n)\n\n# Create and run agent\nagent = MVPAgent(settings=settings)\nasyncio.run(agent.run_interactive())\n</code></pre> <p>Save this as <code>my_first_analysis.py</code> and run: <pre><code>python my_first_analysis.py\n</code></pre></p>"},{"location":"quickstart/#example-2-single-agent-with-codebase","title":"Example 2: Single Agent with Codebase","text":"<p>For analyzing actual code vulnerabilities:</p> <pre><code>import asyncio\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    codebase_path='/path/to/your/project',\n    vulnerable_folder='vulnerable-version',\n    patched_folder='patched-version',\n    max_turns=15\n)\n\nagent = SingleAgent(settings=settings)\nasyncio.run(agent.run_interactive())\n</code></pre>"},{"location":"quickstart/#example-3-using-pre-built-examples","title":"Example 3: Using Pre-built Examples","text":"<p>Run one of the included examples:</p> <pre><code># MVP analysis example\npython examples/20_mvp_screen.py\n\n# Single agent analysis\npython examples/60_single_agent_screen.py\n\n# Multi-agent orchestration\npython examples/70_multi_agent_screen.py\n</code></pre>"},{"location":"quickstart/#interaction-modes","title":"\ud83d\udde8\ufe0f Interaction Modes","text":"<p>IVExES supports three execution modes:</p>"},{"location":"quickstart/#interactive-mode","title":"Interactive Mode","text":"<p><pre><code>await agent.run_interactive()\n</code></pre> - \u2705 Best for exploration and learning - \u2705 Real-time conversation with the agent - \u2705 Type <code>exit</code>, <code>quit</code>, or <code>q</code> to end</p>"},{"location":"quickstart/#streaming-mode","title":"Streaming Mode","text":"<p><pre><code>async for chunk in agent.run_streamed():\n    print(chunk, end='')\n</code></pre> - \u2705 Real-time output as analysis progresses - \u2705 Good for monitoring long-running analyses - \u2705 Integrates well with web interfaces</p>"},{"location":"quickstart/#synchronous-mode","title":"Synchronous Mode","text":"<p><pre><code>result = agent.run()\nprint(result)\n</code></pre> - \u2705 Simple one-shot analysis - \u2705 Best for scripting and automation - \u2705 Returns complete analysis result</p>"},{"location":"quickstart/#customization","title":"\ud83c\udfa8 Customization","text":""},{"location":"quickstart/#model-selection","title":"Model Selection","text":"<p>Choose different models for different tasks:</p> <pre><code>settings = PartialSettings(\n    model='openai/gpt-4o',           # More capable but slower\n    reasoning_model='openai/o4-mini', # For complex reasoning\n    temperature=0.1,                  # More deterministic\n)\n</code></pre>"},{"location":"quickstart/#analysis-scope","title":"Analysis Scope","text":"<p>Configure what gets analyzed:</p> <pre><code>settings = PartialSettings(\n    codebase_path='/path/to/project',\n    vulnerable_folder='v1.0-vulnerable',\n    patched_folder='v1.1-patched',\n    setup_archive='/path/to/setup.tgz',  # Optional setup files\n)\n</code></pre>"},{"location":"quickstart/#vector-database","title":"Vector Database","text":"<p>Enable enhanced knowledge base searching:</p> <pre><code>settings = PartialSettings(\n    embedding_provider='openai',        # or 'builtin', 'local'\n    embedding_model='text-embedding-3-large',\n    chroma_path='/custom/db/path',      # Optional custom path\n)\n</code></pre>"},{"location":"quickstart/#common-workflows","title":"\ud83d\udd27 Common Workflows","text":""},{"location":"quickstart/#1-cve-analysis","title":"1. CVE Analysis","text":"<pre><code>from ivexes.agents import SingleAgent\n\n# Analyze a specific CVE\nagent = SingleAgent()\n# In interactive mode, ask:\n# \"Analyze CVE-2024-12345 and explain the vulnerability\"\n</code></pre>"},{"location":"quickstart/#2-code-diff-analysis","title":"2. Code Diff Analysis","text":"<pre><code>settings = PartialSettings(\n    codebase_path='/path/to/project',\n    vulnerable_folder='before-patch',\n    patched_folder='after-patch'\n)\nagent = SingleAgent(settings=settings)\n# Ask: \"What vulnerability was fixed in the patch?\"\n</code></pre>"},{"location":"quickstart/#3-ctf-challenge","title":"3. CTF Challenge","text":"<pre><code>from ivexes.agents import HTBChallengeAgent\n\nagent = HTBChallengeAgent(\n    challenge_name=\"buffer_overflow_basic\",\n    settings=settings\n)\n</code></pre>"},{"location":"quickstart/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"quickstart/#common-issues","title":"Common Issues","text":"<p>\u274c \"ModuleNotFoundError: No module named 'ivexes'\" <pre><code># Reinstall dependencies\nmake sync\n# or\nuv sync --all-extras --all-packages --group dev\n</code></pre></p> <p>\u274c \"Connection refused\" when contacting LiteLLM <pre><code># Restart LiteLLM service\ndocker compose restart litellm\n# Check if port 4000 is available\nlsof -i :4000\n</code></pre></p> <p>\u274c \"Docker permission denied\" <pre><code># Add user to docker group\nsudo usermod -aG docker $USER\n# Logout and login again\n</code></pre></p> <p>\u274c \"API key not found\" <pre><code># Verify .secrets.env exists and contains your key\ncat .secrets.env\n# Ensure the file is in the project root directory\n</code></pre></p>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<ol> <li>Check logs: <code>docker compose logs litellm</code></li> <li>Run diagnostics: <code>make tests</code></li> <li>Review configuration: See Configuration Guide</li> <li>Search issues: Check GitHub Issues</li> </ol>"},{"location":"quickstart/#learning-path","title":"\ud83c\udf93 Learning Path","text":"<p>Now that you're up and running, here's your learning path:</p>"},{"location":"quickstart/#beginner-first-hour","title":"Beginner (First Hour)","text":"<ol> <li>\u2705 Complete this quickstart guide</li> <li>\ud83d\udcd6 Read Usage Guide for basic workflows</li> <li>\ud83d\udd0d Explore Examples for practical use cases</li> </ol>"},{"location":"quickstart/#intermediate-first-day","title":"Intermediate (First Day)","text":"<ol> <li>\ud83c\udfd7\ufe0f Understand Architecture </li> <li>\u2699\ufe0f Master Configuration options</li> <li>\ud83e\udd16 Learn about different Agent Types</li> </ol>"},{"location":"quickstart/#advanced-first-week","title":"Advanced (First Week)","text":"<ol> <li>\ud83d\udee0\ufe0f Study Development Guide</li> <li>\ud83d\udd0c Explore API Reference for all components</li> <li>\ud83d\ude80 Build custom agents and tools</li> </ol>"},{"location":"quickstart/#pro-tips","title":"\ud83d\udca1 Pro Tips","text":"<p>Performance Tip</p> <p>Start with <code>gpt-4o-mini</code> for faster responses, then upgrade to <code>gpt-4o</code> for complex analyses.</p> <p>Cost Optimization</p> <p>Set <code>MAX_TURNS=5</code> for initial testing to limit API usage.</p> <p>Security Note</p> <p>Never commit <code>.secrets.env</code> to version control. Add it to <code>.gitignore</code>.</p> <p>Debugging</p> <p>Set <code>LOG_LEVEL=DEBUG</code> in your <code>.env</code> file for detailed troubleshooting information.</p>"},{"location":"quickstart/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Choose your path:</p> <ul> <li>\ud83d\udd0d Explore Examples: Try different analysis examples</li> <li>\u2699\ufe0f Advanced Setup: Customize your configuration</li> <li>\ud83c\udfd7\ufe0f Learn Architecture: Understand the system design</li> <li>\ud83d\udee0\ufe0f Start Developing: Read the development guide</li> <li>\ud83d\udcda API Deep Dive: Browse the API reference</li> </ul> <p>Ready for your first real analysis? Head to the Usage Guide to learn core workflows and best practices.</p>"},{"location":"api/agents/","title":"Agents API Reference","text":""},{"location":"api/agents/#overview","title":"Overview","text":"<p>The agents module provides the core intelligence layer of IVEXES, implementing various analysis strategies through specialized AI agents. Each agent is designed for specific vulnerability analysis tasks, from individual assessments to complex multi-agent orchestrations.</p> <p>The agents system follows a hierarchical architecture with a common base class that provides shared functionality, and specialized implementations for different analysis scenarios.</p>"},{"location":"api/agents/#base-classes","title":"Base Classes","text":""},{"location":"api/agents/#baseagent","title":"BaseAgent","text":"<p>The foundational abstract class that provides common functionality for all agents in the system.</p> <pre><code>from ivexes.agents import BaseAgent\nfrom ivexes.config import PartialSettings\n</code></pre>"},{"location":"api/agents/#class-definition","title":"Class Definition","text":"<pre><code>class BaseAgent(ABC):\n    \"\"\"Base class for all agents providing common functionality and interface.\n\n    This abstract base class defines the common interface and functionality\n    for all agents in the system. It handles settings management, agent\n    initialization, and provides different execution modes.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, settings: PartialSettings):\n    \"\"\"Initialize the base agent with settings.\n\n    Args:\n        settings: Partial settings to configure the agent. Settings not provided\n            will be loaded from environment variables.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#key-properties","title":"Key Properties","text":"Property Type Description <code>settings</code> <code>Settings</code> Complete configuration settings <code>turns_left</code> <code>int</code> Remaining conversation turns <code>agent</code> <code>Optional[Agent]</code> Underlying AI agent instance <code>user_msg</code> <code>Optional[str]</code> Default user message <code>session</code> <code>SQLiteSession</code> Session tracking database <code>code_browser</code> <code>Optional[CodeBrowser]</code> Code analysis service <code>printer</code> <code>Printer</code> Output formatting service <code>vector_db</code> <code>CweCapecAttackDatabase</code> Vector database service"},{"location":"api/agents/#core-methods","title":"Core Methods","text":""},{"location":"api/agents/#abstract-methods","title":"Abstract Methods","text":"<pre><code>@abstractmethod\ndef _setup_agent(self):\n    \"\"\"Set up the agent instance.\n\n    This method must be implemented by subclasses to initialize the agent\n    and user message. Should set self.agent and self.user_msg.\n\n    Raises:\n        NotImplementedError: If not implemented by subclass.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#execution-methods","title":"Execution Methods","text":"<pre><code>def run(self, user_msg: Optional[str] = None) -&gt; RunResult:\n    \"\"\"Run the agent synchronously.\n\n    Args:\n        user_msg: Optional user message to override the default.\n\n    Returns:\n        RunResult: The result of the agent execution.\n    \"\"\"\n\ndef run_p(self, user_msg: Optional[str] = None) -&gt; None:\n    \"\"\"Run the agent synchronously and print the result.\n\n    Args:\n        user_msg: Optional user message to override the default.\n    \"\"\"\n\ndef run_streamed(self, user_msg: Optional[str] = None) -&gt; RunResultStreaming:\n    \"\"\"Run the agent with streaming results.\n\n    Args:\n        user_msg: Optional user message to override the default.\n\n    Returns:\n        RunResultStreaming: The streaming result of the agent execution.\n    \"\"\"\n\nasync def run_streamed_p(self, user_msg: Optional[str] = None) -&gt; None:\n    \"\"\"Run the agent with streaming output.\n\n    Args:\n        user_msg: Optional user message to override the default.\n    \"\"\"\n\nasync def run_interactive(\n    self,\n    user_msg: Optional[str] = None,\n    result_hook: Callable[[RunResultStreaming], None] | None = None,\n) -&gt; None:\n    \"\"\"Run the agent in interactive mode with continuous user input.\n\n    Allows users to have a conversation with the agent. The session continues\n    until the user types 'exit', 'quit', or 'q'.\n\n    Args:\n        user_msg: Optional user message to override the default.\n        result_hook: Optional callback function to process results.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#utility-methods","title":"Utility Methods","text":"<pre><code>def _check_settings(self, user_msg: Optional[str]):\n    \"\"\"Validate that agent and user message are properly configured.\n\n    Raises:\n        ValueError: If agent or user_msg are not set.\n    \"\"\"\n\ndef _get_runner_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Get common Runner configuration parameters.\n\n    Returns:\n        Dict containing common Runner parameters.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#usage-example","title":"Usage Example","text":"<pre><code>from ivexes.agents import BaseAgent\nfrom ivexes.config import PartialSettings\n\nclass CustomAgent(BaseAgent):\n    def _setup_agent(self):\n        # Configure your custom agent\n        self.user_msg = \"Analyze this code for vulnerabilities\"\n        self.agent = Agent(\n            name=\"Custom\",\n            instructions=\"You are a custom security analyst\",\n            tools=custom_tools\n        )\n\n# Usage\nsettings = PartialSettings(model='openai/gpt-4o-mini')\nagent = CustomAgent(settings)\nresult = agent.run()\n</code></pre>"},{"location":"api/agents/#specialized-agent-classes","title":"Specialized Agent Classes","text":""},{"location":"api/agents/#singleagent","title":"SingleAgent","text":"<p>A comprehensive agent for individual vulnerability analysis with full toolset integration.</p> <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n</code></pre>"},{"location":"api/agents/#class-definition_1","title":"Class Definition","text":"<pre><code>class SingleAgent(BaseAgent):\n    \"\"\"Agent specialized for single agent analysis tasks.\n\n    This agent is configured with sandbox tools, code browser tools,\n    and vector database tools for comprehensive analysis.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, bin_path: str, settings: Optional[PartialSettings] = None):\n    \"\"\"Initialize Single Agent.\n\n    Args:\n        bin_path: Path to the binary to analyze inside the sandbox\n        settings: Optional partial settings to configure the agent\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#features","title":"Features","text":"<ul> <li>Comprehensive Toolset: Sandbox, code browser, vector database, CVE search</li> <li>Code Analysis: Source code structure analysis and diff comparison</li> <li>Dynamic Testing: Isolated sandbox execution environment</li> <li>Knowledge Integration: Access to CWE, CAPEC, MITRE ATT&amp;CK databases</li> <li>Vulnerability Search: Real-time CVE lookup and correlation</li> </ul>"},{"location":"api/agents/#required-configuration","title":"Required Configuration","text":"<p>The SingleAgent requires specific configuration settings:</p> <pre><code>settings = PartialSettings(\n    codebase_path=\"/path/to/code\",\n    vulnerable_folder=\"vulnerable-version\",\n    patched_folder=\"patched-version\"\n)\n</code></pre>"},{"location":"api/agents/#usage-example_1","title":"Usage Example","text":"<pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    codebase_path='/path/to/analysis',\n    vulnerable_folder='vuln-v1.0',\n    patched_folder='patched-v1.1'\n)\n\nagent = SingleAgent(\n    bin_path='/sandbox/target_binary',\n    settings=settings\n)\n\n# Synchronous execution\nresult = agent.run()\n\n# Interactive mode\nawait agent.run_interactive()\n</code></pre>"},{"location":"api/agents/#multiagent","title":"MultiAgent","text":"<p>An orchestrating agent that coordinates multiple specialized agents for complex analysis scenarios.</p> <pre><code>from ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings\n</code></pre>"},{"location":"api/agents/#class-definition_2","title":"Class Definition","text":"<pre><code>class MultiAgent(BaseAgent):\n    \"\"\"Agent specialized for multi-agent coordination tasks.\n\n    This agent creates a planning agent that coordinates multiple\n    specialized agents including security specialist, code analyst,\n    red team operator, and report journalist.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#constructor_2","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    settings: Optional[PartialSettings] = None,\n    subagent_run_config: Optional[RunConfig] = None,\n):\n    \"\"\"Initialize Multi Agent.\n\n    Args:\n        settings: Optional partial settings to configure the agent\n        subagent_run_config: Optional run configuration for subagents\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#architecture","title":"Architecture","text":"<p>The MultiAgent system consists of:</p> <ol> <li>Planning Agent: Coordinates the overall analysis workflow</li> <li>Security Specialist: Expert in CVE, CWE, CAPEC, and ATT&amp;CK frameworks</li> <li>Code Analyst: Analyzes code structure, functions, and differences</li> <li>Red Team Operator: Performs exploitation and penetration testing</li> <li>Report Journalist: Generates comprehensive vulnerability reports</li> </ol>"},{"location":"api/agents/#specialized-sub-agents","title":"Specialized Sub-Agents","text":""},{"location":"api/agents/#security-specialist","title":"Security Specialist","text":"<ul> <li>Purpose: Provides security vulnerability analysis and threat intelligence</li> <li>Tools: Vector database tools, CVE search, shared memory</li> <li>Expertise: CVE, CWE, CAPEC, MITRE ATT&amp;CK frameworks</li> <li>Capabilities: Attack pattern identification, mitigation strategies</li> </ul>"},{"location":"api/agents/#code-analyst","title":"Code Analyst","text":"<ul> <li>Purpose: Analyzes source code structure and identifies vulnerabilities</li> <li>Tools: Code browser tools, shared memory</li> <li>Expertise: Code structure, functions, diffs, classes</li> <li>Capabilities: Static code analysis, vulnerability identification</li> </ul>"},{"location":"api/agents/#red-team-operator","title":"Red Team Operator","text":"<ul> <li>Purpose: Performs active exploitation and penetration testing</li> <li>Tools: Sandbox tools, shared memory</li> <li>Expertise: Exploitation techniques, payload development</li> <li>Capabilities: Dynamic analysis, exploit development</li> </ul>"},{"location":"api/agents/#report-journalist","title":"Report Journalist","text":"<ul> <li>Purpose: Creates comprehensive vulnerability assessment reports</li> <li>Tools: Report generation tools, shared memory</li> <li>Expertise: Technical writing, vulnerability documentation</li> <li>Capabilities: Report generation, finding synthesis</li> </ul>"},{"location":"api/agents/#shared-context-system","title":"Shared Context System","text":"<p>The MultiAgent uses a sophisticated shared context system for coordination:</p> <pre><code>@dataclass\nclass MultiAgentContext:\n    \"\"\"Combined context with agent memories and shared data.\"\"\"\n\n    shared_memory: SharedMemory\n    start_time: datetime\n    agents_usage: dict[str, Usage]\n    report_generated: bool\n    times_reprompted: int\n</code></pre>"},{"location":"api/agents/#sharedmemory","title":"SharedMemory","text":"<pre><code>class SharedMemory:\n    \"\"\"Simple key-value based shared object for cross-agent information.\"\"\"\n\n    def set(self, key: str, value: str):\n        \"\"\"Store a value in shared memory.\"\"\"\n\n    def get(self, key: str, default=None):\n        \"\"\"Retrieve a value from shared memory.\"\"\"\n\n    def keys(self) -&gt; list[str]:\n        \"\"\"Get all available keys.\"\"\"\n\n    def summary(self) -&gt; str:\n        \"\"\"Get a summary of shared memory contents.\"\"\"\n</code></pre>"},{"location":"api/agents/#usage-example_2","title":"Usage Example","text":"<pre><code>from ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    codebase_path='/path/to/analysis',\n    vulnerable_folder='vuln-version',\n    patched_folder='fixed-version'\n)\n\nagent = MultiAgent(settings=settings)\n\n# Stream results with progress tracking\nawait agent.run_streamed_p(\"Perform comprehensive security analysis\")\n\n# Access shared context information\nprint(agent.context.get_usage())\nprint(agent.context.shared_memory.summary())\n</code></pre>"},{"location":"api/agents/#mvpagent","title":"MVPAgent","text":"<p>A minimal viable product agent for basic vulnerability analysis with sandbox capabilities.</p> <pre><code>from ivexes.agents import MVPAgent\nfrom ivexes.config import PartialSettings\n</code></pre>"},{"location":"api/agents/#class-definition_3","title":"Class Definition","text":"<pre><code>class MVPAgent(BaseAgent):\n    \"\"\"Agent specialized for MVP (Minimum Viable Product) analysis.\n\n    This agent is configured to handle MVP tasks with sandbox tools\n    and specific MVP prompts.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#constructor_3","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    vulnerable_version: str,\n    patched_version: str,\n    settings: Optional[PartialSettings] = None,\n):\n    \"\"\"Initialize MVP Agent.\n\n    Args:\n        vulnerable_version: Path to vulnerable version\n        patched_version: Path to patched version\n        settings: Optional partial settings to configure the agent\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#features_1","title":"Features","text":"<ul> <li>Minimal Configuration: Basic setup for quick analysis</li> <li>Sandbox Integration: Isolated execution environment</li> <li>Version Comparison: Vulnerable vs. patched version analysis</li> <li>Streamlined Workflow: Simplified analysis process</li> </ul>"},{"location":"api/agents/#usage-example_3","title":"Usage Example","text":"<pre><code>from ivexes.agents import MVPAgent\nfrom ivexes.config import PartialSettings\n\nagent = MVPAgent(\n    vulnerable_version=\"vulnerable-1.0\",\n    patched_version=\"patched-1.1\",\n    settings=PartialSettings(model='openai/gpt-4o-mini')\n)\n\n# Run basic analysis\nresult = agent.run()\nprint(result.data)\n</code></pre>"},{"location":"api/agents/#htbchallengeagent","title":"HTBChallengeAgent","text":"<p>A specialized agent for Hack The Box challenge exploitation and analysis.</p> <pre><code>from ivexes.agents import HTBChallengeAgent\nfrom ivexes.config import PartialSettings\n</code></pre>"},{"location":"api/agents/#class-definition_4","title":"Class Definition","text":"<pre><code>class HTBChallengeAgent(BaseAgent):\n    \"\"\"Agent specialized for Hack The Box challenge exploitation.\n\n    This agent is configured to handle HTB challenges with sandbox tools\n    and specific reversing prompts.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#constructor_4","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    program: str,\n    challenge: str,\n    settings: Optional[PartialSettings] = None\n):\n    \"\"\"Initialize HTB Challenge Agent.\n\n    Args:\n        program: Program name for the challenge\n        challenge: Challenge description\n        settings: Optional partial settings to configure the agent\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#features_2","title":"Features","text":"<ul> <li>CTF-Focused: Optimized for Capture The Flag challenges</li> <li>Reversing Capabilities: Binary analysis and exploitation</li> <li>Report Generation: Automated challenge solution reports</li> <li>Sandbox Environment: Isolated challenge execution</li> </ul>"},{"location":"api/agents/#usage-example_4","title":"Usage Example","text":"<pre><code>from ivexes.agents import HTBChallengeAgent\nfrom ivexes.config import PartialSettings\n\nagent = HTBChallengeAgent(\n    program=\"ghost\",\n    challenge=\"Find the hidden flag in this binary\",\n    settings=PartialSettings(model='openai/gpt-4o-mini')\n)\n\n# Analyze HTB challenge\nresult = agent.run()\n</code></pre>"},{"location":"api/agents/#defaultagent","title":"DefaultAgent","text":"<p>A general-purpose agent with standard configuration for common use cases.</p> <pre><code>from ivexes.agents import DefaultAgent\nfrom ivexes.config import PartialSettings\n</code></pre>"},{"location":"api/agents/#class-definition_5","title":"Class Definition","text":"<pre><code>class DefaultAgent(BaseAgent):\n    \"\"\"Default agent implementation with standard configuration.\"\"\"\n</code></pre>"},{"location":"api/agents/#features_3","title":"Features","text":"<ul> <li>Standard Configuration: Pre-configured with common settings</li> <li>General Purpose: Suitable for various analysis tasks</li> <li>Balanced Toolset: Moderate tool selection for versatility</li> </ul>"},{"location":"api/agents/#execution-modes","title":"Execution Modes","text":"<p>All agents support three execution modes:</p>"},{"location":"api/agents/#synchronous-mode","title":"Synchronous Mode","text":"<pre><code># Basic synchronous execution\nresult = agent.run(\"Analyze this vulnerability\")\n\n# With output printing\nagent.run_p(\"Analyze this vulnerability\")\n</code></pre>"},{"location":"api/agents/#streaming-mode","title":"Streaming Mode","text":"<pre><code># Streaming execution\nresult_stream = agent.run_streamed(\"Analyze this vulnerability\")\n\n# With streaming output\nawait agent.run_streamed_p(\"Analyze this vulnerability\")\n</code></pre>"},{"location":"api/agents/#interactive-mode","title":"Interactive Mode","text":"<pre><code># Interactive conversation\nawait agent.run_interactive(\"Start vulnerability analysis\")\n\n# With result hooks\ndef process_result(result):\n    print(f\"Tokens used: {result.usage.total_tokens}\")\n\nawait agent.run_interactive(\n    \"Start analysis\",\n    result_hook=process_result\n)\n</code></pre>"},{"location":"api/agents/#settings-integration","title":"Settings Integration","text":"<p>All agents accept <code>PartialSettings</code> for configuration override:</p> <pre><code>from ivexes.config import PartialSettings\n\n# Common settings patterns\nbasic_settings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    temperature=0.3,\n    max_turns=10\n)\n\nadvanced_settings = PartialSettings(\n    model='openai/gpt-4',\n    reasoning_model='openai/o1-mini',\n    temperature=0.1,\n    max_turns=20,\n    codebase_path='/analysis/target',\n    vulnerable_folder='vuln',\n    patched_folder='fixed'\n)\n\n# Agent with custom settings\nagent = SingleAgent(\n    bin_path='/sandbox/binary',\n    settings=advanced_settings\n)\n</code></pre>"},{"location":"api/agents/#error-handling","title":"Error Handling","text":"<p>Agents provide comprehensive error handling:</p> <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\ntry:\n    agent = SingleAgent(\n        bin_path='/sandbox/binary',\n        settings=PartialSettings()\n    )\n    result = agent.run()\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\nexcept MaxTurnsExceeded as e:\n    print(f\"Conversation limit exceeded: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/agents/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/agents/#resource-management","title":"Resource Management","text":"<pre><code># Configure resource limits\nsettings = PartialSettings(\n    max_turns=5,           # Limit conversation turns\n    model='gpt-4o-mini',   # Use smaller model\n    temperature=0.1        # More deterministic output\n)\n\n# Monitor usage\nresult = agent.run()\nprint(f\"Tokens used: {result.usage.total_tokens}\")\n</code></pre>"},{"location":"api/agents/#parallel-execution","title":"Parallel Execution","text":"<pre><code>import asyncio\nfrom ivexes.agents import SingleAgent, MultiAgent\n\nasync def parallel_analysis():\n    \"\"\"Run multiple agents in parallel.\"\"\"\n    tasks = []\n\n    # Create multiple agent instances\n    agent1 = SingleAgent('binary1', settings1)\n    agent2 = SingleAgent('binary2', settings2)\n\n    # Run in parallel\n    tasks.append(agent1.run_streamed_p(\"Analyze binary1\"))\n    tasks.append(agent2.run_streamed_p(\"Analyze binary2\"))\n\n    await asyncio.gather(*tasks)\n\n# Execute parallel analysis\nasyncio.run(parallel_analysis())\n</code></pre>"},{"location":"api/agents/#examples","title":"Examples","text":""},{"location":"api/agents/#basic-vulnerability-analysis","title":"Basic Vulnerability Analysis","text":"<pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\n# Configure for vulnerability analysis\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    codebase_path='/analysis/target',\n    vulnerable_folder='vulnerable',\n    patched_folder='patched',\n    max_turns=15\n)\n\n# Create and run agent\nagent = SingleAgent(\n    bin_path='/sandbox/vulnerable_binary',\n    settings=settings\n)\n\n# Synchronous analysis\nresult = agent.run(\"Perform comprehensive vulnerability analysis\")\nprint(\"Analysis complete:\", result.data)\n</code></pre>"},{"location":"api/agents/#multi-agent-coordination","title":"Multi-Agent Coordination","text":"<pre><code>from ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings\n\n# Configure multi-agent system\nsettings = PartialSettings(\n    model='openai/gpt-4',\n    reasoning_model='openai/o1-mini',\n    codebase_path='/large-project',\n    vulnerable_folder='v1.0',\n    patched_folder='v1.1'\n)\n\n# Create multi-agent system\nmulti_agent = MultiAgent(settings=settings)\n\n# Stream coordinated analysis\nawait multi_agent.run_streamed_p(\n    \"Perform comprehensive security assessment with detailed reporting\"\n)\n\n# Review coordination results\nprint(\"Multi-agent analysis complete\")\nprint(\"Usage summary:\", multi_agent.context.get_usage())\nprint(\"Shared findings:\", multi_agent.context.shared_memory.summary())\n</code></pre>"},{"location":"api/agents/#interactive-analysis-session","title":"Interactive Analysis Session","text":"<pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\n# Setup interactive agent\nagent = SingleAgent(\n    bin_path='/sandbox/target',\n    settings=PartialSettings(model='openai/gpt-4o-mini')\n)\n\n# Define result processing\ndef save_findings(result):\n    \"\"\"Save important findings to file.\"\"\"\n    with open('findings.txt', 'a') as f:\n        f.write(f\"Finding: {result.data}\\n\")\n\n# Run interactive session\nawait agent.run_interactive(\n    \"Begin interactive vulnerability analysis\",\n    result_hook=save_findings\n)\n</code></pre>"},{"location":"api/agents/#see-also","title":"See Also","text":"<ul> <li>Configuration API - Settings and configuration management</li> <li>Code Browser API - Code analysis and navigation</li> <li>Sandbox API - Execution environment management</li> <li>Vector Database API - Knowledge base integration</li> <li>Tools API - Shared utilities and helpers</li> </ul>"},{"location":"api/code_browser/","title":"Code Browser API Reference","text":""},{"location":"api/code_browser/#overview","title":"Overview","text":"<p>The code browser module provides comprehensive code analysis capabilities through Language Server Protocol (LSP) integration. It runs in a containerized Neovim environment to deliver consistent analysis across different programming languages and systems.</p> <p>The module is designed for security-focused code analysis, offering symbol navigation, reference finding, code structure analysis, and diff generation capabilities. All operations run in isolated Docker containers to ensure security and reproducibility.</p>"},{"location":"api/code_browser/#core-classes","title":"Core Classes","text":""},{"location":"api/code_browser/#codebrowser","title":"CodeBrowser","text":"<p>The main interface for LSP-based code analysis and navigation.</p> <pre><code>from ivexes.code_browser import CodeBrowser\nfrom ivexes.config import Settings\n</code></pre>"},{"location":"api/code_browser/#class-definition","title":"Class Definition","text":"<pre><code>class CodeBrowser:\n    \"\"\"LSP-based code browser for comprehensive code analysis.\n\n    This class provides a high-level interface for analyzing codebases using\n    Neovim's Language Server Protocol capabilities in a containerized environment.\n    It supports various programming languages and provides symbol navigation,\n    reference finding, and code structure analysis.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    settings: Settings,\n    port: int = 8080,\n    load: Literal['lazy', 'eager'] = 'lazy',\n) -&gt; None:\n    \"\"\"Initialize the CodeBrowser with codebase and connection parameters.\n\n    Args:\n        settings: Settings instance containing codebase paths and configurations.\n        port: Port number for Neovim TCP connection (default: 8080).\n        load: Load mode - 'lazy' defers initialization, 'eager' initializes immediately.\n\n    Raises:\n        ValueError: If required codebase settings are missing.\n        SystemExit: If connection to Neovim fails.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#required-configuration","title":"Required Configuration","text":"<p>The CodeBrowser requires specific settings to be configured:</p> <pre><code>from ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    codebase_path=\"/path/to/project\",      # Root directory containing code\n    vulnerable_folder=\"vulnerable\",        # Vulnerable version folder name\n    patched_folder=\"patched\"              # Patched version folder name\n)\n</code></pre>"},{"location":"api/code_browser/#properties","title":"Properties","text":"Property Type Description <code>settings</code> <code>Settings</code> Complete configuration settings <code>path</code> <code>str</code> Absolute path to the codebase directory <code>vulnerable_folder</code> <code>str</code> Name of the vulnerable code folder <code>patched_folder</code> <code>str</code> Name of the patched code folder <code>port</code> <code>int</code> TCP port for Neovim connection <code>container</code> <code>Container</code> Docker container instance <code>nvim</code> <code>pynvim.Nvim</code> PyNvim client instance"},{"location":"api/code_browser/#core-methods","title":"Core Methods","text":""},{"location":"api/code_browser/#initialization","title":"Initialization","text":"<pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the CodeBrowser by setting up Docker container and Neovim connection.\n\n    This method sets up the Docker container for the codebase and establishes\n    a connection to Neovim using PyNvim for LSP capabilities.\n\n    Raises:\n        SystemExit: If connection to Neovim fails.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#file-content-analysis","title":"File Content Analysis","text":"<pre><code>def get_file_content(\n    self,\n    file: str,\n    offset: int = 0,\n    limit: int = 50,\n    encode: Literal['auto', 'raw'] = 'auto',\n) -&gt; str | None:\n    \"\"\"Get the content of a file from the container.\n\n    Args:\n        file: Path to the file within the container.\n        offset: Start line number (0-indexed).\n        limit: Maximum number of lines to return.\n        encode: Encoding type - 'auto' uses chardet detection, 'raw' returns bytes.\n\n    Returns:\n        The file content as a string, or None if file not found.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#codebase-structure","title":"Codebase Structure","text":"<pre><code>def get_codebase_structure(self, n: int = 3) -&gt; str:\n    \"\"\"Get the structure of the codebase using the tree command.\n\n    Args:\n        n: Maximum depth level of the tree.\n\n    Returns:\n        String representation of the codebase directory structure.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#symbol-analysis","title":"Symbol Analysis","text":"<pre><code>def get_symbols(self, file: str) -&gt; list[tuple[str, str, int, tuple[int, int]]]:\n    \"\"\"Get all symbols in the specified file using LSP.\n\n    Args:\n        file: Path to the file to analyze.\n\n    Returns:\n        List of tuples containing:\n        - symbol_name (str): Name of the symbol\n        - symbol_type (str): Type of symbol (function, class, variable, etc.)\n        - line_number (int): Line number where symbol is defined\n        - range (tuple): Symbol range as (start_col, end_col)\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#reference-finding","title":"Reference Finding","text":"<pre><code>def get_references(\n    self, symbol: str\n) -&gt; list[tuple[str, str, int, tuple[int, int]]]:\n    \"\"\"Get all references to a symbol in the codebase using LSP.\n\n    Args:\n        symbol: The symbol name to find references for.\n\n    Returns:\n        List of tuples containing:\n        - file_path (str): Path to the file containing the reference\n        - code_context (str): The line of code containing the reference\n        - line_number (int): Line number where reference appears\n        - range (tuple): Reference range as (start_col, end_col)\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#definition-location","title":"Definition Location","text":"<pre><code>def get_definition(self, symbol: str) -&gt; tuple[str, str, int, int]:\n    \"\"\"Find the definition of a symbol using LSP.\n\n    Args:\n        symbol: The symbol name to find the definition for.\n\n    Returns:\n        Tuple containing (definition_content, file_path, begin_line, end_line).\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#diff-generation","title":"Diff Generation","text":"<pre><code>def get_diff(\n    self,\n    options: Optional[list[str]] = None,\n    file1: Optional[str] = None,\n    file2: Optional[str] = None,\n) -&gt; list[str]:\n    \"\"\"Generate diff between vulnerable and patched versions.\n\n    Args:\n        options: Diff command options (default: ['-u', '-w']).\n        file1: First file/directory path (default: vulnerable_folder).\n        file2: Second file/directory path (default: patched_folder).\n\n    Returns:\n        List of strings, each containing the diff for one file.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#usage-examples","title":"Usage Examples","text":""},{"location":"api/code_browser/#basic-code-analysis","title":"Basic Code Analysis","text":"<pre><code>from ivexes.code_browser import CodeBrowser\nfrom ivexes.config import PartialSettings\n\n# Configure code browser\nsettings = PartialSettings(\n    codebase_path='/project/analysis',\n    vulnerable_folder='vulnerable-v1.0',\n    patched_folder='patched-v1.1'\n)\n\n# Create browser instance\nbrowser = CodeBrowser(settings=settings, port=8080)\n\n# Get codebase structure\nstructure = browser.get_codebase_structure(n=3)\nprint(\"Project structure:\")\nprint(structure)\n\n# Analyze file symbols\nsymbols = browser.get_symbols('src/main.c')\nfor name, type_info, line, (start, end) in symbols:\n    print(f\"{name} ({type_info}) at line {line}, columns {start}-{end}\")\n</code></pre>"},{"location":"api/code_browser/#symbol-reference-analysis","title":"Symbol Reference Analysis","text":"<pre><code># Find all references to a function\nreferences = browser.get_references('vulnerable_function')\nprint(f\"Found {len(references)} references:\")\n\nfor file_path, code_context, line, (start, end) in references:\n    print(f\"  {file_path}:{line}:{start}-{end}\")\n    print(f\"    {code_context}\")\n</code></pre>"},{"location":"api/code_browser/#definition-retrieval","title":"Definition Retrieval","text":"<pre><code># Get function definition\ndefinition, file_path, start_line, end_line = browser.get_definition('malloc')\nprint(f\"Definition found in {file_path} (lines {start_line}-{end_line}):\")\nprint(definition)\n</code></pre>"},{"location":"api/code_browser/#code-comparison","title":"Code Comparison","text":"<pre><code># Generate diff between versions\ndiffs = browser.get_diff(options=['-u', '-w'])\nprint(f\"Found differences in {len(diffs)} files:\")\n\nfor diff in diffs:\n    print(\"=\" * 50)\n    print(diff)\n</code></pre>"},{"location":"api/code_browser/#file-content-reading","title":"File Content Reading","text":"<pre><code># Read file with pagination\ncontent = browser.get_file_content(\n    file='src/vulnerable.c',\n    offset=100,    # Start from line 100\n    limit=50,      # Read 50 lines\n    encode='auto'  # Auto-detect encoding\n)\nprint(\"File content (lines 100-150):\")\nprint(content)\n</code></pre>"},{"location":"api/code_browser/#container-management","title":"Container Management","text":""},{"location":"api/code_browser/#setup_container","title":"setup_container","text":"<p>Container setup and lifecycle management for Neovim LSP analysis.</p> <pre><code>from ivexes.code_browser.nvim import setup_container\nfrom ivexes.config import Settings\n</code></pre>"},{"location":"api/code_browser/#function-definition","title":"Function Definition","text":"<pre><code>def setup_container(\n    code_base: str, \n    settings: Settings, \n    port: int = 8080, \n    renew: bool = False\n) -&gt; Container:\n    \"\"\"Set up a Docker container with codebase mounted for Neovim LSP analysis.\n\n    Args:\n        code_base: Path to the codebase directory to be mounted.\n        settings: Configuration settings for the container.\n        port: Port number to expose from the container.\n        renew: Whether to remove existing container and create new one.\n\n    Returns:\n        Docker container object configured for LSP analysis.\n\n    Raises:\n        ContainerError: If container creation fails.\n        ImageNotFound: If nvim-lsp image is not available.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#container-configuration","title":"Container Configuration","text":"<p>The setup function creates containers with:</p> <ul> <li>Image: <code>nvim-lsp:latest</code> with pre-configured LSP servers</li> <li>Volume Mount: Codebase mounted read-only at <code>/codebase</code></li> <li>Port Mapping: Neovim TCP server exposed on specified port</li> <li>Auto-removal: Container removed when stopped</li> <li>Startup Delay: 30-second initialization period</li> </ul>"},{"location":"api/code_browser/#usage-example","title":"Usage Example","text":"<pre><code>from ivexes.code_browser.nvim import setup_container\nfrom ivexes.config import create_settings\n\nsettings = create_settings()\ncontainer = setup_container(\n    code_base='/path/to/project',\n    settings=settings,\n    port=8080,\n    renew=True  # Force new container creation\n)\n\nprint(f\"Container {container.name} running on port 8080\")\n</code></pre>"},{"location":"api/code_browser/#parser-functions","title":"Parser Functions","text":""},{"location":"api/code_browser/#symbol-parsing","title":"Symbol Parsing","text":""},{"location":"api/code_browser/#parse_symbols","title":"parse_symbols","text":"<p>Parse LSP symbol output into structured data.</p> <pre><code>from ivexes.code_browser.parser import parse_symbols\nfrom pynvim.api import Buffer\n</code></pre>"},{"location":"api/code_browser/#function-definition_1","title":"Function Definition","text":"<pre><code>def parse_symbols(buffer: Buffer) -&gt; list[tuple[str, str, int, tuple[int, int]]]:\n    \"\"\"Parse symbol information from LSP output lines.\n\n    Args:\n        buffer: Buffer containing LSP output in format:\n            &lt;filename&gt;|&lt;line&gt; col &lt;col_start&gt;-&lt;col_end&gt;| [&lt;type&gt;] &lt;name&gt;\n\n    Returns:\n        List of tuples: (name, type, line_no, (col_start, col_end))\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#expected-input-format","title":"Expected Input Format","text":"<pre><code>src/main.c|45 col 12-25| [function] vulnerable_func\nsrc/main.c|67 col 5-15| [variable] buffer_size\ninclude/header.h|23 col 8-20| [struct] user_data\n</code></pre>"},{"location":"api/code_browser/#usage-example_1","title":"Usage Example","text":"<pre><code># Parse symbols from LSP buffer\nsymbols = parse_symbols(nvim_buffer)\nfor name, symbol_type, line, (start, end) in symbols:\n    print(f\"Symbol: {name} ({symbol_type}) at {line}:{start}-{end}\")\n</code></pre>"},{"location":"api/code_browser/#reference-parsing","title":"Reference Parsing","text":""},{"location":"api/code_browser/#parse_references","title":"parse_references","text":"<p>Parse LSP reference output into structured data.</p> <pre><code>from ivexes.code_browser.parser import parse_references\n</code></pre>"},{"location":"api/code_browser/#function-definition_2","title":"Function Definition","text":"<pre><code>def parse_references(buffer: Buffer) -&gt; list[tuple[str, str, int, tuple[int, int]]]:\n    \"\"\"Parse reference information from LSP output lines.\n\n    Args:\n        buffer: Buffer containing LSP output in format:\n            &lt;filename&gt;|&lt;line&gt; col &lt;col_start&gt;-&lt;col_end&gt;| &lt;code&gt;\n\n    Returns:\n        List of tuples: (filename, code, line_no, (col_start, col_end))\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#expected-input-format_1","title":"Expected Input Format","text":"<pre><code>src/main.c|45 col 12-25| vulnerable_func(user_input);\nsrc/utils.c|78 col 8-21| if (vulnerable_func(data) &lt; 0)\ntest/test.c|34 col 16-29| result = vulnerable_func(buffer);\n</code></pre>"},{"location":"api/code_browser/#usage-example_2","title":"Usage Example","text":"<pre><code># Parse references from LSP buffer\nreferences = parse_references(nvim_buffer)\nfor filename, code, line, (start, end) in references:\n    print(f\"Reference in {filename}:{line}:{start}-{end}\")\n    print(f\"  Code: {code}\")\n</code></pre>"},{"location":"api/code_browser/#agent-integration-tools","title":"Agent Integration Tools","text":""},{"location":"api/code_browser/#code-browser-tools","title":"Code Browser Tools","text":"<p>Agent-compatible tools that wrap CodeBrowser functionality for multi-agent systems.</p> <pre><code>from ivexes.code_browser.tools import create_code_browser_tools\nfrom ivexes.code_browser import CodeBrowser\nfrom ivexes.config import Settings\n</code></pre>"},{"location":"api/code_browser/#tool-factory","title":"Tool Factory","text":"<pre><code>def create_code_browser_tools(\n    code_browser: Optional[CodeBrowser] = None, \n    settings: Optional[Settings] = None\n) -&gt; list[Tool]:\n    \"\"\"Create code browser tools with dependency injection.\n\n    Args:\n        code_browser: Existing CodeBrowser instance (optional).\n        settings: Settings for creating new CodeBrowser if needed.\n\n    Returns:\n        List of agent-compatible tools for code analysis.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#available-tools","title":"Available Tools","text":""},{"location":"api/code_browser/#codebrowser_get_definition","title":"codebrowser_get_definition","text":"<pre><code>@function_tool\ndef codebrowser_get_definition(symbol: str) -&gt; str:\n    \"\"\"Find the definition of a symbol in the codebase.\n\n    Args:\n        symbol: The symbol name to find the definition for.\n\n    Returns:\n        Formatted definition with location information.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#codebrowser_get_references","title":"codebrowser_get_references","text":"<pre><code>@function_tool\ndef codebrowser_get_references(symbol: str) -&gt; str:\n    \"\"\"Find all references to a symbol in the codebase.\n\n    Args:\n        symbol: The symbol name to find references for.\n\n    Returns:\n        Formatted list of all references with locations.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#codebrowser_get_symbols","title":"codebrowser_get_symbols","text":"<pre><code>@function_tool\ndef codebrowser_get_symbols(file: str) -&gt; str:\n    \"\"\"Get all symbols in a file.\n\n    Args:\n        file: Path to the file within the codebase to analyze.\n\n    Returns:\n        Formatted list of all symbols with types and locations.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#codebrowser_get_file_content","title":"codebrowser_get_file_content","text":"<pre><code>@function_tool\ndef codebrowser_get_file_content(\n    file: str,\n    offset: int = 0,\n    limit: int = 50,\n    encode: Literal['auto', 'raw'] = 'auto',\n) -&gt; str:\n    \"\"\"Get the content of a file in the codebase.\n\n    Args:\n        file: Path to the file within the codebase.\n        offset: Line number to start reading from (0-based).\n        limit: Maximum number of lines to read.\n        encode: Encoding type - 'auto' or 'raw'.\n\n    Returns:\n        Formatted file content.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#codebrowser_get_file_structure","title":"codebrowser_get_file_structure","text":"<pre><code>@function_tool\ndef codebrowser_get_file_structure(depth: int = 3) -&gt; str:\n    \"\"\"Get the tree of files in the codebase.\n\n    Args:\n        depth: Maximum depth level of the tree.\n\n    Returns:\n        Formatted directory tree structure.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#codebrowser_get_diff","title":"codebrowser_get_diff","text":"<pre><code>@function_tool\ndef codebrowser_get_diff(\n    file1: str = 'vulnerable_folder',\n    file2: str = 'patched_folder',\n    options: Optional[list[str]] = None,\n) -&gt; str:\n    \"\"\"Get the diff between code versions.\n\n    Args:\n        file1: First file/directory to compare.\n        file2: Second file/directory to compare.\n        options: Diff command options.\n\n    Returns:\n        Formatted diff output.\n    \"\"\"\n</code></pre>"},{"location":"api/code_browser/#agent-integration-example","title":"Agent Integration Example","text":"<pre><code>from ivexes.code_browser.tools import create_code_browser_tools\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\n# Create agent with code browser tools\nsettings = PartialSettings(\n    codebase_path='/analysis/project',\n    vulnerable_folder='vulnerable',\n    patched_folder='patched'\n)\n\n# Tools are automatically integrated into agents\nagent = SingleAgent(bin_path='/target/binary', settings=settings)\n\n# Agent can now use code browser capabilities\nresult = agent.run(\"\"\"\nAnalyze the codebase structure, find the main function, \nand identify any vulnerable functions it calls.\n\"\"\")\n</code></pre>"},{"location":"api/code_browser/#error-handling","title":"Error Handling","text":""},{"location":"api/code_browser/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"api/code_browser/#container-setup-errors","title":"Container Setup Errors","text":"<pre><code>from docker.errors import ContainerError, ImageNotFound\n\ntry:\n    browser = CodeBrowser(settings=settings)\n    browser.initialize()\nexcept ContainerError as e:\n    print(f\"Container failed to start: {e}\")\n    # Check Docker daemon and container configuration\nexcept ImageNotFound as e:\n    print(f\"Required image not found: {e}\")\n    # Build or pull the nvim-lsp:latest image\n</code></pre>"},{"location":"api/code_browser/#configuration-errors","title":"Configuration Errors","text":"<pre><code>from ivexes.code_browser import CodeBrowser\nfrom ivexes.config import PartialSettings\n\ntry:\n    settings = PartialSettings()  # Missing required paths\n    browser = CodeBrowser(settings=settings)\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\n    # Ensure codebase_path, vulnerable_folder, and patched_folder are set\n</code></pre>"},{"location":"api/code_browser/#lsp-analysis-errors","title":"LSP Analysis Errors","text":"<pre><code>try:\n    symbols = browser.get_symbols('nonexistent_file.c')\nexcept Exception as e:\n    print(f\"Symbol analysis failed: {e}\")\n    # Check file path and LSP server status\n\ntry:\n    references = browser.get_references('unknown_symbol')\n    if not references:\n        print(\"No references found - symbol may not exist\")\nexcept Exception as e:\n    print(f\"Reference search failed: {e}\")\n</code></pre>"},{"location":"api/code_browser/#best-practices","title":"Best Practices","text":""},{"location":"api/code_browser/#resource-management","title":"Resource Management","text":"<pre><code>import logging\nfrom ivexes.code_browser import CodeBrowser\n\n# Configure logging for debugging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Use lazy loading for performance\nbrowser = CodeBrowser(settings=settings, load='lazy')\n\n# Initialize only when needed\nif analysis_needed:\n    browser.initialize()\n</code></pre>"},{"location":"api/code_browser/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Limit file content reading\ncontent = browser.get_file_content(\n    file='large_file.c',\n    offset=0,\n    limit=100  # Read only first 100 lines\n)\n\n# Use appropriate tree depth\nstructure = browser.get_codebase_structure(n=2)  # Shallow structure for overview\n</code></pre>"},{"location":"api/code_browser/#container-management_1","title":"Container Management","text":"<pre><code>from ivexes.code_browser.nvim import setup_container\n\n# Force container renewal for clean state\ncontainer = setup_container(\n    code_base='/path/to/code',\n    settings=settings,\n    renew=True  # Clean container\n)\n\n# Use unique ports for parallel analysis\nbrowser1 = CodeBrowser(settings=settings1, port=8080)\nbrowser2 = CodeBrowser(settings=settings2, port=8081)\n</code></pre>"},{"location":"api/code_browser/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/code_browser/#container-optimization","title":"Container Optimization","text":"<ul> <li>Container Reuse: Containers are reused by default to improve performance</li> <li>Image Preparation: Ensure <code>nvim-lsp:latest</code> image is pre-built and cached</li> <li>Volume Mounting: Read-only mounts improve security and performance</li> </ul>"},{"location":"api/code_browser/#lsp-server-performance","title":"LSP Server Performance","text":"<ul> <li>Language Support: Different LSP servers have varying performance characteristics</li> <li>Project Size: Large codebases may require longer initialization times</li> <li>Symbol Caching: LSP servers cache symbol information for better performance</li> </ul>"},{"location":"api/code_browser/#memory-management","title":"Memory Management","text":"<ul> <li>File Reading: Use <code>offset</code> and <code>limit</code> parameters for large files</li> <li>Symbol Analysis: Results are processed incrementally to manage memory</li> <li>Container Limits: Consider Docker memory constraints for large codebases</li> </ul>"},{"location":"api/code_browser/#examples","title":"Examples","text":""},{"location":"api/code_browser/#complete-vulnerability-analysis","title":"Complete Vulnerability Analysis","text":"<pre><code>import asyncio\nfrom ivexes.code_browser import CodeBrowser\nfrom ivexes.config import PartialSettings\n\nasync def vulnerability_analysis():\n    \"\"\"Complete vulnerability analysis using code browser.\"\"\"\n\n    settings = PartialSettings(\n        codebase_path='/analysis/vulnerable-app',\n        vulnerable_folder='v1.0-vulnerable',\n        patched_folder='v1.1-fixed'\n    )\n\n    browser = CodeBrowser(settings=settings)\n\n    print(\"=== Codebase Structure ===\")\n    structure = browser.get_codebase_structure(n=3)\n    print(structure)\n\n    print(\"\\n=== Main Function Analysis ===\")\n    main_symbols = browser.get_symbols('src/main.c')\n    for name, type_info, line, range_info in main_symbols:\n        if 'main' in name.lower():\n            print(f\"Found {name} ({type_info}) at line {line}\")\n\n    print(\"\\n=== Vulnerability Search ===\")\n    vulnerable_functions = ['strcpy', 'strcat', 'sprintf', 'gets']\n\n    for func in vulnerable_functions:\n        references = browser.get_references(func)\n        if references:\n            print(f\"\\n{func} used in {len(references)} locations:\")\n            for file_path, code, line, _ in references:\n                print(f\"  {file_path}:{line} - {code.strip()}\")\n\n    print(\"\\n=== Code Changes Analysis ===\")\n    diffs = browser.get_diff()\n    for i, diff in enumerate(diffs):\n        print(f\"\\n--- File Change {i+1} ---\")\n        print(diff[:500] + \"...\" if len(diff) &gt; 500 else diff)\n\nasyncio.run(vulnerability_analysis())\n</code></pre>"},{"location":"api/code_browser/#multi-file-symbol-search","title":"Multi-File Symbol Search","text":"<pre><code>def search_symbols_across_files(browser, symbol_pattern):\n    \"\"\"Search for symbols matching a pattern across multiple files.\"\"\"\n\n    # Get all C files in the project\n    structure = browser.get_codebase_structure(n=5)\n\n    # Extract .c and .h files (simple pattern matching)\n    import re\n    files = re.findall(r'[^\\s]+\\.c(?:pp)?|[^\\s]+\\.h(?:pp)?', structure)\n\n    results = {}\n    for file in files[:10]:  # Limit to first 10 files\n        try:\n            symbols = browser.get_symbols(file)\n            matching_symbols = [\n                (name, type_info, line, range_info) \n                for name, type_info, line, range_info in symbols\n                if symbol_pattern.lower() in name.lower()\n            ]\n            if matching_symbols:\n                results[file] = matching_symbols\n        except Exception as e:\n            print(f\"Error analyzing {file}: {e}\")\n\n    return results\n\n# Usage\nbrowser = CodeBrowser(settings=settings)\nbuffer_symbols = search_symbols_across_files(browser, 'buffer')\n\nfor file, symbols in buffer_symbols.items():\n    print(f\"\\nBuffer-related symbols in {file}:\")\n    for name, type_info, line, _ in symbols:\n        print(f\"  {name} ({type_info}) at line {line}\")\n</code></pre>"},{"location":"api/code_browser/#see-also","title":"See Also","text":"<ul> <li>Agents API - Agent classes that integrate code browser functionality</li> <li>Configuration API - Settings and configuration management</li> <li>Sandbox API - Execution environment management for dynamic analysis</li> <li>Tools API - Additional utility functions and tools</li> <li>Usage Guide - Common workflows and best practices</li> </ul>"},{"location":"api/config/","title":"Configuration API Reference","text":""},{"location":"api/config/#overview","title":"Overview","text":"<p>The configuration module provides robust settings management for IVEXES using Pydantic models with environment variable support, validation, and type safety. It centralizes all application configuration and provides flexible override mechanisms for different deployment scenarios.</p> <p>The module is designed around two main concepts: the complete <code>Settings</code> class that contains all configuration options, and <code>PartialSettings</code> for selective overrides. All settings support environment variable configuration with automatic type conversion and validation.</p>"},{"location":"api/config/#core-classes","title":"Core Classes","text":""},{"location":"api/config/#settings","title":"Settings","text":"<p>The main configuration class that defines all application settings with validation and environment variable support.</p> <pre><code>from ivexes.config import Settings\nfrom pydantic_settings import BaseSettings\n</code></pre>"},{"location":"api/config/#class-definition","title":"Class Definition","text":"<pre><code>class Settings(BaseSettings):\n    \"\"\"Application settings and configuration management.\n\n    This class defines all configuration options for the IVEXES system using\n    Pydantic for validation and type checking. Settings can be configured via\n    environment variables, which take precedence over default values.\n\n    The settings are organized into logical groups:\n    - API settings: Keys and endpoints for external services\n    - Agent settings: LLM model configuration and behavior\n    - Logging settings: Log levels and tracing configuration\n    - Sandbox settings: Container and environment configuration\n    - Codebase settings: Source code analysis paths\n    - Embedding settings: Vector database and embedding configuration\n    \"\"\"\n</code></pre>"},{"location":"api/config/#configuration-groups","title":"Configuration Groups","text":""},{"location":"api/config/#api-settings","title":"API Settings","text":"<p>LLM service configuration and authentication:</p> Field Type Environment Variable Default Description <code>openai_api_key</code> <code>str \\| None</code> <code>OPENAI_API_KEY</code> <code>None</code> OpenAI-specific API key <code>llm_api_key</code> <code>str</code> <code>LLM_API_KEY</code>, <code>OPENAI_API_KEY</code> <code>\"\"</code> Primary LLM API key <code>llm_base_url</code> <code>str</code> <code>LLM_BASE_URL</code> <code>\"https://api.openai.com/v1\"</code> LLM service endpoint <code>max_reprompts</code> <code>int</code> <code>MAX_REPROMPTS</code> <code>5</code> Maximum retry attempts"},{"location":"api/config/#agent-settings","title":"Agent Settings","text":"<p>AI model configuration and behavior:</p> Field Type Environment Variable Default Description <code>model</code> <code>str</code> <code>MODEL</code> <code>\"openai/gpt-4o-mini\"</code> Primary analysis model <code>model_temperature</code> <code>float</code> <code>MODEL_TEMPERATURE</code> <code>0.3</code> Model creativity (0.0-2.0) <code>reasoning_model</code> <code>str</code> <code>REASONING_MODEL</code> <code>\"openai/o4-mini\"</code> Advanced reasoning model <code>max_turns</code> <code>int</code> <code>MAX_TURNS</code> <code>10</code> Conversation turn limit <code>session_db_path</code> <code>str</code> <code>SESSION_DB_PATH</code> <code>\"./sessions.sqlite\"</code> Session database location"},{"location":"api/config/#logging-settings","title":"Logging Settings","text":"<p>Observability and debugging configuration:</p> Field Type Environment Variable Default Description <code>log_level</code> <code>LogLevels</code> <code>LOG_LEVEL</code> <code>\"INFO\"</code> Logging verbosity level <code>trace_name</code> <code>str</code> <code>TRACE_NAME</code> <code>\"ivexes\"</code> OpenAI tracing identifier"},{"location":"api/config/#sandbox-settings","title":"Sandbox Settings","text":"<p>Container execution environment:</p> Field Type Environment Variable Default Description <code>sandbox_image</code> <code>str</code> <code>SANDBOX_IMAGE</code> <code>\"kali-ssh:latest\"</code> Docker image for analysis <code>setup_archive</code> <code>str \\| None</code> <code>SETUP_ARCHIVE</code> <code>None</code> Archive to extract in sandbox"},{"location":"api/config/#codebase-settings","title":"Codebase Settings","text":"<p>Source code analysis configuration:</p> Field Type Environment Variable Default Description <code>codebase_path</code> <code>str \\| None</code> <code>CODEBASE_PATH</code> <code>None</code> Root project directory <code>vulnerable_folder</code> <code>str \\| None</code> <code>VULNERABLE_CODEBASE_FOLDER</code> <code>None</code> Vulnerable version folder <code>patched_folder</code> <code>str \\| None</code> <code>PATCHED_CODEBASE_FOLDER</code> <code>None</code> Patched version folder"},{"location":"api/config/#embedding-settings","title":"Embedding Settings","text":"<p>Vector database and knowledge base configuration:</p> Field Type Environment Variable Default Description <code>chroma_path</code> <code>str</code> <code>CHROMA_PATH</code> <code>\"/tmp/ivexes/chromadb\"</code> ChromaDB storage path <code>embedding_model</code> <code>str</code> <code>EMBEDDING_MODEL</code> <code>\"builtin\"</code> Embedding model identifier <code>embedding_provider</code> <code>str</code> <code>EMBEDDING_PROVIDER</code> <code>\"builtin\"</code> Embedding service provider"},{"location":"api/config/#validation-methods","title":"Validation Methods","text":"<p>The Settings class includes comprehensive field validation:</p>"},{"location":"api/config/#api-key-validation","title":"API Key Validation","text":"<pre><code>@field_validator('llm_api_key')\n@classmethod\ndef validate_api_keys(cls, v: str) -&gt; str:\n    \"\"\"Validate API keys are not empty.\n\n    Raises:\n        ValueError: If API key is empty or whitespace-only.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#temperature-validation","title":"Temperature Validation","text":"<pre><code>@field_validator('model_temperature')\n@classmethod\ndef validate_temperature(cls, v: float) -&gt; float:\n    \"\"\"Validate temperature is between 0.0 and 2.0.\n\n    Raises:\n        ValueError: If temperature is outside valid range.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#turn-limit-validation","title":"Turn Limit Validation","text":"<pre><code>@field_validator('max_turns')\n@classmethod\ndef validate_max_turns(cls, v: int) -&gt; int:\n    \"\"\"Validate max turns is a positive integer.\n\n    Raises:\n        ValueError: If max_turns is less than 1.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#log-level-validation","title":"Log Level Validation","text":"<pre><code>@field_validator('log_level')\n@classmethod\ndef validate_log_level(cls, v: str) -&gt; str:\n    \"\"\"Validate log level is a valid Python logging level.\n\n    Raises:\n        ValueError: If log level is not one of: DEBUG, INFO, WARNING, ERROR, CRITICAL.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#url-validation","title":"URL Validation","text":"<pre><code>@field_validator('llm_base_url')\n@classmethod\ndef validate_base_url(cls, v: str) -&gt; str:\n    \"\"\"Validate base URL starts with http:// or https://.\n\n    Raises:\n        ValueError: If URL doesn't start with valid protocol.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#embedding-provider-validation","title":"Embedding Provider Validation","text":"<pre><code>@field_validator('embedding_provider')\n@classmethod\ndef validate_embedding_provider(cls, v: str) -&gt; str:\n    \"\"\"Validate embedding provider is supported.\n\n    Raises:\n        ValueError: If provider is not one of: builtin, local, openai.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#trace-name-normalization","title":"Trace Name Normalization","text":"<pre><code>@field_validator('trace_name')\n@classmethod\ndef validate_trace_name(cls, v: str) -&gt; str:\n    \"\"\"Convert trace name to lowercase for consistency.\"\"\"\n</code></pre>"},{"location":"api/config/#usage-example","title":"Usage Example","text":"<pre><code>import os\nfrom ivexes.config import Settings\n\n# Set environment variables\nos.environ['LLM_API_KEY'] = 'sk-your-api-key'\nos.environ['MODEL'] = 'openai/gpt-4'\nos.environ['MODEL_TEMPERATURE'] = '0.1'\nos.environ['LOG_LEVEL'] = 'DEBUG'\n\n# Create settings instance\nsettings = Settings()\n\nprint(f\"Model: {settings.model}\")\nprint(f\"Temperature: {settings.model_temperature}\")  \nprint(f\"API Key: {settings.llm_api_key[:10]}...\")\nprint(f\"Base URL: {settings.llm_base_url}\")\n</code></pre>"},{"location":"api/config/#partialsettings","title":"PartialSettings","text":"<p>A TypedDict that allows specifying any subset of Settings fields for configuration overrides.</p> <pre><code>from ivexes.config import PartialSettings\nfrom typing_extensions import TypedDict\n</code></pre>"},{"location":"api/config/#class-definition_1","title":"Class Definition","text":"<pre><code>class PartialSettings(TypedDict, total=False):\n    \"\"\"Partial settings type for overriding global settings.\n\n    This type allows any subset of Settings fields to be specified\n    for overriding global configuration. All fields are optional.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#available-fields","title":"Available Fields","text":"<p>All fields from the Settings class are available as optional fields:</p> <pre><code># API Settings\nopenai_api_key: Optional[str]\nllm_api_key: str\nllm_base_url: str\n\n# Agent Settings  \nmodel: str\nmodel_temperature: float\nreasoning_model: str\nmax_turns: int\n\n# Logging Settings\ntrace_name: str\nlog_level: LogLevels\n\n# Sandbox Settings\nsandbox_image: str\nsetup_archive: Optional[str]\n\n# Codebase Settings\ncodebase_path: Optional[str]\nvulnerable_folder: Optional[str]\npatched_folder: Optional[str]\n\n# Embedding Settings\nchroma_path: str\nembedding_model: str\nembedding_provider: Literal['builtin', 'local', 'openai']\n\n# UI Settings\nrich_console: Optional[Console]\n</code></pre>"},{"location":"api/config/#usage-examples","title":"Usage Examples","text":""},{"location":"api/config/#basic-override","title":"Basic Override","text":"<pre><code>from ivexes.config import PartialSettings\n\n# Override specific settings\noverrides = PartialSettings(\n    model='openai/gpt-4',\n    model_temperature=0.1,\n    max_turns=20,\n    log_level='DEBUG'\n)\n</code></pre>"},{"location":"api/config/#agent-specific-configuration","title":"Agent-Specific Configuration","text":"<pre><code># Configuration for vulnerability analysis\nvuln_analysis_settings = PartialSettings(\n    model='openai/gpt-4',\n    reasoning_model='openai/o1-mini',\n    model_temperature=0.0,  # Deterministic output\n    max_turns=25,\n    codebase_path='/analysis/target',\n    vulnerable_folder='vulnerable-v1.2',\n    patched_folder='patched-v1.3',\n    trace_name='vuln-analysis',\n    log_level='INFO'\n)\n</code></pre>"},{"location":"api/config/#environment-specific-settings","title":"Environment-Specific Settings","text":"<pre><code># Development environment\ndev_settings = PartialSettings(\n    model='openai/gpt-4o-mini',  # Faster, cheaper\n    log_level='DEBUG',\n    trace_name='dev-testing',\n    chroma_path='/tmp/dev-chromadb'\n)\n\n# Production environment\nprod_settings = PartialSettings(\n    model='openai/gpt-4',         # Most capable\n    model_temperature=0.1,        # More consistent\n    log_level='WARNING',          # Less verbose\n    trace_name='production',\n    chroma_path='/data/chromadb'\n)\n</code></pre>"},{"location":"api/config/#factory-functions","title":"Factory Functions","text":""},{"location":"api/config/#create_settings","title":"create_settings","text":"<p>Creates a Settings instance by merging environment variables with optional partial settings overrides.</p> <pre><code>from ivexes.config import create_settings, PartialSettings\n</code></pre>"},{"location":"api/config/#function-definition","title":"Function Definition","text":"<pre><code>def create_settings(partial_settings: Optional[PartialSettings] = None) -&gt; Settings:\n    \"\"\"Create Settings instance by merging environment variables with partial overrides.\n\n    This function creates a new Settings instance by first loading from environment\n    variables and then applying any partial settings overrides. Final validation\n    is performed on the merged result.\n\n    Args:\n        partial_settings: Optional dictionary containing settings to override.\n                         Only the specified fields will be updated.\n\n    Returns:\n        Settings: A new settings instance with merged configuration.\n\n    Raises:\n        RuntimeError: If settings validation fails with details about\n            which configuration values are invalid.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#merge-process","title":"Merge Process","text":"<ol> <li>Environment Loading: Load all settings from environment variables</li> <li>Partial Override: Apply any provided partial settings</li> <li>Validation: Perform comprehensive validation on merged configuration</li> <li>Error Reporting: Provide detailed error messages for invalid values</li> </ol>"},{"location":"api/config/#usage-examples_1","title":"Usage Examples","text":""},{"location":"api/config/#basic-usage","title":"Basic Usage","text":"<pre><code>from ivexes.config import create_settings\n\n# Use environment variables only\nsettings = create_settings()\nprint(f\"Using model: {settings.model}\")\n</code></pre>"},{"location":"api/config/#with-overrides","title":"With Overrides","text":"<pre><code>from ivexes.config import create_settings, PartialSettings\n\n# Override specific values\nsettings = create_settings(\n    PartialSettings(\n        model='openai/gpt-4',\n        model_temperature=0.7,\n        max_turns=20,\n        log_level='DEBUG'\n    )\n)\n\nprint(f\"Model: {settings.model}\")\nprint(f\"Temperature: {settings.model_temperature}\")\n</code></pre>"},{"location":"api/config/#error-handling","title":"Error Handling","text":"<pre><code>from ivexes.config import create_settings, PartialSettings\n\ntry:\n    settings = create_settings(\n        PartialSettings(\n            model_temperature=3.0,  # Invalid: &gt; 2.0\n            max_turns=-1,           # Invalid: negative\n            log_level='INVALID'     # Invalid: not a valid level\n        )\n    )\nexcept RuntimeError as e:\n    print(\"Configuration validation failed:\")\n    print(e)\n    # Output shows specific validation errors for each field\n</code></pre>"},{"location":"api/config/#get_run_config","title":"get_run_config","text":"<p>Creates a RunConfig instance configured with current settings for agent execution.</p> <pre><code>from ivexes.config import get_run_config, Settings\nfrom agents import RunConfig\n</code></pre>"},{"location":"api/config/#function-definition_1","title":"Function Definition","text":"<pre><code>def get_run_config(settings: Optional[Settings] = None) -&gt; RunConfig:\n    \"\"\"Get RunConfig for the application, configured with current settings.\n\n    This function creates a RunConfig instance that contains all necessary\n    configuration for running AI agents, including model settings, provider\n    configuration, and temperature settings.\n\n    Args:\n        settings: Settings instance containing application configuration.\n                 If not provided, loads from environment variables.\n\n    Returns:\n        RunConfig: Configured run configuration for agent execution.\n    \"\"\"\n</code></pre>"},{"location":"api/config/#configuration-details","title":"Configuration Details","text":"<p>The function creates a RunConfig with:</p> <ul> <li>Custom Model Provider: Configured with LLM base URL and API key</li> <li>Model Settings: Temperature and parallel tool call configuration</li> <li>OpenAI Client: Async client with proper authentication</li> </ul>"},{"location":"api/config/#usage-example_1","title":"Usage Example","text":"<pre><code>from ivexes.config import get_run_config, PartialSettings\n\n# Use with custom settings\nsettings = create_settings(\n    PartialSettings(\n        model='openai/gpt-4',\n        model_temperature=0.1,\n        llm_base_url='https://api.openai.com/v1'\n    )\n)\n\nrun_config = get_run_config(settings)\n\n# Use with agents\nfrom agents import Agent\nagent = Agent(name=\"Analyzer\", instructions=\"Analyze code\")\nresult = await agent.run(\"Analyze this code\", run_config=run_config)\n</code></pre>"},{"location":"api/config/#type-definitions","title":"Type Definitions","text":""},{"location":"api/config/#loglevels","title":"LogLevels","text":"<p>Type alias for valid Python logging levels.</p> <pre><code>from ivexes.config import LogLevels\nfrom typing import Literal\n\nLogLevels = Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']\n</code></pre>"},{"location":"api/config/#usage","title":"Usage","text":"<pre><code>from ivexes.config import LogLevels, PartialSettings\n\ndef configure_logging(level: LogLevels):\n    \"\"\"Configure logging with type safety.\"\"\"\n    settings = PartialSettings(log_level=level)\n    return create_settings(settings)\n\n# Type-safe usage\nsettings = configure_logging('DEBUG')  # Valid\nsettings = configure_logging('TRACE')  # Type error\n</code></pre>"},{"location":"api/config/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"api/config/#configuration-factories","title":"Configuration Factories","text":"<pre><code>from ivexes.config import create_settings, PartialSettings\n\nclass ConfigurationFactory:\n    \"\"\"Factory for creating specialized configurations.\"\"\"\n\n    @staticmethod\n    def development_config() -&gt; Settings:\n        \"\"\"Configuration optimized for development.\"\"\"\n        return create_settings(\n            PartialSettings(\n                model='openai/gpt-4o-mini',\n                model_temperature=0.3,\n                log_level='DEBUG',\n                trace_name='development',\n                max_turns=10\n            )\n        )\n\n    @staticmethod\n    def production_config() -&gt; Settings:\n        \"\"\"Configuration optimized for production.\"\"\"\n        return create_settings(\n            PartialSettings(\n                model='openai/gpt-4',\n                model_temperature=0.1,\n                log_level='INFO',\n                trace_name='production',\n                max_turns=20\n            )\n        )\n\n    @staticmethod\n    def security_analysis_config() -&gt; Settings:\n        \"\"\"Configuration optimized for security analysis.\"\"\"\n        return create_settings(\n            PartialSettings(\n                model='openai/gpt-4',\n                reasoning_model='openai/o1-mini',\n                model_temperature=0.0,  # Deterministic\n                max_turns=30,           # Thorough analysis\n                log_level='INFO',\n                trace_name='security-analysis'\n            )\n        )\n\n# Usage\ndev_settings = ConfigurationFactory.development_config()\nprod_settings = ConfigurationFactory.production_config()\nsecurity_settings = ConfigurationFactory.security_analysis_config()\n</code></pre>"},{"location":"api/config/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>import os\nfrom ivexes.config import create_settings, PartialSettings\n\ndef get_environment_config() -&gt; Settings:\n    \"\"\"Get configuration based on environment.\"\"\"\n    env = os.environ.get('ENVIRONMENT', 'development')\n\n    base_config = PartialSettings(\n        trace_name=f'ivexes-{env}'\n    )\n\n    if env == 'production':\n        base_config.update({\n            'model': 'openai/gpt-4',\n            'model_temperature': 0.1,\n            'log_level': 'WARNING',\n            'max_turns': 25\n        })\n    elif env == 'staging':\n        base_config.update({\n            'model': 'openai/gpt-4o-mini',\n            'model_temperature': 0.2,\n            'log_level': 'INFO',\n            'max_turns': 15\n        })\n    else:  # development\n        base_config.update({\n            'model': 'openai/gpt-4o-mini',\n            'model_temperature': 0.3,\n            'log_level': 'DEBUG',\n            'max_turns': 10\n        })\n\n    return create_settings(base_config)\n\n# Usage\nsettings = get_environment_config()\n</code></pre>"},{"location":"api/config/#configuration-validation","title":"Configuration Validation","text":"<pre><code>from ivexes.config import create_settings, PartialSettings\nimport os\n\ndef validate_configuration() -&gt; bool:\n    \"\"\"Validate current configuration and report issues.\"\"\"\n    try:\n        settings = create_settings()\n\n        # Basic validation\n        print(\"\u2705 Configuration loaded successfully\")\n\n        # API key validation\n        if not settings.llm_api_key:\n            print(\"\u274c LLM_API_KEY is required\")\n            return False\n\n        # Model validation\n        if not settings.model.startswith(('openai/', 'anthropic/')):\n            print(f\"\u26a0\ufe0f  Unknown model provider: {settings.model}\")\n\n        # Path validation\n        if settings.codebase_path and not os.path.exists(settings.codebase_path):\n            print(f\"\u274c Codebase path does not exist: {settings.codebase_path}\")\n            return False\n\n        # ChromaDB path validation\n        chroma_dir = os.path.dirname(settings.chroma_path)\n        if not os.path.exists(chroma_dir):\n            try:\n                os.makedirs(chroma_dir, exist_ok=True)\n                print(f\"\u2705 Created ChromaDB directory: {chroma_dir}\")\n            except OSError as e:\n                print(f\"\u274c Cannot create ChromaDB directory: {e}\")\n                return False\n\n        print(\"\u2705 All configuration validation checks passed\")\n        return True\n\n    except RuntimeError as e:\n        print(f\"\u274c Configuration validation failed: {e}\")\n        return False\n\n# Usage\nif validate_configuration():\n    print(\"Ready to run IVEXES\")\nelse:\n    print(\"Fix configuration issues before proceeding\")\n</code></pre>"},{"location":"api/config/#configuration-debugging","title":"Configuration Debugging","text":"<pre><code>from ivexes.config import create_settings, PartialSettings\nimport os\n\ndef debug_configuration():\n    \"\"\"Debug configuration loading and overrides.\"\"\"\n    print(\"=== Environment Variables ===\")\n    config_vars = [\n        'LLM_API_KEY', 'LLM_BASE_URL', 'MODEL', 'MODEL_TEMPERATURE',\n        'REASONING_MODEL', 'MAX_TURNS', 'LOG_LEVEL', 'TRACE_NAME',\n        'CODEBASE_PATH', 'VULNERABLE_CODEBASE_FOLDER', 'PATCHED_CODEBASE_FOLDER'\n    ]\n\n    for var in config_vars:\n        value = os.environ.get(var, 'NOT SET')\n        if 'API_KEY' in var and value != 'NOT SET':\n            value = f\"{value[:10]}...\"  # Hide API keys\n        print(f\"{var}: {value}\")\n\n    print(\"\\n=== Loaded Settings ===\")\n    try:\n        settings = create_settings()\n        print(f\"Model: {settings.model}\")\n        print(f\"Temperature: {settings.model_temperature}\")\n        print(f\"Max Turns: {settings.max_turns}\")\n        print(f\"Log Level: {settings.log_level}\")\n        print(f\"Base URL: {settings.llm_base_url}\")\n        print(f\"API Key: {settings.llm_api_key[:10] if settings.llm_api_key else 'NOT SET'}...\")\n\n    except Exception as e:\n        print(f\"Error loading settings: {e}\")\n\n    print(\"\\n=== With Overrides ===\")\n    try:\n        override_settings = create_settings(\n            PartialSettings(\n                model='openai/gpt-4',\n                model_temperature=0.1,\n                log_level='DEBUG'\n            )\n        )\n        print(f\"Overridden Model: {override_settings.model}\")\n        print(f\"Overridden Temperature: {override_settings.model_temperature}\")\n        print(f\"Overridden Log Level: {override_settings.log_level}\")\n\n    except Exception as e:\n        print(f\"Error with overrides: {e}\")\n\n# Usage\ndebug_configuration()\n</code></pre>"},{"location":"api/config/#error-handling_1","title":"Error Handling","text":""},{"location":"api/config/#validation-errors","title":"Validation Errors","text":"<pre><code>from ivexes.config import create_settings, PartialSettings\n\ndef handle_validation_errors():\n    \"\"\"Demonstrate validation error handling.\"\"\"\n\n    invalid_configs = [\n        # Temperature out of range\n        PartialSettings(model_temperature=3.0),\n\n        # Negative max turns  \n        PartialSettings(max_turns=-1),\n\n        # Invalid log level\n        PartialSettings(log_level='TRACE'),\n\n        # Invalid embedding provider\n        PartialSettings(embedding_provider='invalid'),\n\n        # Invalid URL format\n        PartialSettings(llm_base_url='not-a-url')\n    ]\n\n    for i, config in enumerate(invalid_configs):\n        try:\n            settings = create_settings(config)\n            print(f\"Config {i+1}: \u2705 Valid\")\n        except RuntimeError as e:\n            print(f\"Config {i+1}: \u274c Invalid\")\n            print(f\"  Error: {e}\")\n\nhandle_validation_errors()\n</code></pre>"},{"location":"api/config/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code>from ivexes.config import create_settings\n\ndef check_dependencies():\n    \"\"\"Check for missing configuration dependencies.\"\"\"\n\n    try:\n        settings = create_settings()\n\n        # Check required API key\n        if not settings.llm_api_key:\n            raise ValueError(\"LLM_API_KEY must be set\")\n\n        # Check codebase configuration for code analysis\n        if settings.codebase_path:\n            if not settings.vulnerable_folder:\n                raise ValueError(\"VULNERABLE_CODEBASE_FOLDER required when CODEBASE_PATH is set\")\n            if not settings.patched_folder:\n                raise ValueError(\"PATCHED_CODEBASE_FOLDER required when CODEBASE_PATH is set\")\n\n        print(\"\u2705 All dependencies satisfied\")\n\n    except ValueError as e:\n        print(f\"\u274c Missing dependency: {e}\")\n        return False\n    except Exception as e:\n        print(f\"\u274c Configuration error: {e}\")\n        return False\n\n    return True\n\n# Usage\nif check_dependencies():\n    print(\"Ready to start analysis\")\n</code></pre>"},{"location":"api/config/#examples","title":"Examples","text":""},{"location":"api/config/#complete-configuration-setup","title":"Complete Configuration Setup","text":"<pre><code>import os\nfrom dotenv import load_dotenv\nfrom ivexes.config import create_settings, PartialSettings\n\ndef setup_complete_configuration():\n    \"\"\"Complete configuration setup example.\"\"\"\n\n    # Load environment variables from .env file\n    load_dotenv('.env')\n\n    # Define analysis-specific overrides\n    analysis_config = PartialSettings(\n        # Model configuration\n        model='openai/gpt-4',\n        reasoning_model='openai/o1-mini',\n        model_temperature=0.1,\n        max_turns=25,\n\n        # Analysis paths\n        codebase_path='/analysis/vulnerable-app',\n        vulnerable_folder='v1.0-vulnerable',\n        patched_folder='v1.1-patched',\n\n        # Environment setup\n        sandbox_image='kali-ssh:latest',\n        setup_archive='/archives/analysis-tools.tar.gz',\n\n        # Logging and tracing\n        log_level='INFO',\n        trace_name='vulnerability-analysis',\n\n        # Vector database\n        chroma_path='/data/analysis-chromadb',\n        embedding_provider='openai',\n        embedding_model='text-embedding-3-large'\n    )\n\n    # Create final settings\n    settings = create_settings(analysis_config)\n\n    print(\"=== Configuration Summary ===\")\n    print(f\"Model: {settings.model}\")\n    print(f\"Reasoning Model: {settings.reasoning_model}\")\n    print(f\"Temperature: {settings.model_temperature}\")\n    print(f\"Max Turns: {settings.max_turns}\")\n    print(f\"Codebase: {settings.codebase_path}\")\n    print(f\"Log Level: {settings.log_level}\")\n    print(f\"Trace Name: {settings.trace_name}\")\n\n    return settings\n\n# Usage\nsettings = setup_complete_configuration()\n</code></pre>"},{"location":"api/config/#agent-integration","title":"Agent Integration","text":"<pre><code>from ivexes.config import create_settings, PartialSettings, get_run_config\nfrom ivexes.agents import SingleAgent\n\ndef create_configured_agent():\n    \"\"\"Create agent with complete configuration.\"\"\"\n\n    # Define agent-specific configuration\n    agent_settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        model_temperature=0.2,\n        max_turns=15,\n        codebase_path='/project/analysis',\n        vulnerable_folder='vulnerable',\n        patched_folder='patched',\n        trace_name='single-agent-analysis'\n    )\n\n    # Create settings and run config\n    settings = create_settings(agent_settings)\n    run_config = get_run_config(settings)\n\n    # Create agent with configuration\n    agent = SingleAgent(\n        bin_path='/target/binary',\n        settings=agent_settings  # Pass partial settings to agent\n    )\n\n    print(f\"Agent configured with:\")\n    print(f\"  Model: {settings.model}\")\n    print(f\"  Temperature: {settings.model_temperature}\")\n    print(f\"  Max Turns: {settings.max_turns}\")\n    print(f\"  Codebase: {settings.codebase_path}\")\n\n    return agent, run_config\n\n# Usage\nagent, run_config = create_configured_agent()\n</code></pre>"},{"location":"api/config/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Complete configuration setup and examples</li> <li>Usage Guide - Agent execution modes and workflows</li> <li>Agents API - Agent classes that use configuration</li> <li>Installation Guide - Environment setup and prerequisites</li> </ul>"},{"location":"api/cve_search/","title":"CVE Search API Reference","text":""},{"location":"api/cve_search/#overview","title":"Overview","text":"<p>The CVE Search module provides tools for querying and retrieving vulnerability information from the National Vulnerability Database (NVD). It enables agents to search for Common Vulnerabilities and Exposures (CVE) records by ID and retrieve detailed vulnerability information including descriptions, publication dates, and severity scores.</p>"},{"location":"api/cve_search/#core-functionality","title":"Core Functionality","text":"<p>The module is built on top of the <code>nvdlib</code> library, which provides Python access to the NVD's REST API. All CVE searches are performed against the official NIST National Vulnerability Database.</p>"},{"location":"api/cve_search/#key-features","title":"Key Features","text":"<ul> <li>CVE ID Lookup: Search for specific CVE records by identifier</li> <li>Structured Results: Returns formatted vulnerability information</li> <li>NVD Integration: Direct access to official vulnerability database</li> <li>Agent Integration: Tool functions compatible with IVEXES agents</li> </ul>"},{"location":"api/cve_search/#functions","title":"Functions","text":""},{"location":"api/cve_search/#_search_cve_by_id","title":"_search_cve_by_id()","text":"<p>Internal function that performs the actual CVE lookup.</p> <pre><code>def _search_cve_by_id(cve_id: str) -&gt; str\n</code></pre> <p>Parameters: - <code>cve_id</code> (str): CVE identifier to search for (e.g., \"CVE-2021-34527\")</p> <p>Returns: - <code>str</code>: Formatted CVE information or error message</p> <p>Internal Implementation: <pre><code>results = nvdlib.searchCVE(cveId=cve_id)\nif len(results) &gt; 0:\n    cve = results[0]\n    return formatted_cve_info\nelse:\n    return f'No CVE found with ID {cve_id}.'\n</code></pre></p> <p>This function is not directly exposed but is used internally by the tool functions.</p>"},{"location":"api/cve_search/#tool-functions","title":"Tool Functions","text":""},{"location":"api/cve_search/#search_cve_by_id","title":"search_cve_by_id()","text":"<p>Agent tool for searching CVE information by CVE identifier.</p> <pre><code>@function_tool\ndef search_cve_by_id(cve_id: str) -&gt; str\n</code></pre> <p>Parameters: - <code>cve_id</code> (str): The CVE ID to search for (e.g., \"CVE-2021-34527\")</p> <p>Returns: - <code>str</code>: Formatted CVE information including:   - CVE ID   - Description   - Publication date   - Additional metadata</p> <p>Output Format: <pre><code>&lt;cve&gt;\nID: CVE-YYYY-NNNNN\n&lt;Description&gt; Detailed vulnerability description &lt;/Description&gt;\n&lt;Published&gt; YYYY-MM-DDTHH:MM:SS.sssZ &lt;/Published&gt;\n&lt;/cve&gt;\n</code></pre></p> <p>Example Usage: <pre><code>from ivexes.cve_search.tools import search_cve_by_id\n\n# Search for a specific CVE\nresult = search_cve_by_id(\"CVE-2021-44228\")\nprint(result)\n# Output:\n# &lt;cve&gt;\n# ID: CVE-2021-44228\n# &lt;Description&gt; Apache Log4j2 &lt;=2.14.1 JNDI features used in configuration... &lt;/Description&gt;\n# &lt;Published&gt; 2021-12-10T10:15:09.393Z &lt;/Published&gt;\n# &lt;/cve&gt;\n\n# Search for non-existent CVE\nresult = search_cve_by_id(\"CVE-9999-99999\")\nprint(result)\n# Output: No CVE found with ID CVE-9999-99999.\n</code></pre></p>"},{"location":"api/cve_search/#tool-integration","title":"Tool Integration","text":""},{"location":"api/cve_search/#cve_tools","title":"cve_tools","text":"<p>Pre-configured list of CVE tools for agent integration.</p> <pre><code>from ivexes.cve_search import cve_tools\n\n# Available in the tools list\nprint(cve_tools)  # [search_cve_by_id]\n</code></pre>"},{"location":"api/cve_search/#agent-integration","title":"Agent Integration","text":"<p>CVE tools are automatically available to agents through the import system:</p> <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.cve_search.tools import cve_tools\nfrom ivexes.config import PartialSettings\n\n# Create agent with CVE search capabilities\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    max_turns=20\n)\n\nagent = SingleAgent(\n    bin_path='/usr/bin/target',\n    settings=settings\n)\n\n# CVE tools are automatically included in agent tool set\n# Agent can now call search_cve_by_id() during analysis\n</code></pre>"},{"location":"api/cve_search/#usage-examples","title":"Usage Examples","text":""},{"location":"api/cve_search/#basic-cve-lookup","title":"Basic CVE Lookup","text":"<pre><code>\"\"\"Basic CVE information retrieval.\"\"\"\n\nfrom ivexes.cve_search.tools import search_cve_by_id\n\ndef lookup_vulnerability(cve_id: str) -&gt; dict:\n    \"\"\"Look up vulnerability information for a CVE ID.\"\"\"\n\n    result = search_cve_by_id(cve_id)\n\n    if \"No CVE found\" in result:\n        return {\n            'found': False,\n            'cve_id': cve_id,\n            'error': f'CVE {cve_id} not found in NVD database'\n        }\n\n    # Parse the structured result\n    return {\n        'found': True,\n        'cve_id': cve_id,\n        'raw_data': result\n    }\n\n# Example usage\nvulnerability = lookup_vulnerability(\"CVE-2021-44228\")\nif vulnerability['found']:\n    print(f\"Found Log4j vulnerability: {vulnerability['raw_data']}\")\nelse:\n    print(f\"Error: {vulnerability['error']}\")\n</code></pre>"},{"location":"api/cve_search/#batch-cve-analysis","title":"Batch CVE Analysis","text":"<pre><code>\"\"\"Analyze multiple CVEs for a security assessment.\"\"\"\n\nfrom ivexes.cve_search.tools import search_cve_by_id\nfrom typing import List, Dict, Any\n\ndef analyze_cve_list(cve_ids: List[str]) -&gt; Dict[str, Any]:\n    \"\"\"Analyze a list of CVE IDs and return summary information.\"\"\"\n\n    results = {\n        'total_searched': len(cve_ids),\n        'found': 0,\n        'not_found': 0,\n        'vulnerabilities': [],\n        'missing': []\n    }\n\n    for cve_id in cve_ids:\n        try:\n            cve_info = search_cve_by_id(cve_id)\n\n            if \"No CVE found\" in cve_info:\n                results['not_found'] += 1\n                results['missing'].append(cve_id)\n            else:\n                results['found'] += 1\n                results['vulnerabilities'].append({\n                    'cve_id': cve_id,\n                    'info': cve_info\n                })\n\n        except Exception as e:\n            results['missing'].append(f\"{cve_id} (Error: {e})\")\n            results['not_found'] += 1\n\n    return results\n\n# Example: Analyze known vulnerabilities\nknown_cves = [\n    \"CVE-2021-44228\",  # Log4j\n    \"CVE-2021-34527\",  # PrintNightmare\n    \"CVE-2020-1472\",   # Zerologon\n    \"CVE-9999-99999\"   # Invalid CVE for testing\n]\n\nanalysis = analyze_cve_list(known_cves)\nprint(f\"Analysis Results:\")\nprint(f\"- Total searched: {analysis['total_searched']}\")\nprint(f\"- Found: {analysis['found']}\")\nprint(f\"- Not found: {analysis['not_found']}\")\n\nfor vuln in analysis['vulnerabilities']:\n    print(f\"\\nVulnerability: {vuln['cve_id']}\")\n    print(vuln['info'])\n</code></pre>"},{"location":"api/cve_search/#agent-integration-example","title":"Agent Integration Example","text":"<pre><code>\"\"\"Example of CVE search integration in agent workflow.\"\"\"\n\nimport asyncio\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nasync def vulnerability_analysis_with_cve():\n    \"\"\"Perform vulnerability analysis with CVE lookup capability.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=25,\n        codebase_path='/path/to/vulnerable/codebase',\n        vulnerable_folder='vulnerable-version',\n        patched_folder='patched-version'\n    )\n\n    agent = SingleAgent(\n        bin_path='/usr/bin/vulnerable_service',\n        settings=settings\n    )\n\n    # The agent now has access to search_cve_by_id tool\n    # During analysis, it can search for relevant CVEs\n\n    print(\"Starting vulnerability analysis with CVE lookup capability...\")\n\n    # Agent can use the CVE search tool during its analysis\n    # For example, if it identifies a vulnerability pattern,\n    # it can search for related CVEs to provide context\n\n    async for chunk in agent.run_streamed():\n        print(chunk, end='', flush=True)\n\n# Run the analysis\nif __name__ == \"__main__\":\n    asyncio.run(vulnerability_analysis_with_cve())\n</code></pre>"},{"location":"api/cve_search/#custom-cve-analysis-tool","title":"Custom CVE Analysis Tool","text":"<pre><code>\"\"\"Custom tool that extends CVE search functionality.\"\"\"\n\nfrom ivexes.cve_search.tools import search_cve_by_id\nfrom typing import Optional, Dict, Any\nimport re\nfrom datetime import datetime\n\nclass CVEAnalyzer:\n    \"\"\"Enhanced CVE analysis with additional processing capabilities.\"\"\"\n\n    def __init__(self):\n        self.cache = {}  # Simple caching for repeated lookups\n\n    def search_with_cache(self, cve_id: str) -&gt; str:\n        \"\"\"Search CVE with caching to avoid repeated API calls.\"\"\"\n        if cve_id in self.cache:\n            return self.cache[cve_id]\n\n        result = search_cve_by_id(cve_id)\n        self.cache[cve_id] = result\n        return result\n\n    def parse_cve_info(self, cve_data: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Parse the XML-like CVE response into structured data.\"\"\"\n        if \"No CVE found\" in cve_data:\n            return None\n\n        # Parse the structured CVE response\n        patterns = {\n            'id': r'ID: (CVE-\\d{4}-\\d+)',\n            'description': r'&lt;Description&gt;\\s*(.*?)\\s*&lt;/Description&gt;',\n            'published': r'&lt;Published&gt;\\s*(.*?)\\s*&lt;/Published&gt;'\n        }\n\n        parsed = {}\n        for key, pattern in patterns.items():\n            match = re.search(pattern, cve_data, re.DOTALL)\n            if match:\n                parsed[key] = match.group(1).strip()\n\n        return parsed\n\n    def analyze_severity_keywords(self, description: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze description for severity indicators.\"\"\"\n        high_severity_keywords = [\n            'remote code execution', 'buffer overflow', 'privilege escalation',\n            'authentication bypass', 'sql injection', 'cross-site scripting'\n        ]\n\n        medium_severity_keywords = [\n            'denial of service', 'information disclosure', 'memory leak'\n        ]\n\n        description_lower = description.lower()\n\n        severity_indicators = {\n            'high_risk_keywords': [kw for kw in high_severity_keywords if kw in description_lower],\n            'medium_risk_keywords': [kw for kw in medium_severity_keywords if kw in description_lower],\n            'estimated_severity': 'unknown'\n        }\n\n        if severity_indicators['high_risk_keywords']:\n            severity_indicators['estimated_severity'] = 'high'\n        elif severity_indicators['medium_risk_keywords']:\n            severity_indicators['estimated_severity'] = 'medium'\n        else:\n            severity_indicators['estimated_severity'] = 'low'\n\n        return severity_indicators\n\n    def comprehensive_analysis(self, cve_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Perform comprehensive CVE analysis.\"\"\"\n        # Get CVE data\n        raw_data = self.search_with_cache(cve_id)\n        parsed_data = self.parse_cve_info(raw_data)\n\n        if not parsed_data:\n            return {\n                'cve_id': cve_id,\n                'found': False,\n                'error': 'CVE not found'\n            }\n\n        # Analyze severity\n        severity_analysis = self.analyze_severity_keywords(parsed_data['description'])\n\n        # Determine age\n        try:\n            pub_date = datetime.fromisoformat(parsed_data['published'].replace('Z', '+00:00'))\n            age_days = (datetime.now(pub_date.tzinfo) - pub_date).days\n        except:\n            age_days = None\n\n        return {\n            'cve_id': cve_id,\n            'found': True,\n            'parsed_data': parsed_data,\n            'severity_analysis': severity_analysis,\n            'age_days': age_days,\n            'raw_data': raw_data\n        }\n\n# Usage example\nanalyzer = CVEAnalyzer()\n\n# Comprehensive analysis\nanalysis = analyzer.comprehensive_analysis(\"CVE-2021-44228\")\nif analysis['found']:\n    print(f\"CVE: {analysis['cve_id']}\")\n    print(f\"Description: {analysis['parsed_data']['description']}\")\n    print(f\"Estimated Severity: {analysis['severity_analysis']['estimated_severity']}\")\n    print(f\"High-risk keywords found: {analysis['severity_analysis']['high_risk_keywords']}\")\n    print(f\"Age: {analysis['age_days']} days\")\n</code></pre>"},{"location":"api/cve_search/#integration-with-vector-database","title":"Integration with Vector Database","text":"<pre><code>\"\"\"Integrate CVE search with vector database for enhanced analysis.\"\"\"\n\nfrom ivexes.cve_search.tools import search_cve_by_id\nfrom ivexes.vector_db import VectorDB\nfrom ivexes.config import PartialSettings\n\nasync def cve_enhanced_search(query: str, cve_ids: List[str]) -&gt; Dict[str, Any]:\n    \"\"\"Enhanced CVE search using vector database for context.\"\"\"\n\n    settings = PartialSettings(\n        embedding_provider='local',\n        embedding_model='intfloat/multilingual-e5-large-instruct'\n    )\n\n    # Initialize vector database\n    vector_db = VectorDB(settings)\n\n    results = {\n        'query': query,\n        'cve_details': [],\n        'related_patterns': [],\n        'recommendations': []\n    }\n\n    # Get CVE information\n    for cve_id in cve_ids:\n        cve_info = search_cve_by_id(cve_id)\n        if \"No CVE found\" not in cve_info:\n            results['cve_details'].append({\n                'cve_id': cve_id,\n                'info': cve_info\n            })\n\n    # Use vector database to find related attack patterns\n    if results['cve_details']:\n        # Extract descriptions for vector search\n        descriptions = []\n        for cve in results['cve_details']:\n            # Parse description from CVE info\n            import re\n            desc_match = re.search(r'&lt;Description&gt;\\s*(.*?)\\s*&lt;/Description&gt;', cve['info'], re.DOTALL)\n            if desc_match:\n                descriptions.append(desc_match.group(1))\n\n        # Query vector database for related patterns\n        combined_query = f\"{query} \" + \" \".join(descriptions)\n        vector_results = await vector_db.query(combined_query, n_results=5)\n\n        if vector_results:\n            results['related_patterns'] = vector_results\n\n    return results\n\n# Example usage\ncve_search_results = asyncio.run(cve_enhanced_search(\n    query=\"buffer overflow vulnerability\",\n    cve_ids=[\"CVE-2021-44228\", \"CVE-2020-1472\"]\n))\n</code></pre>"},{"location":"api/cve_search/#error-handling","title":"Error Handling","text":""},{"location":"api/cve_search/#common-errors","title":"Common Errors","text":"<ol> <li>Network Issues: NVD API unavailable or timeout</li> <li>Invalid CVE Format: Malformed CVE identifiers</li> <li>Rate Limiting: Too many API requests</li> <li>Missing Dependencies: nvdlib not installed</li> </ol>"},{"location":"api/cve_search/#error-handling-example","title":"Error Handling Example","text":"<pre><code>\"\"\"Robust CVE search with comprehensive error handling.\"\"\"\n\nfrom ivexes.cve_search.tools import search_cve_by_id\nimport logging\nimport time\nfrom typing import Optional\n\nlogger = logging.getLogger(__name__)\n\ndef robust_cve_search(cve_id: str, max_retries: int = 3) -&gt; Optional[str]:\n    \"\"\"Search CVE with retry logic and error handling.\"\"\"\n\n    # Validate CVE format\n    import re\n    if not re.match(r'^CVE-\\d{4}-\\d+$', cve_id):\n        logger.error(f\"Invalid CVE format: {cve_id}\")\n        return f\"Error: Invalid CVE format '{cve_id}'. Expected format: CVE-YYYY-NNNNN\"\n\n    for attempt in range(max_retries):\n        try:\n            result = search_cve_by_id(cve_id)\n            logger.info(f\"Successfully retrieved CVE {cve_id}\")\n            return result\n\n        except Exception as e:\n            logger.warning(f\"Attempt {attempt + 1} failed for {cve_id}: {e}\")\n\n            if attempt &lt; max_retries - 1:\n                # Exponential backoff\n                wait_time = 2 ** attempt\n                logger.info(f\"Retrying in {wait_time} seconds...\")\n                time.sleep(wait_time)\n            else:\n                logger.error(f\"All {max_retries} attempts failed for {cve_id}\")\n                return f\"Error: Unable to retrieve CVE {cve_id} after {max_retries} attempts. Last error: {e}\"\n\n    return None\n\n# Usage with error handling\ncve_result = robust_cve_search(\"CVE-2021-44228\")\nif cve_result and not cve_result.startswith(\"Error:\"):\n    print(\"CVE information retrieved successfully\")\n    print(cve_result)\nelse:\n    print(f\"Failed to retrieve CVE: {cve_result}\")\n</code></pre>"},{"location":"api/cve_search/#api-limitations","title":"API Limitations","text":""},{"location":"api/cve_search/#nvd-api-constraints","title":"NVD API Constraints","text":"<ul> <li>Rate Limiting: The NVD API has rate limits for requests</li> <li>Data Freshness: CVE data may have delays in updates</li> <li>Network Dependency: Requires internet connection to NVD</li> <li>API Changes: NVD API changes may affect functionality</li> </ul>"},{"location":"api/cve_search/#best-practices","title":"Best Practices","text":"<ol> <li>Cache Results: Implement caching for repeated CVE lookups</li> <li>Batch Processing: Group CVE searches when possible</li> <li>Error Handling: Always handle network and API errors</li> <li>Validation: Validate CVE ID format before searching</li> <li>Rate Limiting: Implement client-side rate limiting for bulk operations</li> </ol>"},{"location":"api/cve_search/#configuration","title":"Configuration","text":""},{"location":"api/cve_search/#nvd-api-settings","title":"NVD API Settings","text":"<p>The CVE search functionality uses the <code>nvdlib</code> library which connects to the NVD REST API. No additional configuration is required, but network access to NIST servers is necessary.</p>"},{"location":"api/cve_search/#optional-enhancements","title":"Optional Enhancements","text":"<p>For production use, consider: - API key registration with NVD for higher rate limits - Local CVE database caching - Proxy configuration for corporate networks - Custom timeout and retry settings</p>"},{"location":"api/cve_search/#see-also","title":"See Also","text":"<ul> <li>Vector Database API - Knowledge base integration for enhanced analysis</li> <li>Agents API - Agent integration and tool usage</li> <li>Examples Guide - Practical usage examples</li> <li>Development Guide - Extending CVE search functionality</li> </ul>"},{"location":"api/sandbox/","title":"Sandbox API Reference","text":""},{"location":"api/sandbox/#overview","title":"Overview","text":"<p>The Sandbox module provides secure containerized environments for executing potentially malicious code and performing dynamic analysis. It manages Docker containers with isolation, resource management, and interactive session support for tools like GDB, shell commands, and custom analysis scripts.</p>"},{"location":"api/sandbox/#core-classes","title":"Core Classes","text":""},{"location":"api/sandbox/#sandbox","title":"Sandbox","text":"<p>Main containerized sandbox environment for secure code execution.</p> <pre><code>from ivexes.sandbox import Sandbox\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/analysis.tgz'\n)\nsandbox = Sandbox(settings)\n</code></pre>"},{"location":"api/sandbox/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    settings: Settings,\n    username: Literal['user', 'root'] = 'user',\n    working_dir: str = '/home/user'\n) -&gt; None\n</code></pre> <p>Parameters: - <code>settings</code> (Settings): Configuration settings containing Docker image, setup archive, and other options - <code>username</code> (Literal['user', 'root']): Default username for container operations - <code>working_dir</code> (str): Default working directory inside container</p> <p>Example: <pre><code>from ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/setup.tgz',\n    trace_name='vulnerability_analysis'\n)\n\nsandbox = Sandbox(\n    settings=settings,\n    username='user',\n    working_dir='/home/user'\n)\n</code></pre></p>"},{"location":"api/sandbox/#methods","title":"Methods","text":""},{"location":"api/sandbox/#connect","title":"connect()","text":"<p>Set up and connect to the Docker container.</p> <pre><code>def connect(self, reset: bool = True) -&gt; bool\n</code></pre> <p>Parameters: - <code>reset</code> (bool): Whether to remove and recreate existing container</p> <p>Returns: - <code>bool</code>: True if successful, False otherwise</p> <p>Example: <pre><code># Connect with container reset\nif sandbox.connect(reset=True):\n    print(\"Sandbox connected successfully\")\nelse:\n    print(\"Failed to connect to sandbox\")\n\n# Reuse existing container if available\nif sandbox.connect(reset=False):\n    print(\"Connected to existing container\")\n</code></pre></p>"},{"location":"api/sandbox/#run","title":"run()","text":"<p>Execute a command in the container with timeout support.</p> <pre><code>def run(\n    self,\n    command: Union[str, bytes],\n    user: Optional[str] = None,\n    timeout: int = 60\n) -&gt; Tuple[int, str]\n</code></pre> <p>Parameters: - <code>command</code> (Union[str, bytes]): Command to execute - <code>user</code> (Optional[str]): User to run as (defaults to sandbox username) - <code>timeout</code> (int): Timeout in seconds</p> <p>Returns: - <code>Tuple[int, str]</code>: Exit code and output   - Exit code: 0 (success), 1 (error), 2 (timeout with partial results)   - Output: Command output or error message</p> <p>Example: <pre><code># Basic command execution\nexit_code, output = sandbox.run('ls -la')\nif exit_code == 0:\n    print(f\"Directory listing:\\n{output}\")\n\n# Run with specific user and timeout\nexit_code, output = sandbox.run(\n    'find / -name \"*.so\" | head -10',\n    user='root',\n    timeout=30\n)\n\n# Handle different exit codes\nif exit_code == 0:\n    print(\"Command completed successfully\")\nelif exit_code == 2:\n    print(\"Command timed out, partial results available\")\nelse:\n    print(f\"Command failed: {output}\")\n</code></pre></p>"},{"location":"api/sandbox/#interactive","title":"interactive()","text":"<p>Start an interactive session for tools like GDB or Python REPL.</p> <pre><code>def interactive(\n    self,\n    command: str = '/bin/sh',\n    user: Literal['user', 'root'] = 'root',\n    session: Optional[str] = None,\n    timeout: int = 60\n) -&gt; InteractiveSession\n</code></pre> <p>Parameters: - <code>command</code> (str): Command to run interactively - <code>user</code> (Literal['user', 'root']): User to run the session as - <code>session</code> (Optional[str]): Session identifier for reuse - <code>timeout</code> (int): Default timeout for session operations</p> <p>Returns: - <code>InteractiveSession</code>: Session object for interaction</p> <p>Example: <pre><code># Start GDB session\ngdb_session = sandbox.interactive(\n    command='gdb ./vulnerable_program',\n    user='user',\n    session='gdb_analysis',\n    timeout=120\n)\n\n# Send commands to GDB\ngdb_session.send('break main')\nstatus, output = gdb_session.read()\nprint(f\"GDB output: {output}\")\n\ngdb_session.send('run')\ngdb_session.send('bt')\n\n# Reuse existing session\nsame_session = sandbox.interactive(session='gdb_analysis')\n</code></pre></p>"},{"location":"api/sandbox/#write_file","title":"write_file()","text":"<p>Create or overwrite a file in the container.</p> <pre><code>def write_file(self, filename: str, content: str) -&gt; bool\n</code></pre> <p>Parameters: - <code>filename</code> (str): File path in container (absolute or relative) - <code>content</code> (str): File content</p> <p>Returns: - <code>bool</code>: True if successful, False otherwise</p> <p>Example: <pre><code># Write analysis script\nscript_content = \"\"\"#!/bin/bash\necho \"Starting vulnerability analysis...\"\nfile /usr/bin/target\nstrings /usr/bin/target | grep -i password\n\"\"\"\n\nsuccess = sandbox.write_file('/tmp/analysis.sh', script_content)\nif success:\n    sandbox.run('chmod +x /tmp/analysis.sh')\n    exit_code, output = sandbox.run('/tmp/analysis.sh')\n\n# Write Python analysis script\npython_script = \"\"\"\nimport os\nimport sys\n\ndef analyze_binary(path):\n    if os.path.exists(path):\n        print(f\"Analyzing {path}\")\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    analyze_binary(\"/usr/bin/target\")\n\"\"\"\n\nsandbox.write_file('analyze.py', python_script)\n</code></pre></p>"},{"location":"api/sandbox/#read_file","title":"read_file()","text":"<p>Read a file from the container.</p> <pre><code>def read_file(self, filename: str) -&gt; Optional[str]\n</code></pre> <p>Parameters: - <code>filename</code> (str): File path in container</p> <p>Returns: - <code>Optional[str]</code>: File content or None if failed</p> <p>Example: <pre><code># Read configuration file\nconfig_content = sandbox.read_file('/etc/passwd')\nif config_content:\n    print(\"User accounts:\")\n    for line in config_content.split('\\n'):\n        if 'user' in line:\n            print(line)\n\n# Read analysis results\nresults = sandbox.read_file('/tmp/analysis_results.txt')\nif results:\n    print(f\"Analysis completed:\\n{results}\")\nelse:\n    print(\"No results file found\")\n</code></pre></p>"},{"location":"api/sandbox/#is_running","title":"is_running()","text":"<p>Check if the container is running.</p> <pre><code>def is_running(self) -&gt; bool\n</code></pre> <p>Returns: - <code>bool</code>: True if container is running, False otherwise</p> <p>Example: <pre><code>if sandbox.is_running():\n    print(\"Container is active\")\n    exit_code, output = sandbox.run('uptime')\nelse:\n    print(\"Container is not running, reconnecting...\")\n    sandbox.connect()\n</code></pre></p>"},{"location":"api/sandbox/#close","title":"close()","text":"<p>Close sandbox and cleanup resources.</p> <pre><code>def close(self) -&gt; bool\n</code></pre> <p>Returns: - <code>bool</code>: True if cleanup successful</p> <p>Example: <pre><code># Manual cleanup\nsuccess = sandbox.close()\nif success:\n    print(\"Sandbox closed successfully\")\n\n# Automatic cleanup with context manager\nwith Sandbox(settings) as sandbox:\n    sandbox.run('echo \"Analysis complete\"')\n# Automatic cleanup happens here\n</code></pre></p>"},{"location":"api/sandbox/#context-manager-support","title":"Context Manager Support","text":"<p>The Sandbox class supports context manager protocol for automatic resource management.</p> <pre><code># Automatic setup and cleanup\nwith Sandbox(settings) as sandbox:\n    # Container is automatically connected\n    exit_code, output = sandbox.run('whoami')\n    print(f\"Running as: {output}\")\n\n    # Interactive analysis\n    gdb = sandbox.interactive('gdb /usr/bin/target')\n    gdb.send('info functions')\n    status, functions = gdb.read()\n\n# Container is automatically cleaned up\n</code></pre>"},{"location":"api/sandbox/#properties","title":"Properties","text":"<ul> <li><code>settings</code> (Settings): Configuration settings</li> <li><code>username</code> (str): Default username for operations</li> <li><code>working_dir</code> (str): Default working directory</li> <li><code>container</code> (Optional[Container]): Docker container instance</li> <li><code>sessions</code> (dict): Active interactive sessions</li> </ul>"},{"location":"api/sandbox/#interactivesession","title":"InteractiveSession","text":"<p>Manages interactive programs running in Docker containers using pexpect.</p> <pre><code># Created through Sandbox.interactive()\nsession = sandbox.interactive('gdb ./program')\n</code></pre>"},{"location":"api/sandbox/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    container: Container,\n    command: str,\n    working_dir: str,\n    user: Literal['root', 'user'],\n    timeout: int = 30\n) -&gt; None\n</code></pre> <p>Parameters: - <code>container</code> (Container): Docker container instance - <code>command</code> (str): Command to run interactively - <code>working_dir</code> (str): Working directory for the command - <code>user</code> (Literal['root', 'user']): User to run as - <code>timeout</code> (int): Default timeout for operations</p>"},{"location":"api/sandbox/#methods_1","title":"Methods","text":""},{"location":"api/sandbox/#send","title":"send()","text":"<p>Send text input to the interactive session.</p> <pre><code>def send(self, text: Union[str, bytes]) -&gt; None\n</code></pre> <p>Parameters: - <code>text</code> (Union[str, bytes]): Text to send to the session</p> <p>Example: <pre><code># GDB interaction\ngdb = sandbox.interactive('gdb ./vulnerable')\ngdb.send('break main')\ngdb.send('run AAAA')\ngdb.send('continue')\n\n# Python REPL interaction\npython = sandbox.interactive('python3')\npython.send('import os')\npython.send('print(os.getcwd())')\npython.send('exit()')\n</code></pre></p>"},{"location":"api/sandbox/#read","title":"read()","text":"<p>Read available output without blocking.</p> <pre><code>def read(self) -&gt; Tuple[STATUS, str]\n</code></pre> <p>Returns: - <code>Tuple[STATUS, str]</code>: Status and output text   - STATUS.ALIVE: Session is active with output   - STATUS.EMPTY: No output available   - STATUS.EOF: End of file reached   - STATUS.TIMEOUT: Read operation timed out</p> <p>Example: <pre><code>session = sandbox.interactive('gdb ./program')\nsession.send('info registers')\n\nstatus, output = session.read()\nif status == InteractiveSession.STATUS.ALIVE:\n    print(f\"Registers:\\n{output}\")\nelif status == InteractiveSession.STATUS.EMPTY:\n    print(\"No output available yet\")\nelif status == InteractiveSession.STATUS.EOF:\n    print(\"Session ended\")\n</code></pre></p>"},{"location":"api/sandbox/#is_alive","title":"is_alive()","text":"<p>Check if the session process is still running.</p> <pre><code>def is_alive(self) -&gt; bool\n</code></pre> <p>Returns: - <code>bool</code>: True if session is active</p> <p>Example: <pre><code>session = sandbox.interactive('long_running_analysis')\nsession.send('start')\n\nwhile session.is_alive():\n    status, output = session.read()\n    if output and output != \"Nothing to read\":\n        print(f\"Analysis output: {output}\")\n    time.sleep(1)\n</code></pre></p>"},{"location":"api/sandbox/#close_1","title":"close()","text":"<p>Close the interactive session.</p> <pre><code>def close(self) -&gt; None\n</code></pre> <p>Example: <pre><code>session = sandbox.interactive('gdb ./program')\n# Perform analysis\nsession.send('quit')\nsession.close()\n\n# Or use context manager\nwith sandbox.interactive('python3') as python_session:\n    python_session.send('print(\"Hello from sandbox\")')\n    status, output = python_session.read()\n# Automatic cleanup\n</code></pre></p>"},{"location":"api/sandbox/#status-enumeration","title":"Status Enumeration","text":"<pre><code>class STATUS(Enum):\n    ALIVE = 1    # Session is active\n    CLOSED = 2   # Session is closed\n    TIMEOUT = 3  # Operation timed out\n    EMPTY = 4    # No data available\n    EOF = 4      # End of file reached\n    ERROR = 5    # Error occurred\n</code></pre>"},{"location":"api/sandbox/#container-management","title":"Container Management","text":""},{"location":"api/sandbox/#setup_container","title":"setup_container()","text":"<p>Create and configure a Docker container for sandbox use.</p> <pre><code>from ivexes.sandbox.sandbox_container import setup_container\n\ndef setup_container(\n    settings: Settings,\n    docker_image: Optional[str] = None,\n    renew: bool = True\n) -&gt; Container\n</code></pre> <p>Parameters: - <code>settings</code> (Settings): Configuration settings - <code>docker_image</code> (Optional[str]): Docker image to use (defaults to settings.sandbox_image) - <code>renew</code> (bool): Whether to remove existing container</p> <p>Returns: - <code>Container</code>: Docker container ready for use</p> <p>Raises: - <code>ValueError</code>: If setup_archive is not .tar/.tgz format - <code>RuntimeError</code>: If container setup fails - <code>docker.errors.ImageNotFound</code>: If Docker image not found</p> <p>Example: <pre><code>from ivexes.config import PartialSettings\nfrom ivexes.sandbox.sandbox_container import setup_container\n\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/analysis_environment.tgz',\n    trace_name='custom_analysis'\n)\n\n# Create new container\ncontainer = setup_container(settings, renew=True)\nprint(f\"Container {container.name} is ready\")\n\n# Reuse existing container if available\ncontainer = setup_container(settings, renew=False)\n</code></pre></p>"},{"location":"api/sandbox/#tool-functions","title":"Tool Functions","text":""},{"location":"api/sandbox/#create_sandbox_tools","title":"create_sandbox_tools()","text":"<p>Create sandbox tools for agent integration.</p> <pre><code>from ivexes.sandbox.tools import create_sandbox_tools\n\ndef create_sandbox_tools(\n    settings: Optional[Settings] = None,\n    sandbox: Optional[Sandbox] = None\n) -&gt; List[Tool]\n</code></pre> <p>Parameters: - <code>settings</code> (Optional[Settings]): Settings instance (loads from environment if not provided) - <code>sandbox</code> (Optional[Sandbox]): Sandbox instance (creates new if not provided)</p> <p>Returns: - <code>List[Tool]</code>: List of sandbox tools for agent use</p> <p>Available Tools: - <code>setup_sandbox()</code>: Initialize sandbox environment - <code>teardown_sandbox()</code>: Clean up sandbox resources - <code>sandbox_run()</code>: Execute commands in sandbox - <code>sandbox_write_file()</code>: Create files in sandbox</p> <p>Example: <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.sandbox.tools import create_sandbox_tools\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/tools.tgz'\n)\n\n# Create tools for agent\ntools = create_sandbox_tools(settings)\n\n# Use with agent\nagent = SingleAgent(bin_path='/usr/bin/target', settings=settings)\n# Tools are automatically available to the agent\n</code></pre></p>"},{"location":"api/sandbox/#tool-setup_sandbox","title":"Tool: setup_sandbox()","text":"<p>Initialize Kali Linux sandbox environment.</p> <p>Returns: - <code>str</code>: Setup result message with environment information</p> <p>Example usage in agent: <pre><code># Agent can call this tool\nresult = setup_sandbox()\n# Returns: \"Sandbox setup successfully\\nUsername: 'user' Password: 'passwd'...\"\n</code></pre></p>"},{"location":"api/sandbox/#tool-teardown_sandbox","title":"Tool: teardown_sandbox()","text":"<p>Clean up sandbox environment and resources.</p> <p>Returns: - <code>str</code>: Teardown result message</p>"},{"location":"api/sandbox/#tool-sandbox_run","title":"Tool: sandbox_run()","text":"<p>Execute commands in the sandbox environment.</p> <p>Parameters: - <code>input</code> (str): Command to execute - <code>user</code> (Literal['root', 'user']): User context (default: 'user') - <code>session</code> (Optional[str]): Session identifier for interactive commands - <code>timeout</code> (int): Command timeout in seconds (default: 60)</p> <p>Returns: - <code>str</code>: Command output</p> <p>Example usage in agent: <pre><code># Basic command\noutput = sandbox_run('ls -la /usr/bin')\n\n# Interactive session\npython_output = sandbox_run('print(\"Hello\")', session='python')\n\n# Root access for system commands\nsystem_info = sandbox_run('ps aux', user='root')\n</code></pre></p>"},{"location":"api/sandbox/#tool-sandbox_write_file","title":"Tool: sandbox_write_file()","text":"<p>Create files in the sandbox environment.</p> <p>Parameters: - <code>file_path</code> (str): Target file path in container - <code>content</code> (str): File content</p> <p>Returns: - <code>str</code>: Success or error message</p> <p>Example usage in agent: <pre><code># Create analysis script\nresult = sandbox_write_file(\n    '/tmp/exploit.py',\n    'print(\"Exploit code here\")'\n)\n</code></pre></p>"},{"location":"api/sandbox/#usage-examples","title":"Usage Examples","text":""},{"location":"api/sandbox/#basic-sandbox-usage","title":"Basic Sandbox Usage","text":"<pre><code>\"\"\"Basic sandbox operation example.\"\"\"\n\nfrom ivexes.sandbox import Sandbox\nfrom ivexes.config import PartialSettings\n\n# Configure sandbox\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/analysis_tools.tgz',\n    trace_name='basic_analysis'\n)\n\n# Create and connect to sandbox\nsandbox = Sandbox(settings)\n\ntry:\n    # Connect to container\n    if not sandbox.connect():\n        raise RuntimeError(\"Failed to connect to sandbox\")\n\n    # Basic command execution\n    exit_code, output = sandbox.run('whoami')\n    print(f\"Running as: {output}\")\n\n    # File system analysis\n    exit_code, output = sandbox.run('find /usr/bin -name \"*ssh*\"')\n    print(f\"SSH binaries: {output}\")\n\n    # Create analysis script\n    script = \"\"\"#!/bin/bash\n    echo \"=== System Information ===\"\n    uname -a\n    echo \"=== Network Interfaces ===\"\n    ip addr show\n    \"\"\"\n\n    if sandbox.write_file('/tmp/sysinfo.sh', script):\n        sandbox.run('chmod +x /tmp/sysinfo.sh')\n        exit_code, output = sandbox.run('/tmp/sysinfo.sh')\n        print(f\"System info:\\n{output}\")\n\nfinally:\n    sandbox.close()\n</code></pre>"},{"location":"api/sandbox/#interactive-analysis-session","title":"Interactive Analysis Session","text":"<pre><code>\"\"\"Interactive GDB analysis example.\"\"\"\n\nfrom ivexes.sandbox import Sandbox\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/vulnerable_binary.tgz'\n)\n\nwith Sandbox(settings) as sandbox:\n    # Start GDB session\n    gdb = sandbox.interactive(\n        command='gdb /usr/bin/vulnerable_program',\n        session='analysis',\n        timeout=120\n    )\n\n    # Set up analysis\n    gdb.send('set disassembly-flavor intel')\n    gdb.send('break main')\n\n    # Run with test input\n    gdb.send('run AAAABBBBCCCCDDDD')\n    status, output = gdb.read()\n    print(f\"Execution stopped: {output}\")\n\n    # Examine registers\n    gdb.send('info registers')\n    status, output = gdb.read()\n    print(f\"Registers: {output}\")\n\n    # Check stack\n    gdb.send('x/20x $rsp')\n    status, output = gdb.read()\n    print(f\"Stack contents: {output}\")\n\n    # Backtrace\n    gdb.send('bt')\n    status, output = gdb.read()\n    print(f\"Backtrace: {output}\")\n\n    gdb.close()\n</code></pre>"},{"location":"api/sandbox/#multi-tool-analysis","title":"Multi-Tool Analysis","text":"<pre><code>\"\"\"Comprehensive binary analysis using multiple tools.\"\"\"\n\nfrom ivexes.sandbox import Sandbox\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/analysis_suite.tgz'\n)\n\nwith Sandbox(settings) as sandbox:\n    binary_path = '/usr/bin/target'\n\n    # File type analysis\n    exit_code, output = sandbox.run(f'file {binary_path}')\n    print(f\"File type: {output}\")\n\n    # String analysis\n    exit_code, output = sandbox.run(f'strings {binary_path} | head -20')\n    print(f\"Interesting strings: {output}\")\n\n    # Security features check\n    exit_code, output = sandbox.run(f'checksec --file={binary_path}')\n    print(f\"Security features: {output}\")\n\n    # Library dependencies\n    exit_code, output = sandbox.run(f'ldd {binary_path}')\n    print(f\"Dependencies: {output}\")\n\n    # Disassembly sample\n    exit_code, output = sandbox.run(f'objdump -d {binary_path} | head -50')\n    print(f\"Disassembly sample: {output}\")\n\n    # Dynamic analysis with ltrace\n    exit_code, output = sandbox.run(\n        f'timeout 10 ltrace -c {binary_path} 2&gt;&amp;1 || true',\n        timeout=15\n    )\n    print(f\"Library calls: {output}\")\n</code></pre>"},{"location":"api/sandbox/#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<pre><code>\"\"\"Robust sandbox usage with error handling.\"\"\"\n\nfrom ivexes.sandbox import Sandbox\nfrom ivexes.config import PartialSettings\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nsettings = PartialSettings(\n    sandbox_image='kali-ssh:latest',\n    setup_archive='/path/to/tools.tgz'\n)\n\nsandbox = Sandbox(settings)\n\ntry:\n    # Attempt connection with retry\n    for attempt in range(3):\n        if sandbox.connect(reset=attempt &gt; 0):\n            logger.info(f\"Connected on attempt {attempt + 1}\")\n            break\n        logger.warning(f\"Connection attempt {attempt + 1} failed\")\n    else:\n        raise RuntimeError(\"Failed to connect after 3 attempts\")\n\n    # Check container health\n    if not sandbox.is_running():\n        raise RuntimeError(\"Container is not running\")\n\n    # Execute commands with timeout handling\n    commands = [\n        'echo \"Starting analysis\"',\n        'find /usr -name \"*.so\" | wc -l',  # Potentially long command\n        'ps aux | head -10'\n    ]\n\n    for cmd in commands:\n        try:\n            exit_code, output = sandbox.run(cmd, timeout=30)\n\n            if exit_code == 0:\n                logger.info(f\"Command succeeded: {cmd}\")\n                print(output)\n            elif exit_code == 2:\n                logger.warning(f\"Command timed out: {cmd}\")\n                print(f\"Partial output: {output}\")\n            else:\n                logger.error(f\"Command failed: {cmd}\")\n                print(f\"Error: {output}\")\n\n        except Exception as e:\n            logger.error(f\"Exception running command '{cmd}': {e}\")\n            continue\n\nexcept Exception as e:\n    logger.error(f\"Sandbox error: {e}\")\n\nfinally:\n    # Ensure cleanup\n    try:\n        sandbox.close()\n        logger.info(\"Sandbox closed successfully\")\n    except Exception as e:\n        logger.error(f\"Error closing sandbox: {e}\")\n</code></pre>"},{"location":"api/sandbox/#security-considerations","title":"Security Considerations","text":""},{"location":"api/sandbox/#container-isolation","title":"Container Isolation","text":"<ul> <li>Containers run with limited privileges by default</li> <li>File system isolation prevents access to host files</li> <li>Network isolation can be configured per container</li> <li>Resource limits prevent resource exhaustion attacks</li> </ul>"},{"location":"api/sandbox/#user-management","title":"User Management","text":"<ul> <li>Default 'user' account with limited privileges</li> <li>'root' access available for setup operations only</li> <li>Password authentication configured for container access</li> <li>SSH access through secure container networking</li> </ul>"},{"location":"api/sandbox/#resource-management","title":"Resource Management","text":"<ul> <li>Command timeouts prevent hanging processes</li> <li>Memory and CPU limits configurable</li> <li>Automatic cleanup of containers and sessions</li> <li>Proper handling of file descriptors and streams</li> </ul>"},{"location":"api/sandbox/#best-practices","title":"Best Practices","text":"<ol> <li>Always use timeouts for command execution</li> <li>Clean up resources with context managers or explicit close()</li> <li>Validate input before passing to sandbox commands</li> <li>Monitor container health during long operations</li> <li>Use minimal privileges - avoid root unless necessary</li> <li>Isolate sensitive data - don't mount host directories unnecessarily</li> </ol>"},{"location":"api/sandbox/#see-also","title":"See Also","text":"<ul> <li>Configuration API - Settings and configuration management</li> <li>Container Utilities - Docker utilities and helpers</li> <li>Examples Guide - Practical usage examples</li> <li>Development Guide - Custom sandbox development</li> </ul>"},{"location":"api/tools/","title":"Tools API Reference","text":""},{"location":"api/tools/#overview","title":"Overview","text":"<p>The Tools module provides a comprehensive collection of utility functions and helpers used throughout the IVEXES system. This module aggregates tools from different components including date utilities, sandbox operations, code browsing, vector database functionality, CVE search, and report generation, providing a centralized access point for all available tools.</p> <p>The tools are organized into functional categories and designed for easy integration with IVEXES agents and components.</p>"},{"location":"api/tools/#tool-categories","title":"Tool Categories","text":""},{"location":"api/tools/#aggregated-tools","title":"Aggregated Tools","text":"<p>The main tools module (<code>ivexes.tools</code>) provides convenient access to all tool collections:</p> <pre><code>from ivexes.tools import (\n    date_tools,\n    cve_tools,\n    create_sandbox_tools,\n    create_code_browser_tools,\n    create_vectordb_tools,\n    create_report_tools\n)\n</code></pre>"},{"location":"api/tools/#tool-creation-functions","title":"Tool Creation Functions","text":"<ul> <li><code>create_sandbox_tools()</code>: Containerized environment operations</li> <li><code>create_code_browser_tools()</code>: Code analysis and browsing capabilities  </li> <li><code>create_vectordb_tools()</code>: Vector database operations for knowledge retrieval</li> <li><code>create_report_tools()</code>: Report generation and documentation</li> </ul>"},{"location":"api/tools/#static-tool-collections","title":"Static Tool Collections","text":"<ul> <li><code>date_tools</code>: Date and time retrieval utilities</li> <li><code>cve_tools</code>: CVE lookup and vulnerability research</li> </ul>"},{"location":"api/tools/#date-and-time-tools","title":"Date and Time Tools","text":""},{"location":"api/tools/#get_current_date","title":"get_current_date()","text":"<p>Tool function for retrieving current date and time information.</p> <pre><code>@function_tool(strict_mode=True)\ndef get_current_date() -&gt; str\n</code></pre> <p>Returns: - <code>str</code>: Current date and time in 'YYYY-MM-DD HH:MM:SS' format</p> <p>Example: <pre><code>from ivexes.date.tools import get_current_date\n\n# Get current timestamp\ntimestamp = get_current_date()\nprint(timestamp)  # Output: '2024-01-15 14:30:45'\n</code></pre></p>"},{"location":"api/tools/#current_date","title":"current_date()","text":"<p>Utility function for formatted current date/time (non-tool version).</p> <pre><code>def current_date() -&gt; str\n</code></pre> <p>Returns: - <code>str</code>: Formatted current date and time</p> <p>Example: <pre><code>from ivexes.date.tools import current_date\n\n# Direct function call\nnow = current_date()\nprint(f\"Analysis started at: {now}\")\n</code></pre></p>"},{"location":"api/tools/#usage-with-agents","title":"Usage with Agents","text":"<pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.date.tools import date_tools\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(model='openai/gpt-4o-mini')\nagent = SingleAgent(settings=settings)\n\n# date_tools is automatically available to agents\n# Agents can call get_current_date() during analysis\n</code></pre>"},{"location":"api/tools/#token-management-and-statistics","title":"Token Management and Statistics","text":""},{"location":"api/tools/#get_text_statistics","title":"get_text_statistics()","text":"<p>Analyze token, character, and word counts in text strings.</p> <pre><code>def get_text_statistics(string: str, model: str = 'gpt-4') -&gt; tuple[int, int, int]\n</code></pre> <p>Parameters: - <code>string</code> (str): Input text to analyze - <code>model</code> (str): Model name for token encoding (default: 'gpt-4')</p> <p>Returns: - <code>tuple[int, int, int]</code>: (token_count, character_count, word_count)</p> <p>Example: <pre><code>from ivexes.token import get_text_statistics\n\ntext = \"This is a sample vulnerability analysis report.\"\ntokens, chars, words = get_text_statistics(text, model='gpt-4')\n\nprint(f\"Analysis: {tokens} tokens, {chars} characters, {words} words\")\n# Output: Analysis: 12 tokens, 46 characters, 8 words\n</code></pre></p>"},{"location":"api/tools/#get_file_statistics","title":"get_file_statistics()","text":"<p>Analyze token, character, and word counts in files.</p> <pre><code>def get_file_statistics(file_path: str) -&gt; tuple[int, int, int]\n</code></pre> <p>Parameters: - <code>file_path</code> (str): Path to file for analysis</p> <p>Returns: - <code>tuple[int, int, int]</code>: (token_count, character_count, word_count)</p> <p>Example: <pre><code>from ivexes.token import get_file_statistics\n\n# Analyze a source code file\ntokens, chars, words = get_file_statistics('/path/to/vulnerable.c')\n\nif tokens &gt; 0:\n    print(f\"File analysis: {tokens} tokens, {chars} characters, {words} words\")\nelse:\n    print(\"File could not be analyzed (encoding issues or empty)\")\n</code></pre></p>"},{"location":"api/tools/#get_directory_statistics","title":"get_directory_statistics()","text":"<p>Analyze token, character, and word counts across entire directories.</p> <pre><code>def get_directory_statistics(directory_path: str) -&gt; tuple[int, int, int]\n</code></pre> <p>Parameters: - <code>directory_path</code> (str): Path to directory for recursive analysis</p> <p>Returns: - <code>tuple[int, int, int]</code>: Total (token_count, character_count, word_count)</p> <p>Example: <pre><code>from ivexes.token import get_directory_statistics\n\n# Analyze entire codebase\ntotal_tokens, total_chars, total_words = get_directory_statistics('/path/to/codebase')\n\nprint(f\"Codebase Analysis:\")\nprint(f\"- Total tokens: {total_tokens:,}\")\nprint(f\"- Total characters: {total_chars:,}\")  \nprint(f\"- Total words: {total_words:,}\")\n\n# Estimate analysis cost\nestimated_cost = total_tokens * 0.00001  # Example rate\nprint(f\"- Estimated analysis cost: ${estimated_cost:.2f}\")\n</code></pre></p>"},{"location":"api/tools/#container-management-utilities","title":"Container Management Utilities","text":""},{"location":"api/tools/#get_client","title":"get_client()","text":"<p>Get or create a Docker client instance with singleton pattern.</p> <pre><code>def get_client() -&gt; DockerClient\n</code></pre> <p>Returns: - <code>DockerClient</code>: Docker client instance</p> <p>Example: <pre><code>from ivexes.container import get_client\n\nclient = get_client()\nprint(f\"Docker client version: {client.version()}\")\n</code></pre></p>"},{"location":"api/tools/#find_by_name","title":"find_by_name()","text":"<p>Find and optionally start a Docker container by name.</p> <pre><code>def find_by_name(container_name: str, start: bool = True) -&gt; Container | None\n</code></pre> <p>Parameters: - <code>container_name</code> (str): Name of container to find - <code>start</code> (bool): Whether to start container if found but not running</p> <p>Returns: - <code>Container | None</code>: Container instance or None if not found</p> <p>Example: <pre><code>from ivexes.container import find_by_name\n\n# Find and start container if needed\ncontainer = find_by_name('ivexes-analysis-container', start=True)\n\nif container:\n    print(f\"Container {container.name} is {container.status}\")\nelse:\n    print(\"Container not found\")\n</code></pre></p>"},{"location":"api/tools/#cleanup","title":"cleanup()","text":"<p>Clean up containers with specific name prefix.</p> <pre><code>def cleanup(prefix: str = 'ivexes-') -&gt; None\n</code></pre> <p>Parameters: - <code>prefix</code> (str): Prefix for containers to remove (default: 'ivexes-')</p> <p>Example: <pre><code>from ivexes.container import cleanup\n\n# Clean up all IVEXES containers\ncleanup('ivexes-')\n\n# Clean up test containers\ncleanup('test-container-')\n</code></pre></p>"},{"location":"api/tools/#remove_if_exists","title":"remove_if_exists()","text":"<p>Remove a specific container if it exists.</p> <pre><code>def remove_if_exists(container_name: str) -&gt; bool\n</code></pre> <p>Parameters: - <code>container_name</code> (str): Name of container to remove</p> <p>Returns: - <code>bool</code>: True if container was removed, False if it didn't exist</p> <p>Example: <pre><code>from ivexes.container import remove_if_exists\n\n# Clean up specific container\nremoved = remove_if_exists('old-analysis-container')\nif removed:\n    print(\"Container removed successfully\")\nelse:\n    print(\"Container did not exist\")\n</code></pre></p>"},{"location":"api/tools/#santize_name","title":"santize_name()","text":"<p>Sanitize container names by replacing invalid characters.</p> <pre><code>def santize_name(name: str) -&gt; str\n</code></pre> <p>Parameters: - <code>name</code> (str): Original name to sanitize</p> <p>Returns: - <code>str</code>: Sanitized name with invalid characters replaced</p> <p>Example: <pre><code>from ivexes.container import santize_name\n\n# Sanitize problematic container name\nraw_name = \"My Analysis Container! (2024)\"\nsafe_name = santize_name(raw_name)\nprint(safe_name)  # Output: \"my-analysis-container-2024\"\n\n# Use for container creation\ncontainer_name = f\"ivexes-{santize_name(analysis_id)}\"\n</code></pre></p>"},{"location":"api/tools/#color-utilities","title":"Color Utilities","text":""},{"location":"api/tools/#colors-class","title":"Colors Class","text":"<p>ANSI escape sequences for colored terminal output.</p> <pre><code>class Colors:\n    HEADER = '\\033[95m'      # Purple header\n    OKBLUE = '\\033[94m'      # Blue for info\n    OKCYAN = '\\033[96m'      # Cyan for highlights  \n    OKGREEN = '\\033[92m'     # Green for success\n    WARNING = '\\033[93m'     # Yellow for warnings\n    FAIL = '\\033[91m'        # Red for errors\n    ENDC = '\\033[0m'         # Reset color\n    BOLD = '\\033[1m'         # Bold text\n    UNDERLINE = '\\033[4m'    # Underlined text\n</code></pre> <p>Example: <pre><code>from ivexes.colors import Colors\n\n# Colored output for analysis results\nprint(f\"{Colors.HEADER}Vulnerability Analysis Report{Colors.ENDC}\")\nprint(f\"{Colors.OKGREEN}\u2713 Analysis completed successfully{Colors.ENDC}\")\nprint(f\"{Colors.WARNING}\u26a0 3 potential vulnerabilities found{Colors.ENDC}\")\nprint(f\"{Colors.FAIL}\u2717 Critical security issue detected{Colors.ENDC}\")\n\n# Combined formatting\nprint(f\"{Colors.BOLD}{Colors.UNDERLINE}Summary{Colors.ENDC}\")\nprint(f\"{Colors.OKCYAN}Total files analyzed: 42{Colors.ENDC}\")\n</code></pre></p>"},{"location":"api/tools/#colored-logging-example","title":"Colored Logging Example","text":"<pre><code>import logging\nfrom ivexes.colors import Colors\n\nclass ColoredFormatter(logging.Formatter):\n    \"\"\"Colored log formatter using IVEXES colors.\"\"\"\n\n    COLORS = {\n        'DEBUG': Colors.OKCYAN,\n        'INFO': Colors.OKGREEN,\n        'WARNING': Colors.WARNING,\n        'ERROR': Colors.FAIL,\n        'CRITICAL': f\"{Colors.BOLD}{Colors.FAIL}\"\n    }\n\n    def format(self, record):\n        log_color = self.COLORS.get(record.levelname, '')\n        record.levelname = f\"{log_color}{record.levelname}{Colors.ENDC}\"\n        return super().format(record)\n\n# Setup colored logging\nhandler = logging.StreamHandler()\nhandler.setFormatter(ColoredFormatter('%(levelname)s - %(message)s'))\nlogger = logging.getLogger('ivexes')\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\n# Use colored logging\nlogger.info(\"Analysis started\")\nlogger.warning(\"Potential vulnerability detected\")\nlogger.error(\"Failed to connect to sandbox\")\n</code></pre>"},{"location":"api/tools/#custom-exceptions","title":"Custom Exceptions","text":""},{"location":"api/tools/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>class IvexesError(Exception):\n    \"\"\"Base exception class for all IVEXES errors.\"\"\"\n    pass\n\nclass ConfigurationError(IvexesError):\n    \"\"\"Configuration validation failed.\"\"\"\n    pass\n\nclass SandboxError(IvexesError):\n    \"\"\"Sandbox operation failed.\"\"\"\n    pass\n\nclass CodeBrowserError(IvexesError):\n    \"\"\"Code browser operation failed.\"\"\"\n    pass\n\nclass VectorDatabaseError(IvexesError):\n    \"\"\"Vector database operation failed.\"\"\"\n    pass\n</code></pre>"},{"location":"api/tools/#exception-usage-examples","title":"Exception Usage Examples","text":"<pre><code>from ivexes.exceptions import (\n    IvexesError, \n    ConfigurationError, \n    SandboxError, \n    CodeBrowserError, \n    VectorDatabaseError\n)\n\ndef robust_analysis_function():\n    \"\"\"Example of comprehensive error handling.\"\"\"\n\n    try:\n        # Configuration validation\n        if not validate_config():\n            raise ConfigurationError(\"Invalid API key configuration\")\n\n        # Sandbox operations\n        if not setup_sandbox():\n            raise SandboxError(\"Failed to initialize analysis environment\")\n\n        # Code analysis\n        if not analyze_code():\n            raise CodeBrowserError(\"Code parsing failed\")\n\n        # Knowledge base queries\n        if not query_vulnerabilities():\n            raise VectorDatabaseError(\"Knowledge base unavailable\")\n\n    except ConfigurationError as e:\n        print(f\"Configuration issue: {e}\")\n        return {\"error\": \"configuration\", \"details\": str(e)}\n\n    except SandboxError as e:\n        print(f\"Sandbox error: {e}\")\n        return {\"error\": \"sandbox\", \"details\": str(e)}\n\n    except CodeBrowserError as e:\n        print(f\"Code analysis error: {e}\")\n        return {\"error\": \"code_analysis\", \"details\": str(e)}\n\n    except VectorDatabaseError as e:\n        print(f\"Knowledge base error: {e}\")\n        return {\"error\": \"knowledge_base\", \"details\": str(e)}\n\n    except IvexesError as e:\n        print(f\"General IVEXES error: {e}\")\n        return {\"error\": \"general\", \"details\": str(e)}\n\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return {\"error\": \"unexpected\", \"details\": str(e)}\n\n    return {\"status\": \"success\"}\n\n# Usage with error handling\nresult = robust_analysis_function()\nif \"error\" in result:\n    print(f\"Analysis failed: {result['error']} - {result['details']}\")\nelse:\n    print(\"Analysis completed successfully\")\n</code></pre>"},{"location":"api/tools/#usage-examples","title":"Usage Examples","text":""},{"location":"api/tools/#comprehensive-tool-integration","title":"Comprehensive Tool Integration","text":"<pre><code>\"\"\"Complete example integrating multiple tool categories.\"\"\"\n\nimport asyncio\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\nfrom ivexes.tools import (\n    date_tools, \n    cve_tools,\n    create_sandbox_tools,\n    create_vectordb_tools,\n    create_report_tools\n)\nfrom ivexes.token import get_directory_statistics\nfrom ivexes.container import cleanup, santize_name\nfrom ivexes.colors import Colors\nfrom ivexes.exceptions import IvexesError\n\nasync def comprehensive_vulnerability_analysis():\n    \"\"\"Complete vulnerability analysis using all available tools.\"\"\"\n\n    print(f\"{Colors.HEADER}IVEXES Comprehensive Analysis{Colors.ENDC}\")\n\n    try:\n        # Configuration\n        settings = PartialSettings(\n            model='openai/gpt-4o-mini',\n            max_turns=25,\n            codebase_path='/path/to/vulnerable/codebase',\n            vulnerable_folder='vulnerable-v1.0',\n            patched_folder='patched-v1.1',\n            trace_name='comprehensive-analysis'\n        )\n\n        # Clean up any existing containers\n        container_name = santize_name(f\"analysis-{settings.trace_name}\")\n        cleanup(f'{container_name}-')\n\n        # Analyze codebase size\n        print(f\"{Colors.OKCYAN}Analyzing codebase statistics...{Colors.ENDC}\")\n        tokens, chars, words = get_directory_statistics(settings.codebase_path)\n        print(f\"Codebase: {tokens:,} tokens, {chars:,} characters, {words:,} words\")\n\n        # Create all tools\n        sandbox_tools = create_sandbox_tools(settings)\n        vectordb_tools = create_vectordb_tools(settings=settings)\n        report_tools = create_report_tools(settings)\n\n        # Initialize agent with all tools\n        agent = SingleAgent(\n            bin_path='/usr/bin/vulnerable_service',\n            settings=settings\n        )\n\n        print(f\"{Colors.OKGREEN}Starting agent analysis...{Colors.ENDC}\")\n\n        # Agent has access to:\n        # - date_tools: get_current_date\n        # - cve_tools: search_cve_by_id  \n        # - sandbox_tools: setup_sandbox, sandbox_run, etc.\n        # - vectordb_tools: semantic_search_cwe, semantic_search_capec, etc.\n        # - report_tools: create_report\n\n        async for chunk in agent.run_streamed():\n            print(chunk, end='', flush=True)\n\n        print(f\"\\n{Colors.OKGREEN}Analysis completed successfully{Colors.ENDC}\")\n\n    except IvexesError as e:\n        print(f\"{Colors.FAIL}IVEXES Error: {e}{Colors.ENDC}\")\n    except Exception as e:\n        print(f\"{Colors.FAIL}Unexpected Error: {e}{Colors.ENDC}\")\n    finally:\n        # Cleanup\n        print(f\"{Colors.WARNING}Cleaning up resources...{Colors.ENDC}\")\n        cleanup(f'{container_name}-')\n\nif __name__ == \"__main__\":\n    asyncio.run(comprehensive_vulnerability_analysis())\n</code></pre>"},{"location":"api/tools/#custom-tool-development","title":"Custom Tool Development","text":"<pre><code>\"\"\"Example of creating custom tools that integrate with IVEXES.\"\"\"\n\nfrom typing import List, Dict, Any\nfrom agents import function_tool, Tool\nfrom ivexes.config import Settings\nfrom ivexes.token import get_text_statistics\nfrom ivexes.colors import Colors\nfrom ivexes.date.tools import current_date\nimport json\n\ndef create_custom_analysis_tools(settings: Settings) -&gt; List[Tool]:\n    \"\"\"Create custom tools for specialized analysis.\"\"\"\n\n    @function_tool\n    def analyze_code_complexity(code: str) -&gt; str:\n        \"\"\"Analyze code complexity metrics.\n\n        Args:\n            code: Source code to analyze\n\n        Returns:\n            JSON string with complexity metrics\n        \"\"\"\n        lines = code.split('\\n')\n\n        metrics = {\n            'timestamp': current_date(),\n            'total_lines': len(lines),\n            'non_empty_lines': len([line for line in lines if line.strip()]),\n            'comment_lines': len([line for line in lines if line.strip().startswith('#') or line.strip().startswith('//')]),\n            'function_count': code.count('def ') + code.count('function '),\n            'class_count': code.count('class '),\n            'import_count': code.count('import ') + code.count('from '),\n            'complexity_score': 0\n        }\n\n        # Simple complexity calculation\n        complexity_keywords = ['if', 'for', 'while', 'try', 'catch', 'switch', 'case']\n        for keyword in complexity_keywords:\n            metrics['complexity_score'] += code.lower().count(keyword)\n\n        # Token analysis\n        tokens, chars, words = get_text_statistics(code)\n        metrics.update({\n            'tokens': tokens,\n            'characters': chars,\n            'words': words,\n            'token_density': tokens / len(lines) if lines else 0\n        })\n\n        return json.dumps(metrics, indent=2)\n\n    @function_tool\n    def security_keyword_scan(text: str, custom_keywords: str = \"\") -&gt; str:\n        \"\"\"Scan text for security-related keywords.\n\n        Args:\n            text: Text to scan\n            custom_keywords: Additional comma-separated keywords\n\n        Returns:\n            JSON string with scan results\n        \"\"\"\n        # Default security keywords\n        security_keywords = [\n            'password', 'secret', 'token', 'key', 'auth', 'login',\n            'sql', 'inject', 'xss', 'csrf', 'buffer', 'overflow',\n            'vuln', 'exploit', 'backdoor', 'malware', 'attack'\n        ]\n\n        # Add custom keywords\n        if custom_keywords:\n            custom_list = [kw.strip().lower() for kw in custom_keywords.split(',')]\n            security_keywords.extend(custom_list)\n\n        text_lower = text.lower()\n        found_keywords = {}\n\n        for keyword in security_keywords:\n            count = text_lower.count(keyword)\n            if count &gt; 0:\n                found_keywords[keyword] = count\n\n        results = {\n            'timestamp': current_date(),\n            'total_keywords_searched': len(security_keywords),\n            'keywords_found': len(found_keywords),\n            'total_matches': sum(found_keywords.values()),\n            'keyword_matches': found_keywords,\n            'risk_score': min(100, sum(found_keywords.values()) * 10)  # Simple risk scoring\n        }\n\n        return json.dumps(results, indent=2)\n\n    @function_tool\n    def create_analysis_summary(findings: str, severity: str = \"medium\") -&gt; str:\n        \"\"\"Create formatted analysis summary.\n\n        Args:\n            findings: Analysis findings text\n            severity: Severity level (low, medium, high, critical)\n\n        Returns:\n            Formatted summary with color coding\n        \"\"\"\n        severity_colors = {\n            'low': Colors.OKGREEN,\n            'medium': Colors.WARNING,\n            'high': Colors.FAIL,\n            'critical': f\"{Colors.BOLD}{Colors.FAIL}\"\n        }\n\n        color = severity_colors.get(severity.lower(), Colors.OKCYAN)\n\n        summary = f\"\"\"\n{Colors.HEADER}Analysis Summary{Colors.ENDC}\n{Colors.BOLD}Timestamp:{Colors.ENDC} {current_date()}\n{Colors.BOLD}Severity:{Colors.ENDC} {color}{severity.upper()}{Colors.ENDC}\n{Colors.BOLD}Trace:{Colors.ENDC} {settings.trace_name or 'N/A'}\n\n{Colors.UNDERLINE}Findings:{Colors.ENDC}\n{findings}\n\n{Colors.OKCYAN}Generated by IVEXES Custom Analysis Tools{Colors.ENDC}\n\"\"\"\n        return summary\n\n    return [\n        analyze_code_complexity,\n        security_keyword_scan,\n        create_analysis_summary\n    ]\n\n# Usage example\nfrom ivexes.agents import SingleAgent\n\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    trace_name='custom-tool-analysis'\n)\n\n# Create custom tools\ncustom_tools = create_custom_analysis_tools(settings)\n\n# Example manual usage\ncode_sample = \"\"\"\ndef authenticate_user(username, password):\n    if username == \"admin\" and password == \"secret123\":\n        return True\n    return False\n\ndef process_sql_query(query):\n    # Potential SQL injection vulnerability\n    cursor.execute(\"SELECT * FROM users WHERE id = \" + query)\n    return cursor.fetchall()\n\"\"\"\n\n# Test custom tools\ncomplexity_result = custom_tools[0].func(code_sample)\nsecurity_scan = custom_tools[1].func(code_sample, \"admin,secret,injection\")\nsummary = custom_tools[2].func(\"Found potential SQL injection and hardcoded credentials\", \"high\")\n\nprint(\"Complexity Analysis:\")\nprint(complexity_result)\nprint(\"\\nSecurity Scan:\")\nprint(security_scan)\nprint(\"\\nSummary:\")\nprint(summary)\n</code></pre>"},{"location":"api/tools/#tool-performance-monitoring","title":"Tool Performance Monitoring","text":"<pre><code>\"\"\"Performance monitoring and optimization for IVEXES tools.\"\"\"\n\nimport time\nimport functools\nfrom typing import Callable, Any, Dict\nfrom ivexes.colors import Colors\nfrom ivexes.date.tools import current_date\n\nclass ToolPerformanceMonitor:\n    \"\"\"Monitor and track performance of IVEXES tools.\"\"\"\n\n    def __init__(self):\n        self.metrics: Dict[str, Dict[str, Any]] = {}\n\n    def monitor_tool(self, tool_func: Callable) -&gt; Callable:\n        \"\"\"Decorator to monitor tool performance.\"\"\"\n\n        @functools.wraps(tool_func)\n        def wrapper(*args, **kwargs):\n            tool_name = tool_func.__name__\n            start_time = time.time()\n\n            try:\n                result = tool_func(*args, **kwargs)\n                end_time = time.time()\n                execution_time = end_time - start_time\n\n                # Update metrics\n                if tool_name not in self.metrics:\n                    self.metrics[tool_name] = {\n                        'total_calls': 0,\n                        'total_time': 0,\n                        'avg_time': 0,\n                        'min_time': float('inf'),\n                        'max_time': 0,\n                        'last_called': None,\n                        'errors': 0\n                    }\n\n                metrics = self.metrics[tool_name]\n                metrics['total_calls'] += 1\n                metrics['total_time'] += execution_time\n                metrics['avg_time'] = metrics['total_time'] / metrics['total_calls']\n                metrics['min_time'] = min(metrics['min_time'], execution_time)\n                metrics['max_time'] = max(metrics['max_time'], execution_time)\n                metrics['last_called'] = current_date()\n\n                return result\n\n            except Exception as e:\n                end_time = time.time()\n                execution_time = end_time - start_time\n\n                if tool_name not in self.metrics:\n                    self.metrics[tool_name] = {\n                        'total_calls': 0, 'total_time': 0, 'avg_time': 0,\n                        'min_time': float('inf'), 'max_time': 0, \n                        'last_called': None, 'errors': 0\n                    }\n\n                self.metrics[tool_name]['errors'] += 1\n                self.metrics[tool_name]['total_calls'] += 1\n                self.metrics[tool_name]['last_called'] = current_date()\n\n                raise e\n\n        return wrapper\n\n    def get_performance_report(self) -&gt; str:\n        \"\"\"Generate performance report for all monitored tools.\"\"\"\n\n        if not self.metrics:\n            return f\"{Colors.WARNING}No tool performance data available{Colors.ENDC}\"\n\n        report = f\"{Colors.HEADER}Tool Performance Report{Colors.ENDC}\\n\"\n        report += f\"{Colors.BOLD}Generated: {current_date()}{Colors.ENDC}\\n\\n\"\n\n        # Sort tools by total execution time\n        sorted_tools = sorted(\n            self.metrics.items(), \n            key=lambda x: x[1]['total_time'], \n            reverse=True\n        )\n\n        for tool_name, metrics in sorted_tools:\n            success_rate = ((metrics['total_calls'] - metrics['errors']) / \n                          metrics['total_calls'] * 100) if metrics['total_calls'] &gt; 0 else 0\n\n            color = Colors.OKGREEN if success_rate &gt; 95 else Colors.WARNING if success_rate &gt; 80 else Colors.FAIL\n\n            report += f\"{Colors.UNDERLINE}{tool_name}{Colors.ENDC}\\n\"\n            report += f\"  Total calls: {metrics['total_calls']}\\n\"\n            report += f\"  Success rate: {color}{success_rate:.1f}%{Colors.ENDC}\\n\"\n            report += f\"  Total time: {metrics['total_time']:.3f}s\\n\"\n            report += f\"  Avg time: {metrics['avg_time']:.3f}s\\n\"\n            report += f\"  Min time: {metrics['min_time']:.3f}s\\n\"\n            report += f\"  Max time: {metrics['max_time']:.3f}s\\n\"\n            report += f\"  Last called: {metrics['last_called']}\\n\"\n            if metrics['errors'] &gt; 0:\n                report += f\"  {Colors.FAIL}Errors: {metrics['errors']}{Colors.ENDC}\\n\"\n            report += \"\\n\"\n\n        return report\n\n    def reset_metrics(self):\n        \"\"\"Reset all performance metrics.\"\"\"\n        self.metrics.clear()\n\n# Usage example\nmonitor = ToolPerformanceMonitor()\n\n# Monitor existing tools\nfrom ivexes.token import get_text_statistics, get_directory_statistics\nfrom ivexes.container import find_by_name, cleanup\n\n# Wrap tools with monitoring\nmonitored_get_text_statistics = monitor.monitor_tool(get_text_statistics)\nmonitored_get_directory_statistics = monitor.monitor_tool(get_directory_statistics)\nmonitored_find_by_name = monitor.monitor_tool(find_by_name)\n\n# Use monitored tools\ntest_text = \"This is a test vulnerability analysis with multiple security keywords like password and sql injection.\"\n\n# Perform operations\nstats1 = monitored_get_text_statistics(test_text)\nstats2 = monitored_get_text_statistics(test_text * 10)  # Larger text\ncontainer = monitored_find_by_name('nonexistent-container', start=False)\n\n# Generate performance report\nprint(monitor.get_performance_report())\n</code></pre>"},{"location":"api/tools/#integration-patterns","title":"Integration Patterns","text":""},{"location":"api/tools/#agent-tool-integration","title":"Agent Tool Integration","text":"<p>All tools are designed to work seamlessly with IVEXES agents:</p> <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.tools import *\nfrom ivexes.config import PartialSettings\n\n# Tools are automatically available to agents\nsettings = PartialSettings(model='openai/gpt-4o-mini')\nagent = SingleAgent(settings=settings)\n\n# Agent can use:\n# - get_current_date() for timestamps\n# - search_cve_by_id() for vulnerability research\n# - All sandbox, code browser, and vector DB tools\n# - create_report() for documentation\n</code></pre>"},{"location":"api/tools/#multi-agent-tool-sharing","title":"Multi-Agent Tool Sharing","text":"<pre><code>from ivexes.agents.multi_agent import MultiAgent\nfrom ivexes.tools import create_vectordb_tools, create_report_tools\n\n# Shared tools across multiple agents\nvectordb_tools = create_vectordb_tools()\nreport_tools = create_report_tools(settings)\n\nmulti_agent = MultiAgent(settings=settings)\n# All sub-agents have access to shared tool instances\n</code></pre>"},{"location":"api/tools/#best-practices","title":"Best Practices","text":""},{"location":"api/tools/#tool-selection","title":"Tool Selection","text":"<ol> <li>Use Appropriate Tools: Choose tools based on specific functionality needs</li> <li>Monitor Performance: Use performance monitoring for optimization</li> <li>Handle Errors: Implement comprehensive error handling</li> <li>Cache Results: Cache expensive operations when possible</li> <li>Clean Resources: Properly clean up containers and temporary files</li> </ol>"},{"location":"api/tools/#error-handling","title":"Error Handling","text":"<pre><code>from ivexes.exceptions import IvexesError\n\ntry:\n    result = some_tool_function()\nexcept IvexesError as e:\n    # Handle IVEXES-specific errors\n    logger.error(f\"Tool error: {e}\")\nexcept Exception as e:\n    # Handle unexpected errors\n    logger.error(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/tools/#resource-management","title":"Resource Management","text":"<pre><code>from ivexes.container import cleanup\nimport atexit\n\n# Register cleanup on exit\natexit.register(lambda: cleanup('analysis-'))\n\n# Use context managers where available\nwith Sandbox(settings) as sandbox:\n    # Automatic cleanup\n    pass\n</code></pre>"},{"location":"api/tools/#see-also","title":"See Also","text":"<ul> <li>Sandbox API - Sandbox tools and container management</li> <li>Vector Database API - Knowledge base tools and search</li> <li>CVE Search API - Vulnerability research tools</li> <li>Configuration API - Settings and configuration management</li> <li>Examples Guide - Practical usage examples</li> </ul>"},{"location":"api/vector_db/","title":"Vector Database API Reference","text":""},{"location":"api/vector_db/#overview","title":"Overview","text":"<p>The Vector Database module provides comprehensive knowledge base integration for cybersecurity analysis using ChromaDB for vector storage and semantic search. It incorporates three major cybersecurity frameworks: CWE (Common Weakness Enumeration), CAPEC (Common Attack Pattern Enumeration and Classification), and MITRE ATT&amp;CK, enabling agents to query relevant security information using natural language semantic search.</p>"},{"location":"api/vector_db/#key-features","title":"Key Features","text":"<ul> <li>Multi-Framework Integration: CWE, CAPEC, and MITRE ATT&amp;CK data</li> <li>Semantic Search: Vector-based similarity search using embeddings</li> <li>Flexible Embedding Providers: Built-in, local (Sentence Transformers), or OpenAI embeddings</li> <li>Persistent Storage: ChromaDB with configurable storage paths</li> <li>Structured Queries: Type-specific queries for targeted results</li> <li>Lazy/Eager Loading: Configurable initialization strategies</li> </ul>"},{"location":"api/vector_db/#core-classes","title":"Core Classes","text":""},{"location":"api/vector_db/#cwecapecattackdatabase","title":"CweCapecAttackDatabase","text":"<p>Main interface for cybersecurity knowledge base operations with vector similarity search.</p> <pre><code>from ivexes.vector_db import CweCapecAttackDatabase\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    embedding_provider='local',\n    embedding_model='intfloat/multilingual-e5-large-instruct',\n    chroma_path='/path/to/vector/storage'\n)\ndb = CweCapecAttackDatabase(settings, load='eager')\n</code></pre>"},{"location":"api/vector_db/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    settings: IvexesSettings,\n    load: Literal['lazy', 'eager'] = 'lazy'\n) -&gt; None\n</code></pre> <p>Parameters: - <code>settings</code> (IvexesSettings): Configuration including embedding provider, model, and storage path - <code>load</code> (Literal['lazy', 'eager']): Initialization strategy   - <code>'lazy'</code>: Initialize database on first query (default)   - <code>'eager'</code>: Initialize database immediately during construction</p> <p>Example: <pre><code>from ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    embedding_provider='openai',  # or 'local', 'builtin'\n    embedding_model='text-embedding-3-small',\n    openai_api_key='your-api-key',\n    chroma_path='/home/user/.ivexes/chromadb'\n)\n\n# Lazy initialization - database loaded on first query\ndb = CweCapecAttackDatabase(settings, load='lazy')\n\n# Eager initialization - database loaded immediately\ndb = CweCapecAttackDatabase(settings, load='eager')\n</code></pre></p>"},{"location":"api/vector_db/#initialization-methods","title":"Initialization Methods","text":""},{"location":"api/vector_db/#initialize","title":"initialize()","text":"<p>Download and initialize all cybersecurity knowledge bases with error handling.</p> <pre><code>def initialize(self) -&gt; None\n</code></pre> <p>Process: 1. Configure embedding function based on settings 2. Create ChromaDB persistent client 3. Initialize collection with embedding function 4. Download and parse CWE, CAPEC, and ATT&amp;CK data if collection is empty</p> <p>Example: <pre><code>db = CweCapecAttackDatabase(settings, load='lazy')\n# Manually trigger initialization\ndb.initialize()\nprint(f\"Database initialized with {db.collection.count()} entries\")\n</code></pre></p>"},{"location":"api/vector_db/#initialize_cwe","title":"initialize_cwe()","text":"<p>Initialize database with CWE (Common Weakness Enumeration) data.</p> <pre><code>def initialize_cwe(self) -&gt; None\n</code></pre> <p>Downloads and parses CWE XML data from MITRE, extracting weakness definitions and relationships.</p>"},{"location":"api/vector_db/#initialize_capec","title":"initialize_capec()","text":"<p>Initialize database with CAPEC (Common Attack Pattern Enumeration) data.</p> <pre><code>def initialize_capec(self) -&gt; None\n</code></pre> <p>Downloads and parses CAPEC XML data, extracting attack pattern descriptions and relationships.</p>"},{"location":"api/vector_db/#initialize_attack","title":"initialize_attack()","text":"<p>Initialize database with MITRE ATT&amp;CK framework data.</p> <pre><code>def initialize_attack(self) -&gt; None\n</code></pre> <p>Downloads and parses ATT&amp;CK STIX data including techniques, tactics, mitigations, groups, and software.</p>"},{"location":"api/vector_db/#query-methods","title":"Query Methods","text":""},{"location":"api/vector_db/#query","title":"query()","text":"<p>General-purpose semantic search across knowledge bases with type filtering.</p> <pre><code>def query(\n    self, \n    query_text: str, \n    types: list[QueryTypes] | None = None, \n    n: int = 3\n) -&gt; list[str]\n</code></pre> <p>Parameters: - <code>query_text</code> (str): Natural language query - <code>types</code> (list[QueryTypes] | None): Filter by specific data types (default: all types) - <code>n</code> (int): Number of results to return</p> <p>Returns: - <code>list[str]</code>: List of formatted knowledge base entries</p> <p>Query Types: <pre><code>QueryTypes = Literal[\n    'cwe',                  # Common Weakness Enumeration\n    'capec',                # Common Attack Pattern Enumeration  \n    'attack-technique',     # ATT&amp;CK Techniques\n    'attack-mitigation',    # ATT&amp;CK Mitigations\n    'attack-group',         # ATT&amp;CK Threat Groups\n    'attack-malware',       # ATT&amp;CK Malware\n    'attack-tool',          # ATT&amp;CK Tools\n    'attack-tactic',        # ATT&amp;CK Tactics\n]\n</code></pre></p> <p>Example: <pre><code># General search across all knowledge bases\nresults = db.query(\"buffer overflow vulnerability\", n=5)\nfor result in results:\n    print(result)\n\n# Search specific types\ncwe_results = db.query(\n    \"sql injection\", \n    types=['cwe', 'capec'], \n    n=3\n)\n\n# Search ATT&amp;CK techniques only\nattack_results = db.query(\n    \"privilege escalation\",\n    types=['attack-technique', 'attack-tactic'],\n    n=5\n)\n</code></pre></p>"},{"location":"api/vector_db/#query_cwe","title":"query_cwe()","text":"<p>Search Common Weakness Enumeration entries.</p> <pre><code>def query_cwe(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre> <p>Example: <pre><code>weaknesses = db.query_cwe(\"cross-site scripting\", n=5)\nfor weakness in weaknesses:\n    print(weakness)\n</code></pre></p>"},{"location":"api/vector_db/#query_capec","title":"query_capec()","text":"<p>Search Common Attack Pattern Enumeration entries.</p> <pre><code>def query_capec(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre> <p>Example: <pre><code>attack_patterns = db.query_capec(\"social engineering\", n=3)\nfor pattern in attack_patterns:\n    print(pattern)\n</code></pre></p>"},{"location":"api/vector_db/#query_attack_techniques","title":"query_attack_techniques()","text":"<p>Search MITRE ATT&amp;CK techniques.</p> <pre><code>def query_attack_techniques(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre> <p>Example: <pre><code>techniques = db.query_attack_techniques(\"lateral movement\", n=5)\nfor technique in techniques:\n    print(technique)\n</code></pre></p>"},{"location":"api/vector_db/#query_attack_tactics","title":"query_attack_tactics()","text":"<p>Search MITRE ATT&amp;CK tactics (kill chain phases).</p> <pre><code>def query_attack_tactics(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre>"},{"location":"api/vector_db/#query_attack_mitigations","title":"query_attack_mitigations()","text":"<p>Search MITRE ATT&amp;CK mitigations.</p> <pre><code>def query_attack_mitigations(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre>"},{"location":"api/vector_db/#query_attack_groups","title":"query_attack_groups()","text":"<p>Search MITRE ATT&amp;CK threat groups.</p> <pre><code>def query_attack_groups(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre>"},{"location":"api/vector_db/#query_attack_software","title":"query_attack_software()","text":"<p>Search MITRE ATT&amp;CK software (malware and tools).</p> <pre><code>def query_attack_software(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre>"},{"location":"api/vector_db/#query_attack_all","title":"query_attack_all()","text":"<p>Search all MITRE ATT&amp;CK data types.</p> <pre><code>def query_attack_all(self, query_text: str, n: int = 3) -&gt; list[str]\n</code></pre> <p>Example: <pre><code># Comprehensive ATT&amp;CK search\nall_attack_info = db.query_attack_all(\"ransomware\", n=10)\nfor info in all_attack_info:\n    print(info)\n</code></pre></p>"},{"location":"api/vector_db/#utility-methods","title":"Utility Methods","text":""},{"location":"api/vector_db/#clear","title":"clear()","text":"<p>Clear all data from the database collection.</p> <pre><code>def clear(self) -&gt; None\n</code></pre> <p>Example: <pre><code># Clear all data for fresh initialization\ndb.clear()\ndb.initialize()  # Reload data\n</code></pre></p>"},{"location":"api/vector_db/#tool-functions","title":"Tool Functions","text":""},{"location":"api/vector_db/#create_vectordb_tools","title":"create_vectordb_tools()","text":"<p>Create vector database tools for agent integration.</p> <pre><code>from ivexes.vector_db.tools import create_vectordb_tools\n\ndef create_vectordb_tools(\n    db: Optional[CweCapecAttackDatabase] = None, \n    settings: Optional[Settings] = None\n) -&gt; list[Tool]\n</code></pre> <p>Parameters: - <code>db</code> (Optional[CweCapecAttackDatabase]): Database instance (creates new if not provided) - <code>settings</code> (Optional[Settings]): Configuration settings (loads from environment if not provided)</p> <p>Returns: - <code>list[Tool]</code>: List of tool functions for agent use</p> <p>Available Tools: - <code>semantic_search_cwe()</code>: Search CWE entries - <code>semantic_search_capec()</code>: Search CAPEC entries - <code>semantic_search_attack_techniques()</code>: Search ATT&amp;CK techniques - <code>semantic_search_attack_tactics()</code>: Search ATT&amp;CK tactics - <code>semantic_search_attack_mitigations()</code>: Search ATT&amp;CK mitigations - <code>semantic_search_attack_groups()</code>: Search ATT&amp;CK groups - <code>semantic_search_attack_software()</code>: Search ATT&amp;CK software - <code>semantic_search_attack_all()</code>: Search all ATT&amp;CK data - <code>semantic_search()</code>: General search with type filtering</p> <p>Example: <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.vector_db.tools import create_vectordb_tools\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    embedding_provider='local',\n    embedding_model='intfloat/multilingual-e5-large-instruct'\n)\n\n# Create tools for agent\ntools = create_vectordb_tools(settings=settings)\n\n# Use with agent\nagent = SingleAgent(bin_path='/usr/bin/target', settings=settings)\n# Tools are automatically available to the agent\n</code></pre></p>"},{"location":"api/vector_db/#tool-functions-reference","title":"Tool Functions Reference","text":""},{"location":"api/vector_db/#semantic_search_cwe","title":"semantic_search_cwe()","text":"<p>Agent tool for searching CWE entries.</p> <pre><code>@function_tool\ndef semantic_search_cwe(query: str, n: int = 5) -&gt; str\n</code></pre> <p>Parameters: - <code>query</code> (str): Search query - <code>n</code> (int): Number of results (default: 5)</p> <p>Returns: - <code>str</code>: Formatted search results</p>"},{"location":"api/vector_db/#semantic_search_capec","title":"semantic_search_capec()","text":"<p>Agent tool for searching CAPEC entries.</p> <pre><code>@function_tool\ndef semantic_search_capec(query: str, n: int = 5) -&gt; str\n</code></pre>"},{"location":"api/vector_db/#semantic_search_attack_techniques","title":"semantic_search_attack_techniques()","text":"<p>Agent tool for searching ATT&amp;CK techniques.</p> <pre><code>@function_tool\ndef semantic_search_attack_techniques(query: str, n: int = 5) -&gt; str\n</code></pre>"},{"location":"api/vector_db/#semantic_search","title":"semantic_search()","text":"<p>General semantic search with type filtering.</p> <pre><code>@function_tool\ndef semantic_search(query: str, type: list[QueryTypes], n: int = 5) -&gt; str\n</code></pre> <p>Parameters: - <code>query</code> (str): Search query - <code>type</code> (list[QueryTypes]): Types to search - <code>n</code> (int): Number of results</p>"},{"location":"api/vector_db/#usage-examples","title":"Usage Examples","text":""},{"location":"api/vector_db/#basic-knowledge-base-search","title":"Basic Knowledge Base Search","text":"<pre><code>\"\"\"Basic vector database operations.\"\"\"\n\nfrom ivexes.vector_db import CweCapecAttackDatabase\nfrom ivexes.config import PartialSettings\n\n# Configure database\nsettings = PartialSettings(\n    embedding_provider='local',\n    embedding_model='intfloat/multilingual-e5-large-instruct',\n    chroma_path='/tmp/ivexes/chromadb'\n)\n\n# Initialize database\ndb = CweCapecAttackDatabase(settings, load='eager')\n\n# Search for vulnerabilities\nbuffer_overflow_cwe = db.query_cwe(\"buffer overflow\", n=3)\nprint(\"Buffer Overflow CWE Entries:\")\nfor entry in buffer_overflow_cwe:\n    print(f\"- {entry}\")\n\n# Search for attack patterns\nsocial_engineering = db.query_capec(\"social engineering\", n=3)\nprint(\"\\nSocial Engineering CAPEC:\")\nfor pattern in social_engineering:\n    print(f\"- {pattern}\")\n\n# Search ATT&amp;CK techniques\npersistence = db.query_attack_techniques(\"persistence mechanisms\", n=5)\nprint(\"\\nPersistence Techniques:\")\nfor technique in persistence:\n    print(f\"- {technique}\")\n</code></pre>"},{"location":"api/vector_db/#multi-type-knowledge-analysis","title":"Multi-Type Knowledge Analysis","text":"<pre><code>\"\"\"Advanced multi-type knowledge base analysis.\"\"\"\n\nfrom ivexes.vector_db import CweCapecAttackDatabase\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    embedding_provider='openai',\n    embedding_model='text-embedding-3-small',\n    openai_api_key='your-api-key'\n)\n\ndb = CweCapecAttackDatabase(settings)\n\ndef analyze_security_topic(topic: str) -&gt; dict:\n    \"\"\"Comprehensive analysis of a security topic across all knowledge bases.\"\"\"\n\n    analysis = {\n        'topic': topic,\n        'weaknesses': db.query_cwe(topic, n=3),\n        'attack_patterns': db.query_capec(topic, n=3),\n        'techniques': db.query_attack_techniques(topic, n=3),\n        'mitigations': db.query_attack_mitigations(topic, n=3),\n        'threat_groups': db.query_attack_groups(topic, n=2)\n    }\n\n    return analysis\n\n# Analyze web application security\nweb_security = analyze_security_topic(\"web application security\")\n\nprint(f\"Analysis: {web_security['topic']}\")\nprint(f\"Found {len(web_security['weaknesses'])} related weaknesses\")\nprint(f\"Found {len(web_security['attack_patterns'])} attack patterns\")\nprint(f\"Found {len(web_security['techniques'])} techniques\")\nprint(f\"Found {len(web_security['mitigations'])} mitigations\")\n\n# Cross-reference analysis\nfor weakness in web_security['weaknesses']:\n    print(f\"Weakness: {weakness[:100]}...\")\n</code></pre>"},{"location":"api/vector_db/#agent-integration-example","title":"Agent Integration Example","text":"<pre><code>\"\"\"Vector database integration with IVEXES agents.\"\"\"\n\nimport asyncio\nfrom ivexes.agents import SingleAgent\nfrom ivexes.vector_db.tools import create_vectordb_tools\nfrom ivexes.config import PartialSettings\n\nasync def vulnerability_research_agent():\n    \"\"\"Agent with vector database knowledge for enhanced analysis.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=20,\n        embedding_provider='local',\n        embedding_model='intfloat/multilingual-e5-large-instruct',\n        codebase_path='/path/to/vulnerable/code'\n    )\n\n    # Create vector database tools\n    vectordb_tools = create_vectordb_tools(settings=settings)\n\n    agent = SingleAgent(\n        bin_path='/usr/bin/vulnerable_service',\n        settings=settings\n    )\n\n    print(\"Starting vulnerability research with knowledge base integration...\")\n\n    # Agent now has access to all semantic search tools:\n    # - semantic_search_cwe\n    # - semantic_search_capec\n    # - semantic_search_attack_techniques\n    # - semantic_search_attack_mitigations\n    # - semantic_search_attack_groups\n    # - semantic_search_attack_software\n    # - semantic_search_attack_all\n    # - semantic_search\n\n    async for chunk in agent.run_streamed():\n        print(chunk, end='', flush=True)\n\n# Run the research agent\nif __name__ == \"__main__\":\n    asyncio.run(vulnerability_research_agent())\n</code></pre>"},{"location":"api/vector_db/#custom-knowledge-base-analysis","title":"Custom Knowledge Base Analysis","text":"<pre><code>\"\"\"Custom knowledge base analysis with advanced filtering.\"\"\"\n\nfrom ivexes.vector_db import CweCapecAttackDatabase, QueryTypes\nfrom ivexes.config import PartialSettings\nfrom typing import Dict, List\n\nclass SecurityKnowledgeAnalyzer:\n    \"\"\"Advanced security knowledge analyzer with custom query strategies.\"\"\"\n\n    def __init__(self, settings: PartialSettings):\n        self.db = CweCapecAttackDatabase(settings, load='lazy')\n        self.cache = {}\n\n    def comprehensive_threat_analysis(self, threat_description: str) -&gt; Dict[str, List[str]]:\n        \"\"\"Perform comprehensive threat analysis across all knowledge bases.\"\"\"\n\n        if threat_description in self.cache:\n            return self.cache[threat_description]\n\n        # Ensure database is initialized\n        self.db._check_database()\n\n        analysis = {\n            'threat_description': threat_description,\n            'related_weaknesses': self.db.query_cwe(threat_description, n=5),\n            'attack_patterns': self.db.query_capec(threat_description, n=5),\n            'attack_techniques': self.db.query_attack_techniques(threat_description, n=5),\n            'defensive_mitigations': self.db.query_attack_mitigations(threat_description, n=5),\n            'known_threat_groups': self.db.query_attack_groups(threat_description, n=3),\n            'associated_malware': self.db.query_attack_software(threat_description, n=3)\n        }\n\n        # Cache results\n        self.cache[threat_description] = analysis\n        return analysis\n\n    def find_related_patterns(self, cwe_id: str) -&gt; Dict[str, List[str]]:\n        \"\"\"Find related attack patterns and techniques for a specific CWE.\"\"\"\n\n        # Search for the specific CWE\n        cwe_details = self.db.query_cwe(cwe_id, n=1)\n        if not cwe_details:\n            return {'error': f'CWE {cwe_id} not found'}\n\n        cwe_description = cwe_details[0]\n\n        # Extract key terms from CWE description for broader search\n        search_terms = cwe_description.split()[:10]  # Use first 10 words\n        search_query = ' '.join(search_terms)\n\n        return {\n            'cwe_details': cwe_details,\n            'related_capec': self.db.query_capec(search_query, n=5),\n            'attack_techniques': self.db.query_attack_techniques(search_query, n=5),\n            'mitigations': self.db.query_attack_mitigations(search_query, n=3)\n        }\n\n    def threat_landscape_analysis(self, domain: str) -&gt; Dict[str, int]:\n        \"\"\"Analyze threat landscape for a specific domain.\"\"\"\n\n        landscape = {}\n\n        # Count different types of threats\n        all_types: List[QueryTypes] = [\n            'cwe', 'capec', 'attack-technique', 'attack-mitigation',\n            'attack-group', 'attack-malware', 'attack-tool', 'attack-tactic'\n        ]\n\n        for threat_type in all_types:\n            results = self.db.query(domain, types=[threat_type], n=10)\n            landscape[threat_type] = len(results)\n\n        return landscape\n\n# Usage example\nsettings = PartialSettings(\n    embedding_provider='local',\n    embedding_model='intfloat/multilingual-e5-large-instruct'\n)\n\nanalyzer = SecurityKnowledgeAnalyzer(settings)\n\n# Comprehensive analysis\nransomware_analysis = analyzer.comprehensive_threat_analysis(\"ransomware attack\")\nprint(f\"Ransomware Analysis Results:\")\nprint(f\"- Related weaknesses: {len(ransomware_analysis['related_weaknesses'])}\")\nprint(f\"- Attack patterns: {len(ransomware_analysis['attack_patterns'])}\")\nprint(f\"- Attack techniques: {len(ransomware_analysis['attack_techniques'])}\")\n\n# CWE-specific analysis\nbuffer_overflow_patterns = analyzer.find_related_patterns(\"CWE-120\")\nprint(f\"\\nBuffer Overflow (CWE-120) Related Patterns:\")\nprint(f\"- Related CAPEC patterns: {len(buffer_overflow_patterns.get('related_capec', []))}\")\n\n# Domain threat landscape\nweb_landscape = analyzer.threat_landscape_analysis(\"web application\")\nprint(f\"\\nWeb Application Threat Landscape:\")\nfor threat_type, count in web_landscape.items():\n    print(f\"- {threat_type}: {count} entries\")\n</code></pre>"},{"location":"api/vector_db/#performance-optimization-example","title":"Performance Optimization Example","text":"<pre><code>\"\"\"Vector database performance optimization and batch operations.\"\"\"\n\nfrom ivexes.vector_db import CweCapecAttackDatabase\nfrom ivexes.config import PartialSettings\nimport time\nfrom typing import List, Dict\n\nclass OptimizedKnowledgeSearch:\n    \"\"\"Optimized knowledge base search with caching and batch operations.\"\"\"\n\n    def __init__(self, settings: PartialSettings):\n        # Use eager loading for better performance\n        self.db = CweCapecAttackDatabase(settings, load='eager')\n        self.search_cache = {}\n        self.batch_cache = {}\n\n    def cached_search(self, query: str, types: List[str] = None, n: int = 5) -&gt; List[str]:\n        \"\"\"Cached search to avoid repeated queries.\"\"\"\n\n        cache_key = f\"{query}_{types}_{n}\"\n        if cache_key in self.search_cache:\n            return self.search_cache[cache_key]\n\n        results = self.db.query(query, types, n)\n        self.search_cache[cache_key] = results\n        return results\n\n    def batch_search(self, queries: List[str], types: List[str] = None, n: int = 3) -&gt; Dict[str, List[str]]:\n        \"\"\"Perform batch searches efficiently.\"\"\"\n\n        batch_key = f\"{hash(tuple(queries))}_{types}_{n}\"\n        if batch_key in self.batch_cache:\n            return self.batch_cache[batch_key]\n\n        results = {}\n        for query in queries:\n            results[query] = self.cached_search(query, types, n)\n\n        self.batch_cache[batch_key] = results\n        return results\n\n    def clear_cache(self):\n        \"\"\"Clear search caches.\"\"\"\n        self.search_cache.clear()\n        self.batch_cache.clear()\n\n# Performance testing\nsettings = PartialSettings(\n    embedding_provider='builtin',  # Fastest for testing\n    chroma_path='/tmp/ivexes/perf_test'\n)\n\noptimizer = OptimizedKnowledgeSearch(settings)\n\n# Batch vulnerability analysis\nvulnerability_queries = [\n    \"sql injection\",\n    \"cross-site scripting\", \n    \"buffer overflow\",\n    \"privilege escalation\",\n    \"authentication bypass\"\n]\n\nstart_time = time.time()\nbatch_results = optimizer.batch_search(vulnerability_queries, types=['cwe', 'capec'], n=3)\nbatch_time = time.time() - start_time\n\nprint(f\"Batch search completed in {batch_time:.2f} seconds\")\nprint(f\"Found results for {len(batch_results)} queries\")\n\n# Test cache performance\nstart_time = time.time()\ncached_results = optimizer.batch_search(vulnerability_queries, types=['cwe', 'capec'], n=3)\ncached_time = time.time() - start_time\n\nprint(f\"Cached search completed in {cached_time:.2f} seconds\")\nprint(f\"Performance improvement: {(batch_time - cached_time) / batch_time * 100:.1f}%\")\n</code></pre>"},{"location":"api/vector_db/#configuration","title":"Configuration","text":""},{"location":"api/vector_db/#embedding-providers","title":"Embedding Providers","text":""},{"location":"api/vector_db/#built-in-provider-default","title":"Built-in Provider (Default)","text":"<pre><code>settings = PartialSettings(\n    embedding_provider='builtin'  # ChromaDB default embedding\n)\n</code></pre>"},{"location":"api/vector_db/#local-provider-sentence-transformers","title":"Local Provider (Sentence Transformers)","text":"<pre><code>settings = PartialSettings(\n    embedding_provider='local',\n    embedding_model='intfloat/multilingual-e5-large-instruct'\n)\n</code></pre>"},{"location":"api/vector_db/#openai-provider","title":"OpenAI Provider","text":"<pre><code>settings = PartialSettings(\n    embedding_provider='openai',\n    embedding_model='text-embedding-3-small',\n    openai_api_key='your-api-key'\n)\n</code></pre>"},{"location":"api/vector_db/#storage-configuration","title":"Storage Configuration","text":"<pre><code>settings = PartialSettings(\n    chroma_path='/home/user/.ivexes/chromadb',  # Custom storage path\n    embedding_model='intfloat/multilingual-e5-large-instruct'\n)\n</code></pre>"},{"location":"api/vector_db/#error-handling","title":"Error Handling","text":""},{"location":"api/vector_db/#common-errors","title":"Common Errors","text":"<ol> <li>Initialization Failures: Network issues downloading knowledge bases</li> <li>Embedding Errors: Invalid API keys or model names</li> <li>Storage Issues: Insufficient disk space or permissions</li> <li>Query Errors: Invalid query types or parameters</li> </ol>"},{"location":"api/vector_db/#error-handling-example","title":"Error Handling Example","text":"<pre><code>\"\"\"Robust vector database usage with comprehensive error handling.\"\"\"\n\nfrom ivexes.vector_db import CweCapecAttackDatabase\nfrom ivexes.config import PartialSettings\nfrom ivexes.exceptions import VectorDatabaseError\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef robust_knowledge_search(query: str) -&gt; dict:\n    \"\"\"Perform knowledge search with comprehensive error handling.\"\"\"\n\n    settings = PartialSettings(\n        embedding_provider='local',\n        embedding_model='intfloat/multilingual-e5-large-instruct',\n        chroma_path='/tmp/ivexes/robust_test'\n    )\n\n    try:\n        # Initialize database with retry logic\n        db = None\n        for attempt in range(3):\n            try:\n                db = CweCapecAttackDatabase(settings, load='eager')\n                logger.info(f\"Database initialized on attempt {attempt + 1}\")\n                break\n            except Exception as e:\n                logger.warning(f\"Initialization attempt {attempt + 1} failed: {e}\")\n                if attempt == 2:\n                    raise VectorDatabaseError(f\"Failed to initialize after 3 attempts: {e}\")\n\n        # Perform searches with error handling\n        results = {\n            'query': query,\n            'cwe_results': [],\n            'capec_results': [],\n            'attack_results': [],\n            'errors': []\n        }\n\n        # CWE search\n        try:\n            results['cwe_results'] = db.query_cwe(query, n=3)\n            logger.info(f\"CWE search successful: {len(results['cwe_results'])} results\")\n        except Exception as e:\n            results['errors'].append(f\"CWE search failed: {e}\")\n            logger.error(f\"CWE search error: {e}\")\n\n        # CAPEC search\n        try:\n            results['capec_results'] = db.query_capec(query, n=3)\n            logger.info(f\"CAPEC search successful: {len(results['capec_results'])} results\")\n        except Exception as e:\n            results['errors'].append(f\"CAPEC search failed: {e}\")\n            logger.error(f\"CAPEC search error: {e}\")\n\n        # ATT&amp;CK search\n        try:\n            results['attack_results'] = db.query_attack_all(query, n=5)\n            logger.info(f\"ATT&amp;CK search successful: {len(results['attack_results'])} results\")\n        except Exception as e:\n            results['errors'].append(f\"ATT&amp;CK search failed: {e}\")\n            logger.error(f\"ATT&amp;CK search error: {e}\")\n\n        return results\n\n    except VectorDatabaseError as e:\n        logger.error(f\"Vector database error: {e}\")\n        return {\n            'query': query,\n            'error': str(e),\n            'success': False\n        }\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        return {\n            'query': query,\n            'error': f\"Unexpected error: {e}\",\n            'success': False\n        }\n\n# Usage with error handling\nsearch_results = robust_knowledge_search(\"privilege escalation\")\n\nif 'error' in search_results:\n    print(f\"Search failed: {search_results['error']}\")\nelse:\n    print(f\"Search Results for: {search_results['query']}\")\n    print(f\"- CWE entries: {len(search_results['cwe_results'])}\")\n    print(f\"- CAPEC entries: {len(search_results['capec_results'])}\")\n    print(f\"- ATT&amp;CK entries: {len(search_results['attack_results'])}\")\n\n    if search_results['errors']:\n        print(f\"- Partial failures: {len(search_results['errors'])}\")\n        for error in search_results['errors']:\n            print(f\"  * {error}\")\n</code></pre>"},{"location":"api/vector_db/#best-practices","title":"Best Practices","text":""},{"location":"api/vector_db/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Use Eager Loading: For applications with frequent queries</li> <li>Cache Results: Implement caching for repeated searches</li> <li>Batch Queries: Group related searches together</li> <li>Choose Appropriate Embedding Models: Balance accuracy vs speed</li> <li>Monitor Storage: Vector databases can consume significant disk space</li> </ol>"},{"location":"api/vector_db/#security-considerations","title":"Security Considerations","text":"<ol> <li>API Key Management: Secure storage of OpenAI API keys</li> <li>Storage Permissions: Appropriate file system permissions for ChromaDB</li> <li>Network Security: Consider network access for embedding providers</li> <li>Data Validation: Validate query inputs to prevent injection attacks</li> </ol>"},{"location":"api/vector_db/#troubleshooting","title":"Troubleshooting","text":"<ol> <li>Slow Initialization: Check network connectivity for knowledge base downloads</li> <li>High Memory Usage: Consider using built-in embeddings for resource-constrained environments</li> <li>Inconsistent Results: Ensure consistent embedding model across sessions</li> <li>Storage Issues: Monitor disk space and ChromaDB directory permissions</li> </ol>"},{"location":"api/vector_db/#see-also","title":"See Also","text":"<ul> <li>Configuration API - Settings and configuration management</li> <li>Tools API - Shared utilities and helpers</li> <li>Agents API - Agent integration and tool usage</li> <li>Examples Guide - Practical usage examples</li> </ul>"},{"location":"documentation/architecture/","title":"Architecture Guide","text":""},{"location":"documentation/architecture/#overview","title":"Overview","text":"<p>IVEXES (Intelligent Vulnerability Extraction &amp; Exploit Synthesis) is a Python framework designed for cybersecurity vulnerability analysis and exploitation using multi-agent AI systems. It combines knowledge bases (CWE, CAPEC, MITRE ATT&amp;CK) with dynamic analysis capabilities for automated security assessment.</p> <p>The system follows a modular architecture with clear separation of concerns, enabling extensibility and maintainability while providing powerful vulnerability analysis capabilities.</p>"},{"location":"documentation/architecture/#system-architecture","title":"System Architecture","text":""},{"location":"documentation/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         IVEXES Framework                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502     Agents      \u2502    \u2502  Code Browser   \u2502    \u2502    Sandbox     \u2502  \u2502\n\u2502  \u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502  \u2502\n\u2502  \u2502  \u2022 BaseAgent    \u2502\u25c4\u2500\u2500\u25ba\u2502  \u2022 CodeBrowser  \u2502\u25c4\u2500\u2500\u25ba\u2502  \u2022 Sandbox     \u2502  \u2502\n\u2502  \u2502  \u2022 SingleAgent  \u2502    \u2502  \u2022 Nvim LSP     \u2502    \u2502  \u2022 Container   \u2502  \u2502\n\u2502  \u2502  \u2022 MultiAgent   \u2502    \u2502  \u2022 Parser       \u2502    \u2502  \u2022 Kali Linux  \u2502  \u2502\n\u2502  \u2502  \u2022 MVPAgent     \u2502    \u2502  \u2022 Navigation   \u2502    \u2502  \u2022 Isolation   \u2502  \u2502\n\u2502  \u2502  \u2022 HTBAgent     \u2502    \u2502                 \u2502    \u2502                 \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502           \u2502                       \u2502                       \u2502         \u2502\n\u2502           \u2502                       \u2502                       \u2502         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502   Vector DB     \u2502    \u2502  Configuration  \u2502    \u2502     Printer     \u2502  \u2502\n\u2502  \u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502  \u2502\n\u2502  \u2502  \u2022 ChromaDB     \u2502\u25c4\u2500\u2500\u25ba\u2502  \u2022 Settings     \u2502\u25c4\u2500\u2500\u25ba\u2502  \u2022 Formatter   \u2502  \u2502\n\u2502  \u2502  \u2022 Embeddings   \u2502    \u2502  \u2022 Environment  \u2502    \u2502  \u2022 Components  \u2502  \u2502\n\u2502  \u2502  \u2022 MITRE Data   \u2502    \u2502  \u2022 Validation   \u2502    \u2502  \u2022 Output      \u2502  \u2502\n\u2502  \u2502  \u2022 CVE Search   \u2502    \u2502                 \u2502    \u2502                 \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/architecture/#component-relationships","title":"Component Relationships","text":"<p>The architecture is built around several key components that work together:</p> <ol> <li>Agents serve as the intelligence layer, orchestrating analysis workflows</li> <li>Code Browser provides code analysis and navigation capabilities</li> <li>Sandbox offers isolated execution environments for dynamic analysis</li> <li>Vector Database stores and retrieves vulnerability knowledge</li> <li>Configuration manages settings and environment parameters</li> <li>Printer handles formatted output and reporting</li> </ol>"},{"location":"documentation/architecture/#core-components","title":"Core Components","text":""},{"location":"documentation/architecture/#agent-system","title":"Agent System","text":"<p>The agent system forms the core intelligence layer of IVEXES, implementing different analysis strategies:</p>"},{"location":"documentation/architecture/#baseagent-abstract","title":"BaseAgent (Abstract)","text":"<ul> <li>Purpose: Provides common functionality and interface for all agents</li> <li>Key Features:</li> <li>Settings management and validation</li> <li>Execution modes (sync, streaming, interactive)</li> <li>Session tracking and persistence</li> <li>Resource cleanup and lifecycle management</li> <li>Design Pattern: Template Method Pattern</li> </ul>"},{"location":"documentation/architecture/#singleagent","title":"SingleAgent","text":"<ul> <li>Purpose: Individual vulnerability analysis with comprehensive toolset</li> <li>Key Features:</li> <li>Code browser integration for source analysis</li> <li>Sandbox tools for dynamic testing</li> <li>Vector database integration for knowledge retrieval</li> <li>CVE search capabilities</li> <li>Use Cases: Focused vulnerability assessment, binary analysis</li> </ul>"},{"location":"documentation/architecture/#multiagent","title":"MultiAgent","text":"<ul> <li>Purpose: Orchestrated multi-agent analysis for complex scenarios</li> <li>Key Features:</li> <li>Shared context management across agents</li> <li>Coordinated workflow execution</li> <li>Distributed analysis capabilities</li> <li>Result aggregation and synthesis</li> <li>Use Cases: Large-scale assessments, collaborative analysis</li> </ul>"},{"location":"documentation/architecture/#specialized-agents","title":"Specialized Agents","text":"<ul> <li>MVPAgent: Minimal viable product implementation for basic functionality</li> <li>HTBChallengeAgent: Specialized for Hack The Box challenge analysis</li> <li>DefaultAgent: General-purpose implementation with standard configuration</li> </ul>"},{"location":"documentation/architecture/#code-browser-system","title":"Code Browser System","text":"<p>The code browser provides sophisticated code analysis capabilities through LSP integration:</p>"},{"location":"documentation/architecture/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   CodeBrowser   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Structure     \u2502\u25c4\u2500\u2500\u2510\n\u2502 \u2022 Navigation    \u2502   \u2502\n\u2502 \u2022 Diff Analysis \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n         \u2502             \u2502\n         \u25bc             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   Nvim LSP      \u2502   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\n\u2502 \u2022 Language      \u2502   \u2502\n\u2502   Server        \u2502   \u2502\n\u2502 \u2022 Semantic      \u2502   \u2502\n\u2502   Analysis      \u2502   \u2502\n\u2502 \u2022 Completion    \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n         \u2502             \u2502\n         \u25bc             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502     Parser      \u2502\u2500\u2500\u2500\u2518\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Tree-sitter   \u2502\n\u2502 \u2022 AST Analysis  \u2502\n\u2502 \u2022 Code Structure\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/architecture/#key-features","title":"Key Features","text":"<ul> <li>LSP Integration: Leverages Language Server Protocol for accurate code analysis</li> <li>Container Isolation: Runs in isolated Docker environment for security</li> <li>Multi-language Support: Supports various programming languages through LSP</li> <li>Diff Analysis: Compares vulnerable and patched versions</li> <li>Code Navigation: Semantic code browsing and symbol resolution</li> </ul>"},{"location":"documentation/architecture/#sandbox-system","title":"Sandbox System","text":"<p>The sandbox provides secure, isolated execution environments for dynamic analysis:</p>"},{"location":"documentation/architecture/#architecture_1","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Sandbox     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Lifecycle     \u2502\n\u2502 \u2022 Configuration \u2502\n\u2502 \u2022 Tool Access   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SandboxContainer\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Docker Mgmt   \u2502\n\u2502 \u2022 File Transfer \u2502\n\u2502 \u2022 Execution     \u2502\n\u2502 \u2022 Monitoring    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Kali Linux     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Security Tools\u2502\n\u2502 \u2022 SSH Access    \u2502\n\u2502 \u2022 Isolated Env  \u2502\n\u2502 \u2022 Auto Setup    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/architecture/#key-features_1","title":"Key Features","text":"<ul> <li>Container-based Isolation: Docker containers for secure execution</li> <li>Kali Linux Environment: Pre-configured with security testing tools  </li> <li>Automatic Setup: Extracts and configures analysis targets from archives</li> <li>SSH Integration: Remote command execution and file transfer</li> <li>Resource Management: Container lifecycle and resource cleanup</li> </ul>"},{"location":"documentation/architecture/#vector-database-system","title":"Vector Database System","text":"<p>The vector database manages vulnerability knowledge and enables semantic search:</p>"},{"location":"documentation/architecture/#architecture_2","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    VectorDB     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Query Interface\u2502\n\u2502 \u2022 Embeddings    \u2502\n\u2502 \u2022 Similarity    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    ChromaDB     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Storage       \u2502\n\u2502 \u2022 Indexing      \u2502\n\u2502 \u2022 Retrieval     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   CWE/CAPEC     \u2502    \u2502  MITRE ATT&amp;CK   \u2502    \u2502   CVE Search    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2022 Weaknesses    \u2502    \u2502 \u2022 Tactics       \u2502    \u2502 \u2022 Vulnerabilities\u2502\n\u2502 \u2022 Attack Patterns\u2502    \u2502 \u2022 Techniques    \u2502    \u2502 \u2022 Metadata      \u2502\n\u2502 \u2022 Mitigations   \u2502    \u2502 \u2022 Procedures    \u2502    \u2502 \u2022 Scoring       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/architecture/#key-features_2","title":"Key Features","text":"<ul> <li>Knowledge Integration: CWE, CAPEC, and MITRE ATT&amp;CK frameworks</li> <li>Semantic Search: Embedding-based similarity matching</li> <li>Multiple Providers: Support for various embedding providers</li> <li>CVE Integration: Real-time vulnerability data retrieval</li> <li>Pattern Matching: Vulnerability pattern recognition and correlation</li> </ul>"},{"location":"documentation/architecture/#data-flow","title":"Data Flow","text":""},{"location":"documentation/architecture/#analysis-workflow","title":"Analysis Workflow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    User     \u2502\u2500\u2500\u2500\u25ba\u2502   Agent     \u2502\u25c4\u2500\u2500\u25ba\u2502 Configuration\u2502\n\u2502   Input     \u2502    \u2502             \u2502    \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502 Code Browser\u2502\n                   \u2502   Analysis  \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Vector DB  \u2502\u25c4\u2500\u2500\u25ba\u2502   Agent     \u2502\u25c4\u2500\u2500\u25ba\u2502   Sandbox   \u2502\n\u2502  Knowledge  \u2502    \u2502 Processing  \u2502    \u2502  Execution  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502   Report    \u2502\n                   \u2502 Generation  \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"documentation/architecture/#information-flow","title":"Information Flow","text":"<ol> <li>Input Processing: User provides analysis target and configuration</li> <li>Code Analysis: CodeBrowser examines source code structure and differences</li> <li>Knowledge Retrieval: VectorDB searches for relevant vulnerability patterns</li> <li>Dynamic Analysis: Sandbox executes tests in isolated environment</li> <li>Synthesis: Agent combines static and dynamic analysis results</li> <li>Output Generation: Printer formats and presents findings</li> </ol>"},{"location":"documentation/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"documentation/architecture/#template-method-pattern","title":"Template Method Pattern","text":"<p>Used in: BaseAgent class Purpose: Define the skeleton of algorithm in superclass, let subclasses override specific steps <pre><code>class BaseAgent(ABC):\n    def run(self):  # Template method\n        self._check_settings()\n        with trace():\n            return self._execute()  # Abstract method\n\n    @abstractmethod\n    def _setup_agent(self):  # Primitive operation\n        pass\n</code></pre></p>"},{"location":"documentation/architecture/#strategy-pattern","title":"Strategy Pattern","text":"<p>Used in: Agent execution modes Purpose: Define family of algorithms, make them interchangeable - Synchronous execution (<code>run()</code>) - Streaming execution (<code>run_streamed()</code>) - Interactive execution (<code>run_interactive()</code>)</p>"},{"location":"documentation/architecture/#factory-pattern","title":"Factory Pattern","text":"<p>Used in: Tool creation and agent initialization Purpose: Create objects without specifying exact class <pre><code>def create_sandbox_tools(settings): ...\ndef create_code_browser_tools(browser): ...\ndef create_vectordb_tools(db): ...\n</code></pre></p>"},{"location":"documentation/architecture/#observer-pattern","title":"Observer Pattern","text":"<p>Used in: Streaming results and progress tracking Purpose: Define one-to-many dependency between objects - Result streaming callbacks - Progress hooks - Session tracking</p>"},{"location":"documentation/architecture/#dependency-injection","title":"Dependency Injection","text":"<p>Used in: Settings and service configuration Purpose: Provide dependencies from external source <pre><code>class BaseAgent:\n    def __init__(self, settings: PartialSettings):\n        self.settings = create_settings(settings)  # DI\n        self.code_browser = CodeBrowser(self.settings)  # DI\n</code></pre></p>"},{"location":"documentation/architecture/#extension-points","title":"Extension Points","text":""},{"location":"documentation/architecture/#custom-agents","title":"Custom Agents","text":"<p>Create new agent types by extending BaseAgent: <pre><code>class CustomAgent(BaseAgent):\n    def _setup_agent(self):\n        # Configure agent-specific tools and prompts\n        self.agent = Agent(name=\"Custom\", tools=custom_tools)\n        self.user_msg = \"Custom analysis prompt\"\n</code></pre></p>"},{"location":"documentation/architecture/#tool-integration","title":"Tool Integration","text":"<p>Add new analysis tools by implementing the tool interface: <pre><code>def custom_analysis_tool(context: str) -&gt; str:\n    \"\"\"Custom analysis functionality.\"\"\"\n    return analysis_result\n\ntools = [custom_analysis_tool] + existing_tools\n</code></pre></p>"},{"location":"documentation/architecture/#knowledge-sources","title":"Knowledge Sources","text":"<p>Extend vector database with new knowledge sources: <pre><code>class CustomKnowledgeDB(VectorDB):\n    def load_custom_data(self):\n        # Load and index custom vulnerability data\n        pass\n</code></pre></p>"},{"location":"documentation/architecture/#output-formats","title":"Output Formats","text":"<p>Add new output formats through the printer system: <pre><code>class CustomFormatter(Formatter):\n    def format_results(self, results):\n        # Custom formatting logic\n        return formatted_output\n</code></pre></p>"},{"location":"documentation/architecture/#security-considerations","title":"Security Considerations","text":""},{"location":"documentation/architecture/#isolation","title":"Isolation","text":"<ul> <li>Container Sandboxing: All dynamic analysis runs in isolated Docker containers</li> <li>Network Isolation: Containers have restricted network access</li> <li>Resource Limits: CPU, memory, and disk usage constraints</li> <li>Temporary Filesystems: Non-persistent storage for analysis artifacts</li> </ul>"},{"location":"documentation/architecture/#access-control","title":"Access Control","text":"<ul> <li>API Key Management: Secure storage and rotation of service credentials</li> <li>File System Permissions: Restricted access to host file system</li> <li>Service Authentication: Secure communication with external services</li> <li>Audit Logging: Comprehensive logging of security-relevant events</li> </ul>"},{"location":"documentation/architecture/#data-protection","title":"Data Protection","text":"<ul> <li>Sensitive Information: Automatic detection and redaction of secrets</li> <li>Encryption: At-rest and in-transit encryption for sensitive data</li> <li>Data Retention: Configurable retention policies for analysis results</li> <li>Privacy Compliance: GDPR and other privacy regulation considerations</li> </ul>"},{"location":"documentation/architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"documentation/architecture/#scalability","title":"Scalability","text":"<ul> <li>Horizontal Scaling: Multiple agent instances can run in parallel</li> <li>Vertical Scaling: Resource allocation per analysis session</li> <li>Caching: Vector database and code analysis result caching</li> <li>Streaming: Real-time result delivery for long-running analyses</li> </ul>"},{"location":"documentation/architecture/#resource-management","title":"Resource Management","text":"<ul> <li>Memory Usage: Configurable memory limits for containers and processes</li> <li>CPU Utilization: Multi-core processing where applicable</li> <li>Storage: Efficient cleanup of temporary analysis artifacts</li> <li>Network: Bandwidth management for external service calls</li> </ul>"},{"location":"documentation/architecture/#related-topics","title":"Related Topics","text":"<ul> <li>Installation Guide - Setup and configuration</li> <li>Configuration Guide - Settings and customization</li> <li>Usage Guide - Operational workflows</li> <li>API Reference - Detailed class documentation</li> </ul>"},{"location":"documentation/architecture/#next-steps","title":"Next Steps","text":"<ol> <li>Installation: Follow the Installation Guide to set up IVEXES</li> <li>Configuration: Review Configuration Guide for customization options</li> <li>Development: See Development Guide for extending the system</li> <li>Examples: Explore Examples Guide for practical use cases</li> </ol>"},{"location":"documentation/configuration/","title":"Configuration Guide","text":""},{"location":"documentation/configuration/#overview","title":"Overview","text":"<p>IVEXES provides a comprehensive configuration system built on Pydantic that manages all application settings through environment variables and programmatic overrides. The configuration system is designed for flexibility, validation, and ease of use across different deployment scenarios.</p> <p>All configuration is centralized in the <code>Settings</code> class, which validates inputs and provides sensible defaults. You can customize behavior through environment variables, <code>.env</code> files, or programmatic configuration using <code>PartialSettings</code>.</p>"},{"location":"documentation/configuration/#configuration-architecture","title":"Configuration Architecture","text":""},{"location":"documentation/configuration/#settings-hierarchy","title":"Settings Hierarchy","text":"<p>IVEXES uses a layered configuration approach:</p> <ol> <li>Default Values: Built-in defaults for all settings</li> <li>Environment Variables: Override defaults via environment variables</li> <li>Partial Settings: Programmatic overrides for specific use cases</li> <li>Validation: All values validated on load with clear error messages</li> </ol>"},{"location":"documentation/configuration/#configuration-categories","title":"Configuration Categories","text":"<p>The configuration system is organized into logical groups:</p> <ul> <li>API Settings: Keys and endpoints for external services</li> <li>Agent Settings: LLM model configuration and behavior</li> <li>Logging Settings: Log levels and tracing configuration</li> <li>Sandbox Settings: Container and environment configuration</li> <li>Codebase Settings: Source code analysis paths</li> <li>Embedding Settings: Vector database and embedding configuration</li> </ul>"},{"location":"documentation/configuration/#core-configuration","title":"Core Configuration","text":""},{"location":"documentation/configuration/#required-settings","title":"Required Settings","text":"<p>These settings must be configured for IVEXES to function:</p>"},{"location":"documentation/configuration/#api-keys","title":"API Keys","text":"<pre><code># Primary API key for LLM services\nexport LLM_API_KEY=\"sk-your-api-key-here\"\n\n# Alternative: OpenAI specific key (falls back to LLM_API_KEY)\nexport OPENAI_API_KEY=\"sk-your-openai-key-here\"\n</code></pre>"},{"location":"documentation/configuration/#llm-configuration","title":"LLM Configuration","text":"<pre><code># LLM service endpoint\nexport LLM_BASE_URL=\"https://api.openai.com/v1\"\n\n# Primary model for analysis\nexport MODEL=\"openai/gpt-4o-mini\"\n\n# Reasoning model for complex tasks\nexport REASONING_MODEL=\"openai/o1-mini\"\n</code></pre>"},{"location":"documentation/configuration/#agent-configuration","title":"Agent Configuration","text":"<p>Control AI agent behavior and performance:</p> <pre><code># Model creativity (0.0-2.0)\nexport MODEL_TEMPERATURE=\"0.3\"\n\n# Maximum conversation turns\nexport MAX_TURNS=\"10\"\n\n# Maximum retry attempts\nexport MAX_REPROMPTS=\"5\"\n\n# Session database location\nexport SESSION_DB_PATH=\"./sessions.sqlite\"\n</code></pre>"},{"location":"documentation/configuration/#logging-and-tracing","title":"Logging and Tracing","text":"<p>Configure logging and observability:</p> <pre><code># Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\nexport LOG_LEVEL=\"INFO\"\n\n# OpenAI tracing identifier\nexport TRACE_NAME=\"ivexes\"\n</code></pre>"},{"location":"documentation/configuration/#sandbox-configuration","title":"Sandbox Configuration","text":"<p>Configure the execution environment:</p> <pre><code># Docker image for sandbox\nexport SANDBOX_IMAGE=\"kali-ssh:latest\"\n\n# Archive to extract in sandbox (optional)\nexport SETUP_ARCHIVE=\"/path/to/setup.tar.gz\"\n</code></pre>"},{"location":"documentation/configuration/#codebase-analysis","title":"Codebase Analysis","text":"<p>Configure paths for code analysis:</p> <pre><code># Root directory containing code versions\nexport CODEBASE_PATH=\"/path/to/project\"\n\n# Vulnerable version folder name\nexport VULNERABLE_CODEBASE_FOLDER=\"vulnerable\"\n\n# Patched version folder name\nexport PATCHED_CODEBASE_FOLDER=\"patched\"\n</code></pre>"},{"location":"documentation/configuration/#vector-database","title":"Vector Database","text":"<p>Configure knowledge base and embeddings:</p> <pre><code># ChromaDB storage path\nexport CHROMA_PATH=\"/tmp/ivexes/chromadb\"\n\n# Embedding provider (builtin, local, openai)\nexport EMBEDDING_PROVIDER=\"builtin\"\n\n# Embedding model\nexport EMBEDDING_MODEL=\"builtin\"\n</code></pre>"},{"location":"documentation/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"documentation/configuration/#environment-files","title":"Environment Files","text":"<p>Create configuration files for different environments:</p>"},{"location":"documentation/configuration/#env-development","title":"<code>.env</code> (Development)","text":"<pre><code># Development configuration\nLLM_API_KEY=sk-dev-key-here\nLLM_BASE_URL=http://localhost:4000/v1\nMODEL=openai/gpt-4o-mini\nMODEL_TEMPERATURE=0.3\nLOG_LEVEL=DEBUG\nTRACE_NAME=ivexes-dev\n\n# Local development paths\nCODEBASE_PATH=/home/user/projects/analysis\nVULNERABLE_CODEBASE_FOLDER=vulnerable\nPATCHED_CODEBASE_FOLDER=fixed\n\n# Local ChromaDB\nCHROMA_PATH=/tmp/ivexes-dev/chromadb\nEMBEDDING_PROVIDER=builtin\n</code></pre>"},{"location":"documentation/configuration/#secretsenv-production","title":"<code>.secrets.env</code> (Production)","text":"<pre><code># Production secrets (never commit to version control)\nLLM_API_KEY=sk-prod-key-secure\nOPENAI_API_KEY=sk-openai-prod-key\n</code></pre>"},{"location":"documentation/configuration/#dockerenv-container-deployment","title":"<code>docker.env</code> (Container Deployment)","text":"<pre><code># Container-optimized configuration\nLLM_BASE_URL=http://litellm:4000/v1\nSANDBOX_IMAGE=kali-ssh:latest\nCHROMA_PATH=/data/chromadb\nSESSION_DB_PATH=/data/sessions.sqlite\nLOG_LEVEL=INFO\n</code></pre>"},{"location":"documentation/configuration/#programmatic-configuration","title":"Programmatic Configuration","text":""},{"location":"documentation/configuration/#using-partialsettings","title":"Using PartialSettings","text":"<p>Override specific settings programmatically:</p> <pre><code>from ivexes.config import PartialSettings, create_settings\n\n# Basic configuration override\nsettings = create_settings(\n    PartialSettings(\n        model='openai/gpt-4',\n        model_temperature=0.1,\n        max_turns=20,\n        log_level='DEBUG'\n    )\n)\n\n# Agent-specific configuration\nanalysis_settings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    reasoning_model='openai/o1-mini',\n    codebase_path='/project/analysis',\n    vulnerable_folder='v1.0-vulnerable',\n    patched_folder='v1.1-fixed',\n    max_turns=15\n)\n\n# Create settings with validation\nsettings = create_settings(analysis_settings)\n</code></pre>"},{"location":"documentation/configuration/#agent-configuration-patterns","title":"Agent Configuration Patterns","text":""},{"location":"documentation/configuration/#singleagent-configuration","title":"SingleAgent Configuration","text":"<pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    codebase_path='/analysis/target',\n    vulnerable_folder='before',\n    patched_folder='after',\n    max_turns=15,\n    model_temperature=0.2\n)\n\nagent = SingleAgent(\n    bin_path='/sandbox/target_binary',\n    settings=settings\n)\n</code></pre>"},{"location":"documentation/configuration/#multiagent-configuration","title":"MultiAgent Configuration","text":"<pre><code>from ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings\n\n# High-performance multi-agent setup\nsettings = PartialSettings(\n    model='openai/gpt-4',\n    reasoning_model='openai/o1-mini',\n    model_temperature=0.1,\n    max_turns=25,\n    codebase_path='/large-project',\n    vulnerable_folder='v2.0',\n    patched_folder='v2.1',\n    log_level='INFO'\n)\n\nmulti_agent = MultiAgent(settings=settings)\n</code></pre>"},{"location":"documentation/configuration/#validation-and-error-handling","title":"Validation and Error Handling","text":""},{"location":"documentation/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>The settings system provides comprehensive validation:</p> <pre><code>from ivexes.config import create_settings, PartialSettings\n\ntry:\n    settings = create_settings(\n        PartialSettings(\n            model_temperature=3.0,  # Invalid: &gt; 2.0\n            max_turns=-1,           # Invalid: negative\n            log_level='INVALID'     # Invalid: not a valid level\n        )\n    )\nexcept RuntimeError as e:\n    print(\"Configuration validation failed:\")\n    print(e)\n    # Output:\n    # Configuration validation failed:\n    #   - model_temperature: Temperature must be between 0.0 and 2.0\n    #   - max_turns: Max turns must be a positive integer\n    #   - log_level: Log level must be one of: DEBUG, INFO, WARNING, ERROR, CRITICAL\n</code></pre>"},{"location":"documentation/configuration/#validation-rules","title":"Validation Rules","text":""},{"location":"documentation/configuration/#api-keys_1","title":"API Keys","text":"<ul> <li>Must not be empty or whitespace-only</li> <li>Validated when <code>llm_api_key</code> is accessed</li> </ul>"},{"location":"documentation/configuration/#model-temperature","title":"Model Temperature","text":"<ul> <li>Must be between 0.0 and 2.0</li> <li>Controls randomness in model outputs</li> </ul>"},{"location":"documentation/configuration/#max-turns","title":"Max Turns","text":"<ul> <li>Must be a positive integer</li> <li>Prevents infinite conversation loops</li> </ul>"},{"location":"documentation/configuration/#log-level","title":"Log Level","text":"<ul> <li>Must be one of: DEBUG, INFO, WARNING, ERROR, CRITICAL</li> <li>Case-insensitive input, normalized to uppercase</li> </ul>"},{"location":"documentation/configuration/#base-url","title":"Base URL","text":"<ul> <li>Must start with <code>http://</code> or <code>https://</code></li> <li>Validates LLM endpoint format</li> </ul>"},{"location":"documentation/configuration/#embedding-provider","title":"Embedding Provider","text":"<ul> <li>Must be one of: <code>builtin</code>, <code>local</code>, <code>openai</code></li> <li>Determines vector database integration method</li> </ul>"},{"location":"documentation/configuration/#advanced-configuration-patterns","title":"Advanced Configuration Patterns","text":""},{"location":"documentation/configuration/#multi-environment-setup","title":"Multi-Environment Setup","text":"<pre><code>import os\nfrom ivexes.config import create_settings, PartialSettings\n\ndef get_settings_for_environment():\n    \"\"\"Get settings based on deployment environment.\"\"\"\n    env = os.environ.get('DEPLOYMENT_ENV', 'development')\n\n    base_settings = PartialSettings(\n        trace_name=f'ivexes-{env}',\n        log_level='DEBUG' if env == 'development' else 'INFO'\n    )\n\n    if env == 'production':\n        base_settings.update({\n            'model': 'openai/gpt-4',\n            'model_temperature': 0.1,\n            'max_turns': 20\n        })\n    elif env == 'development':\n        base_settings.update({\n            'model': 'openai/gpt-4o-mini',\n            'model_temperature': 0.3,\n            'max_turns': 10\n        })\n\n    return create_settings(base_settings)\n</code></pre>"},{"location":"documentation/configuration/#performance-optimization","title":"Performance Optimization","text":"<pre><code># High-performance configuration\nperformance_settings = PartialSettings(\n    model='openai/gpt-4o-mini',      # Faster model\n    model_temperature=0.1,            # More deterministic\n    max_turns=5,                      # Limit conversation length\n    log_level='WARNING',              # Reduce log noise\n    embedding_provider='builtin'      # Fastest embedding option\n)\n\n# Resource-conscious configuration\nresource_settings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    max_turns=3,\n    chroma_path='/tmp/small-chromadb',\n    embedding_provider='builtin'\n)\n</code></pre>"},{"location":"documentation/configuration/#security-focused-configuration","title":"Security-Focused Configuration","text":"<pre><code># Security analysis optimized settings\nsecurity_settings = PartialSettings(\n    model='openai/gpt-4',              # Most capable model\n    reasoning_model='openai/o1-mini',   # Advanced reasoning\n    model_temperature=0.0,              # Deterministic output\n    max_turns=30,                       # Allow thorough analysis\n    log_level='DEBUG',                  # Detailed logging\n    trace_name='security-audit'        # Specific tracing\n)\n</code></pre>"},{"location":"documentation/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"documentation/configuration/#security-considerations","title":"Security Considerations","text":"<ol> <li>API Key Management:</li> <li>Never commit API keys to version control</li> <li>Use <code>.secrets.env</code> files with proper permissions</li> <li>Rotate keys regularly</li> <li> <p>Use different keys for different environments</p> </li> <li> <p>Path Security:</p> </li> <li>Use absolute paths for codebase analysis</li> <li>Validate path accessibility before analysis</li> <li> <p>Avoid world-writable directories for data storage</p> </li> <li> <p>Container Security:</p> </li> <li>Use specific image tags, not <code>latest</code></li> <li>Regularly update sandbox images</li> <li>Limit container capabilities</li> </ol>"},{"location":"documentation/configuration/#performance-optimization_1","title":"Performance Optimization","text":"<ol> <li>Model Selection:</li> <li>Use <code>gpt-4o-mini</code> for development and light analysis</li> <li>Use <code>gpt-4</code> for production and complex analysis</li> <li> <p>Enable reasoning models for complex vulnerability analysis</p> </li> <li> <p>Resource Management:</p> </li> <li>Set appropriate <code>max_turns</code> to prevent runaway conversations</li> <li>Use local embedding providers when possible</li> <li> <p>Monitor ChromaDB storage growth</p> </li> <li> <p>Logging Configuration:</p> </li> <li>Use <code>INFO</code> or <code>WARNING</code> in production</li> <li>Use <code>DEBUG</code> only for troubleshooting</li> <li>Configure log rotation for long-running services</li> </ol>"},{"location":"documentation/configuration/#development-workflow","title":"Development Workflow","text":"<ol> <li>Environment Separation:</li> <li>Use different configuration files for each environment</li> <li>Validate configuration in CI/CD pipelines</li> <li> <p>Test configuration changes in development first</p> </li> <li> <p>Configuration Validation:</p> </li> <li>Always use <code>create_settings()</code> for validation</li> <li>Handle <code>RuntimeError</code> exceptions for invalid configuration</li> <li> <p>Provide clear error messages for configuration issues</p> </li> <li> <p>Testing:</p> </li> <li>Test with minimal viable configuration</li> <li>Validate all environment variable combinations</li> <li>Test configuration error scenarios</li> </ol>"},{"location":"documentation/configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"documentation/configuration/#common-configuration-issues","title":"Common Configuration Issues","text":""},{"location":"documentation/configuration/#api-key-problems","title":"API Key Problems","text":"<pre><code># Error: API key cannot be empty\n# Solution: Set your API key\nexport LLM_API_KEY=\"sk-your-key-here\"\n\n# Error: Invalid API key format\n# Solution: Verify key format and permissions\ncurl -H \"Authorization: Bearer $LLM_API_KEY\" \\\n     https://api.openai.com/v1/models\n</code></pre>"},{"location":"documentation/configuration/#model-configuration-issues","title":"Model Configuration Issues","text":"<pre><code># Error: Model not found\n# Solution: Check model name and availability\nexport MODEL=\"openai/gpt-4o-mini\"  # Not \"gpt-4o-mini\"\n\n# Error: Temperature validation failed\n# Solution: Use value between 0.0 and 2.0\nexport MODEL_TEMPERATURE=\"0.3\"  # Not \"3.0\"\n</code></pre>"},{"location":"documentation/configuration/#path-configuration-issues","title":"Path Configuration Issues","text":"<pre><code># Error: Codebase path validation\nsettings = PartialSettings(\n    codebase_path='/nonexistent/path',  # Will fail if path doesn't exist\n    vulnerable_folder='vuln',\n    patched_folder='patched'\n)\n\n# Solution: Verify paths exist\nimport os\ncodebase_path = '/path/to/project'\nif not os.path.exists(codebase_path):\n    raise ValueError(f\"Codebase path does not exist: {codebase_path}\")\n</code></pre>"},{"location":"documentation/configuration/#chromadb-issues","title":"ChromaDB Issues","text":"<pre><code># Error: Permission denied writing to ChromaDB\n# Solution: Ensure directory is writable\nmkdir -p /tmp/ivexes/chromadb\nchmod 755 /tmp/ivexes/chromadb\nexport CHROMA_PATH=\"/tmp/ivexes/chromadb\"\n</code></pre>"},{"location":"documentation/configuration/#configuration-validation_1","title":"Configuration Validation","text":"<pre><code>from ivexes.config import create_settings, PartialSettings\n\ndef validate_configuration():\n    \"\"\"Validate current configuration and report issues.\"\"\"\n    try:\n        settings = create_settings()\n        print(\"\u2705 Configuration valid\")\n        print(f\"Model: {settings.model}\")\n        print(f\"Base URL: {settings.llm_base_url}\")\n        print(f\"Log Level: {settings.log_level}\")\n\n        # Test API connectivity\n        if settings.llm_api_key:\n            print(\"\u2705 API key configured\")\n        else:\n            print(\"\u274c API key missing\")\n\n    except RuntimeError as e:\n        print(\"\u274c Configuration validation failed:\")\n        print(e)\n        return False\n\n    return True\n\n# Run validation\nif __name__ == \"__main__\":\n    validate_configuration()\n</code></pre>"},{"location":"documentation/configuration/#related-topics","title":"Related Topics","text":"<ul> <li>Installation Guide - Setting up the development environment</li> <li>Usage Guide - Core workflows and agent execution modes</li> <li>Configuration API - Detailed API reference for configuration classes</li> <li>Development Guide - Development setup and contributing guidelines</li> </ul>"},{"location":"documentation/configuration/#next-steps","title":"Next Steps","text":"<p>After configuring IVEXES:</p> <ol> <li>Verify Installation: Run configuration validation to ensure all settings are correct</li> <li>Test Basic Functionality: Create a simple agent with your configuration</li> <li>Explore Usage Patterns: Review the Usage Guide for common workflows</li> <li>Review API Documentation: Detailed reference in Configuration API</li> <li>Set Up Development Environment: Follow Development Guide for contributing</li> </ol>"},{"location":"documentation/development/","title":"Development Guide","text":""},{"location":"documentation/development/#overview","title":"Overview","text":"<p>This guide provides comprehensive information for developers who want to contribute to IVEXES or extend the system with custom functionality. It covers development setup, coding standards, testing guidelines, and best practices for creating custom agents and tools.</p>"},{"location":"documentation/development/#development-setup","title":"Development Setup","text":""},{"location":"documentation/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher</li> <li>Docker and Docker Compose</li> <li>Git for version control</li> <li>uv package manager (recommended) or pip</li> </ul>"},{"location":"documentation/development/#environment-setup","title":"Environment Setup","text":"<ol> <li> <p>Clone the Repository <pre><code>git clone https://github.com/LetsDrinkSomeTea/ivexes.git\ncd ivexes\n</code></pre></p> </li> <li> <p>Install Development Dependencies <pre><code># Using uv (recommended)\nuv sync --all-extras --all-packages --group dev\n\n# Or using make\nmake sync\n\n# Or using pip (legacy)\npip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Setup Container Images <pre><code># Build all required Docker images\nmake build-images\n\n# Or manually\ndocker compose --profile images build\n</code></pre></p> </li> <li> <p>Start LiteLLM Proxy <pre><code># Start background services\nmake run-litellm\n\n# Or manually\ndocker compose up -d\n</code></pre></p> </li> <li> <p>Complete Setup (All-in-One) <pre><code># Combines all setup steps\nmake setup\n</code></pre></p> </li> </ol>"},{"location":"documentation/development/#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env</code> file for development settings:</p> <pre><code># LLM Configuration\nLLM_API_KEY=your_api_key_here\nLLM_BASE_URL=http://localhost:4000\nMODEL=openai/gpt-4o-mini\nREASONING_MODEL=openai/o4-mini\nTEMPERATURE=0.3\n\n# Development Settings\nLOG_LEVEL=DEBUG\nTRACE_NAME=ivexes-dev\n\n# Embedding Configuration\nEMBEDDING_PROVIDER=local\nEMBEDDING_MODEL=intfloat/multilingual-e5-large-instruct\nCHROMA_PATH=/tmp/ivexes/chromadb\n\n# Development Paths\nCODEBASE_PATH=/path/to/test/codebase\nVULNERABLE_CODEBASE_FOLDER=vulnerable-version\nPATCHED_CODEBASE_FOLDER=patched-version\n</code></pre> <p>Create a <code>.secrets.env</code> file for sensitive data (never commit this):</p> <pre><code># API Keys\nOPENAI_API_KEY=sk-your-openai-key\nANTHROPIC_API_KEY=your-anthropic-key\n\n# Database Credentials\nDATABASE_URL=postgresql://user:pass@localhost:5432/ivexes\n</code></pre>"},{"location":"documentation/development/#code-standards-and-style","title":"Code Standards and Style","text":""},{"location":"documentation/development/#code-formatting","title":"Code Formatting","text":"<p>IVEXES uses Ruff for code formatting and linting with Google-style docstrings.</p> <pre><code># Format code\nmake format\n# Or manually:\nuv run ruff format\nuv run ruff check --fix\n\n# Check formatting without changes\nmake format-check\n# Or manually:\nuv run ruff format --check\n\n# Run linter only\nmake lint\n# Or manually:\nuv run ruff check\n</code></pre>"},{"location":"documentation/development/#code-style-guidelines","title":"Code Style Guidelines","text":"<ol> <li> <p>Docstring Convention: Use Google-style docstrings    <pre><code>def analyze_vulnerability(cve_id: str, severity: str) -&gt; Dict[str, Any]:\n    \"\"\"Analyze vulnerability details and impact.\n\n    Args:\n        cve_id: CVE identifier (e.g., 'CVE-2021-44228')\n        severity: Vulnerability severity level\n\n    Returns:\n        Dictionary containing analysis results with keys:\n        - 'impact': Impact assessment\n        - 'exploitability': Exploitability score\n        - 'recommendations': Mitigation recommendations\n\n    Raises:\n        ValueError: If CVE ID format is invalid\n        NetworkError: If CVE database is unreachable\n    \"\"\"\n</code></pre></p> </li> <li> <p>Type Annotations: Use comprehensive type hints    <pre><code>from typing import Optional, Dict, List, Any, Union\n\nclass VulnerabilityAnalyzer:\n    def __init__(self, settings: PartialSettings) -&gt; None:\n        self.settings: Settings = create_settings(settings)\n        self.results: List[Dict[str, Any]] = []\n</code></pre></p> </li> <li> <p>Error Handling: Use specific exceptions with clear messages    <pre><code>from ivexes.exceptions import IvexesError, ConfigurationError\n\ndef validate_config(settings: Settings) -&gt; None:\n    \"\"\"Validate configuration settings.\"\"\"\n    if not settings.llm_api_key:\n        raise ConfigurationError(\n            \"LLM_API_KEY is required but not provided. \"\n            \"Set it in environment variables or .secrets.env file.\"\n        )\n</code></pre></p> </li> <li> <p>Import Organization: Follow PEP 8 import ordering    <pre><code># Standard library imports\nimport asyncio\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Third-party imports\nfrom agents import Agent, tool\nfrom pydantic import BaseModel\n\n# Local application imports\nfrom ..config import PartialSettings, Settings\nfrom ..exceptions import IvexesError\nfrom .base import BaseAgent\n</code></pre></p> </li> </ol>"},{"location":"documentation/development/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>IVEXES uses pre-commit hooks to enforce code quality:</p> <pre><code># Install pre-commit hooks\nuv run pre-commit install\n\n# Run hooks manually\nuv run pre-commit run --all-files\n</code></pre> <p>The pre-commit configuration includes: - Ruff formatting and linting - Trailing whitespace removal - End-of-file fixing - Large file detection</p>"},{"location":"documentation/development/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"documentation/development/#test-structure","title":"Test Structure","text":"<p>Tests are organized in the <code>tests/cases/</code> directory using Python's unittest framework:</p> <pre><code>tests/\n\u251c\u2500\u2500 cases/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_config.py       # Configuration testing\n\u2502   \u251c\u2500\u2500 test_container.py    # Container utilities testing\n\u2502   \u251c\u2500\u2500 test_downloader.py   # Data downloader testing\n\u2502   \u251c\u2500\u2500 test_embed.py        # Embedding functionality testing\n\u2502   \u251c\u2500\u2500 test_parser.py       # Parser testing\n\u2502   \u2514\u2500\u2500 test_sandbox.py      # Sandbox testing\n\u2514\u2500\u2500 run_tests.py             # Test runner\n</code></pre>"},{"location":"documentation/development/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nmake tests\n\n# Or manually\nuv run python -m unittest discover -s tests -v\n\n# Run specific test file\nuv run python -m unittest tests.cases.test_config -v\n\n# Run with legacy test runner\nuv run python tests/run_tests.py\n</code></pre>"},{"location":"documentation/development/#writing-tests","title":"Writing Tests","text":"<ol> <li> <p>Test Class Structure <pre><code>\"\"\"Test module for configuration functionality.\"\"\"\n\nimport unittest\nimport tempfile\nfrom pathlib import Path\n\nfrom ivexes.config import Settings, PartialSettings, create_settings\n\nclass TestConfiguration(unittest.TestCase):\n    \"\"\"Test cases for configuration management.\"\"\"\n\n    def setUp(self) -&gt; None:\n        \"\"\"Set up test fixtures.\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.settings = PartialSettings(\n            model='test/model',\n            temperature=0.5\n        )\n\n    def tearDown(self) -&gt; None:\n        \"\"\"Clean up test fixtures.\"\"\"\n        # Cleanup code here\n        pass\n\n    def test_settings_creation(self) -&gt; None:\n        \"\"\"Test settings object creation.\"\"\"\n        settings = create_settings(self.settings)\n        self.assertEqual(settings.model, 'test/model')\n        self.assertEqual(settings.temperature, 0.5)\n\n    def test_invalid_temperature(self) -&gt; None:\n        \"\"\"Test validation of invalid temperature values.\"\"\"\n        with self.assertRaises(ValueError):\n            create_settings(PartialSettings(temperature=5.0))\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre></p> </li> <li> <p>Async Test Support <pre><code>import asyncio\nimport unittest\n\nclass TestAsyncAgent(unittest.TestCase):\n    \"\"\"Test cases for async agent functionality.\"\"\"\n\n    def setUp(self) -&gt; None:\n        \"\"\"Set up async test environment.\"\"\"\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n    def tearDown(self) -&gt; None:\n        \"\"\"Clean up async test environment.\"\"\"\n        self.loop.close()\n\n    def test_async_agent_run(self) -&gt; None:\n        \"\"\"Test async agent execution.\"\"\"\n        async def run_test():\n            agent = TestAgent()\n            result = await agent.run()\n            self.assertIsNotNone(result)\n\n        self.loop.run_until_complete(run_test())\n</code></pre></p> </li> <li> <p>Mock External Dependencies <pre><code>import unittest\nfrom unittest.mock import Mock, patch\n\nclass TestExternalIntegration(unittest.TestCase):\n    \"\"\"Test external service integration.\"\"\"\n\n    @patch('ivexes.vector_db.ChromaDB')\n    def test_vector_db_integration(self, mock_chroma):\n        \"\"\"Test vector database integration with mocked ChromaDB.\"\"\"\n        mock_collection = Mock()\n        mock_chroma.return_value.get_or_create_collection.return_value = mock_collection\n\n        # Test your integration\n        from ivexes.vector_db import VectorDB\n        db = VectorDB()\n        db.query('test query')\n\n        mock_collection.query.assert_called_once()\n</code></pre></p> </li> </ol>"},{"location":"documentation/development/#test-quality-standards","title":"Test Quality Standards","text":"<ul> <li>Coverage: Aim for &gt;80% code coverage</li> <li>Isolation: Each test should be independent</li> <li>Clarity: Test names should clearly describe what is being tested</li> <li>Speed: Unit tests should run quickly (&lt;1s per test)</li> <li>Reliability: Tests should be deterministic and not flaky</li> </ul>"},{"location":"documentation/development/#creating-custom-agents","title":"Creating Custom Agents","text":""},{"location":"documentation/development/#agent-architecture","title":"Agent Architecture","text":"<p>All agents inherit from <code>BaseAgent</code> which provides common functionality:</p> <pre><code>\"\"\"Custom agent implementation example.\"\"\"\n\nfrom typing import Optional, List\nfrom agents import Agent, tool\n\nfrom ivexes.agents.base import BaseAgent\nfrom ivexes.config import PartialSettings\nfrom ivexes.sandbox.tools import create_sandbox_tools\nfrom ivexes.vector_db import create_vectordb_tools\n\nclass CustomSecurityAgent(BaseAgent):\n    \"\"\"Custom agent for specialized security analysis.\"\"\"\n\n    def __init__(self, target: str, settings: Optional[PartialSettings] = None):\n        \"\"\"Initialize custom security agent.\n\n        Args:\n            target: Target system or application to analyze\n            settings: Optional configuration settings\n        \"\"\"\n        self.target = target\n        super().__init__(settings or {})\n\n    def _setup_agent(self) -&gt; None:\n        \"\"\"Set up the custom agent with specialized tools and prompts.\"\"\"\n        # Create custom system message\n        self.system_msg = f\"\"\"\n        You are a specialized security analyst focused on {self.target}.\n\n        Your capabilities include:\n        - Static code analysis\n        - Dynamic behavior analysis  \n        - Vulnerability assessment\n        - Exploit development\n        - Security recommendations\n\n        Use the available tools systematically to conduct thorough analysis.\n        \"\"\"\n\n        # Set up tools\n        tools = self._create_tools()\n\n        # Create agent with specialized configuration\n        self.agent = Agent(\n            model=self.settings.model,\n            tools=tools,\n            system_message=self.system_msg,\n            max_turns=self.settings.max_turns,\n            temperature=self.settings.temperature\n        )\n\n        # Set initial user message\n        self.user_msg = f\"Analyze {self.target} for security vulnerabilities.\"\n\n    def _create_tools(self) -&gt; List:\n        \"\"\"Create specialized tool set for this agent.\"\"\"\n        tools = []\n\n        # Add standard tools\n        if self.settings.enable_sandbox:\n            tools.extend(create_sandbox_tools(self.settings))\n\n        if self.settings.enable_vector_db:\n            tools.extend(create_vectordb_tools(self.settings))\n\n        # Add custom tools\n        tools.extend(self._create_custom_tools())\n\n        return tools\n\n    def _create_custom_tools(self) -&gt; List:\n        \"\"\"Create custom tools specific to this agent.\"\"\"\n        @tool\n        def custom_security_scan(target_path: str) -&gt; dict:\n            \"\"\"Run custom security scan on target.\n\n            Args:\n                target_path: Path to scan for security issues\n\n            Returns:\n                Dictionary with scan results\n            \"\"\"\n            # Implementation of custom security scanning logic\n            return {\n                'target': target_path,\n                'vulnerabilities': [],\n                'recommendations': []\n            }\n\n        @tool\n        def generate_exploit_template(vulnerability_type: str) -&gt; str:\n            \"\"\"Generate exploit template for vulnerability type.\n\n            Args:\n                vulnerability_type: Type of vulnerability (e.g., 'buffer_overflow')\n\n            Returns:\n                Exploit template code\n            \"\"\"\n            templates = {\n                'buffer_overflow': '''\n                # Buffer Overflow Exploit Template\n                import struct\n\n                def create_payload():\n                    buffer = b\"A\" * 100  # Adjust buffer size\n                    return buffer\n                ''',\n                'sql_injection': '''\n                # SQL Injection Exploit Template\n                payload = \"' OR '1'='1' --\"\n                '''\n            }\n\n            return templates.get(vulnerability_type, \"# No template available\")\n\n        return [custom_security_scan, generate_exploit_template]\n\n# Usage example\nasync def main():\n    \"\"\"Example usage of custom agent.\"\"\"\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=20,\n        enable_sandbox=True,\n        enable_vector_db=True\n    )\n\n    agent = CustomSecurityAgent(\n        target='web-application',\n        settings=settings\n    )\n\n    await agent.run_interactive()\n\nif __name__ == '__main__':\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"documentation/development/#agent-best-practices","title":"Agent Best Practices","text":"<ol> <li>Clear Responsibility: Each agent should have a well-defined purpose</li> <li>Tool Selection: Choose appropriate tools for the agent's domain</li> <li>Error Handling: Implement robust error handling and recovery</li> <li>Documentation: Provide comprehensive docstrings and examples</li> <li>Testing: Write unit tests for custom agent functionality</li> </ol>"},{"location":"documentation/development/#creating-custom-tools","title":"Creating Custom Tools","text":""},{"location":"documentation/development/#tool-development-pattern","title":"Tool Development Pattern","text":"<pre><code>\"\"\"Custom tool implementation example.\"\"\"\n\nfrom typing import Dict, Any, List\nfrom agents import tool\nfrom pathlib import Path\n\n@tool\ndef analyze_binary_strings(binary_path: str, min_length: int = 4) -&gt; Dict[str, Any]:\n    \"\"\"Extract and analyze strings from binary file.\n\n    Args:\n        binary_path: Path to binary file to analyze\n        min_length: Minimum string length to extract\n\n    Returns:\n        Dictionary containing:\n        - 'strings': List of extracted strings\n        - 'interesting': List of potentially interesting strings\n        - 'count': Total number of strings found\n\n    Raises:\n        FileNotFoundError: If binary file doesn't exist\n        PermissionError: If binary file can't be read\n    \"\"\"\n    import re\n    import string\n\n    binary_file = Path(binary_path)\n    if not binary_file.exists():\n        raise FileNotFoundError(f\"Binary file not found: {binary_path}\")\n\n    try:\n        with open(binary_file, 'rb') as f:\n            data = f.read()\n    except PermissionError as e:\n        raise PermissionError(f\"Cannot read binary file: {e}\")\n\n    # Extract printable strings\n    printable = set(string.printable) - set('\\t\\n\\r\\x0b\\x0c')\n    strings = []\n    current_string = \"\"\n\n    for byte in data:\n        char = chr(byte)\n        if char in printable:\n            current_string += char\n        else:\n            if len(current_string) &gt;= min_length:\n                strings.append(current_string)\n            current_string = \"\"\n\n    # Add final string if it meets criteria\n    if len(current_string) &gt;= min_length:\n        strings.append(current_string)\n\n    # Identify interesting strings\n    interesting_patterns = [\n        r'password',\n        r'key',\n        r'token',\n        r'secret',\n        r'api',\n        r'config',\n        r'admin',\n        r'root',\n        r'http[s]?://',\n        r'\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b',  # IP addresses\n        r'[a-zA-Z0-9+/]{20,}={0,2}',  # Base64-like\n    ]\n\n    interesting = []\n    for string_val in strings:\n        for pattern in interesting_patterns:\n            if re.search(pattern, string_val, re.IGNORECASE):\n                interesting.append(string_val)\n                break\n\n    return {\n        'strings': strings,\n        'interesting': interesting,\n        'count': len(strings),\n        'file': str(binary_file)\n    }\n\n@tool\ndef calculate_entropy(data: str) -&gt; float:\n    \"\"\"Calculate Shannon entropy of given data.\n\n    Args:\n        data: String data to analyze\n\n    Returns:\n        Entropy value (0.0 to 8.0, higher = more random)\n    \"\"\"\n    import math\n    from collections import Counter\n\n    if not data:\n        return 0.0\n\n    # Count character frequencies\n    char_counts = Counter(data)\n    data_len = len(data)\n\n    # Calculate entropy\n    entropy = 0.0\n    for count in char_counts.values():\n        probability = count / data_len\n        if probability &gt; 0:\n            entropy -= probability * math.log2(probability)\n\n    return entropy\n\n# Tool integration example\ndef create_binary_analysis_tools() -&gt; List:\n    \"\"\"Create tools for binary analysis.\"\"\"\n    return [\n        analyze_binary_strings,\n        calculate_entropy,\n    ]\n</code></pre>"},{"location":"documentation/development/#tool-guidelines","title":"Tool Guidelines","text":"<ol> <li>Single Responsibility: Each tool should do one thing well</li> <li>Clear Interface: Use descriptive names and comprehensive docstrings</li> <li>Error Handling: Handle expected errors gracefully</li> <li>Type Safety: Use type hints for all parameters and return values</li> <li>Testing: Write unit tests for tool functionality</li> </ol>"},{"location":"documentation/development/#contributing-workflow","title":"Contributing Workflow","text":""},{"location":"documentation/development/#git-workflow","title":"Git Workflow","text":"<ol> <li> <p>Fork and Clone <pre><code># Fork repository on GitHub, then:\ngit clone https://github.com/yourusername/ivexes.git\ncd ivexes\ngit remote add upstream https://github.com/LetsDrinkSomeTea/ivexes.git\n</code></pre></p> </li> <li> <p>Create Feature Branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Development Cycle <pre><code># Make changes\ngit add .\ngit commit -m \"feat: add new vulnerability detection capability\"\n\n# Run quality checks\nmake check  # format-check + lint + tests\n\n# Push changes\ngit push origin feature/your-feature-name\n</code></pre></p> </li> <li> <p>Pull Request Process</p> </li> <li>Create pull request on GitHub</li> <li>Ensure all CI checks pass</li> <li>Request review from maintainers</li> <li>Address feedback and update as needed</li> </ol>"},{"location":"documentation/development/#commit-message-convention","title":"Commit Message Convention","text":"<p>Use conventional commit format:</p> <pre><code>type(scope): brief description\n\nDetailed explanation if needed.\n\n- Additional details\n- Breaking changes noted with BREAKING CHANGE:\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes (formatting, etc.) - <code>refactor</code>: Code refactoring - <code>test</code>: Adding or updating tests - <code>ci</code>: CI/CD changes</p> <p>Examples: <pre><code>feat(agents): add custom vulnerability detection agent\n\nAdd specialized agent for detecting custom vulnerability patterns\nin legacy C applications.\n\n- Implements static analysis capabilities\n- Integrates with existing sandbox tools\n- Includes comprehensive test coverage\n\nfix(sandbox): resolve container cleanup issue\n\nContainers were not being properly cleaned up after analysis,\ncausing resource leaks in long-running sessions.\n\ndocs(api): update agent API documentation\n\n- Add examples for custom agent development\n- Clarify tool integration patterns\n- Fix broken cross-references\n</code></pre></p>"},{"location":"documentation/development/#code-review-guidelines","title":"Code Review Guidelines","text":"<p>For Contributors: - Write clear, self-documenting code - Include comprehensive tests - Update documentation as needed - Keep changes focused and atomic - Respond promptly to review feedback</p> <p>For Reviewers: - Check code functionality and design - Verify test coverage and quality - Ensure documentation is updated - Review security implications - Provide constructive feedback</p>"},{"location":"documentation/development/#documentation-development","title":"Documentation Development","text":""},{"location":"documentation/development/#mkdocs-setup","title":"MkDocs Setup","text":"<p>IVEXES uses MkDocs with Material theme for documentation:</p> <pre><code># Build documentation\nmake build-docs\n\n# Serve locally for development\nmake serve-docs\n\n# Deploy to GitHub Pages\nmake deploy-docs\n</code></pre>"},{"location":"documentation/development/#documentation-standards","title":"Documentation Standards","text":"<ol> <li>Structure: Follow the established template patterns</li> <li>Examples: Include working code examples</li> <li>Cross-references: Link related sections appropriately</li> <li>API Documentation: Use docstrings as the source of truth</li> <li>Clarity: Write for both beginners and experts</li> </ol>"},{"location":"documentation/development/#adding-new-documentation","title":"Adding New Documentation","text":"<ol> <li>Create new markdown files in appropriate directory</li> <li>Update <code>mkdocs.yml</code> navigation structure</li> <li>Add cross-references from related pages</li> <li>Test documentation builds without errors</li> <li>Verify all code examples work</li> </ol>"},{"location":"documentation/development/#architecture-guidelines","title":"Architecture Guidelines","text":""},{"location":"documentation/development/#design-principles","title":"Design Principles","text":"<ol> <li>Modularity: Components should be loosely coupled</li> <li>Extensibility: Easy to add new agents and tools</li> <li>Testability: Design for easy unit testing</li> <li>Security: Security-first approach to all components</li> <li>Performance: Optimize for analysis speed and accuracy</li> </ol>"},{"location":"documentation/development/#component-interaction","title":"Component Interaction","text":"<pre><code>\"\"\"Example of proper component interaction.\"\"\"\n\nfrom typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass AnalysisProvider(Protocol):\n    \"\"\"Protocol for analysis providers.\"\"\"\n\n    async def analyze(self, target: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze target and return results.\"\"\"\n        ...\n\nclass VulnerabilityAnalyzer:\n    \"\"\"Vulnerability analyzer with pluggable providers.\"\"\"\n\n    def __init__(self, providers: List[AnalysisProvider]):\n        self.providers = providers\n\n    async def comprehensive_analysis(self, target: str) -&gt; Dict[str, Any]:\n        \"\"\"Run analysis using all available providers.\"\"\"\n        results = {}\n\n        for provider in self.providers:\n            try:\n                provider_result = await provider.analyze(target)\n                results[provider.__class__.__name__] = provider_result\n            except Exception as e:\n                results[provider.__class__.__name__] = {'error': str(e)}\n\n        return results\n</code></pre>"},{"location":"documentation/development/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Async Programming: Use async/await for I/O operations</li> <li>Resource Management: Properly clean up containers and connections</li> <li>Memory Usage: Monitor memory usage in long-running analyses</li> <li>Caching: Cache expensive operations where appropriate</li> <li>Parallelization: Use concurrent execution where possible</li> </ol>"},{"location":"documentation/development/#troubleshooting-development-issues","title":"Troubleshooting Development Issues","text":""},{"location":"documentation/development/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Docker Permission Issues <pre><code># Add user to docker group\nsudo usermod -aG docker $USER\n# Log out and back in, or:\nnewgrp docker\n</code></pre></p> </li> <li> <p>LiteLLM Connection Issues <pre><code># Check container status\ndocker compose ps\n\n# View logs\ndocker compose logs litellm\n\n# Restart services\ndocker compose restart\n</code></pre></p> </li> <li> <p>Import Errors <pre><code># Ensure package is installed in development mode\nuv sync --all-extras --all-packages --group dev\n\n# Check Python path\npython -c \"import sys; print('\\n'.join(sys.path))\"\n</code></pre></p> </li> <li> <p>Test Failures <pre><code># Run specific test with verbose output\nuv run python -m unittest tests.cases.test_config.TestConfiguration.test_specific_method -v\n\n# Check test isolation\nuv run python -m unittest tests.cases.test_config -v\n</code></pre></p> </li> </ol>"},{"location":"documentation/development/#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Use Logging: Add debug logging to understand execution flow</li> <li>Test Isolation: Run tests individually to isolate issues</li> <li>Container Inspection: Use <code>docker exec</code> to inspect containers</li> <li>Environment Variables: Double-check environment configuration</li> <li>Dependencies: Verify all dependencies are correctly installed</li> </ol>"},{"location":"documentation/development/#performance-optimization","title":"Performance Optimization","text":""},{"location":"documentation/development/#profiling","title":"Profiling","text":"<pre><code>\"\"\"Performance profiling example.\"\"\"\n\nimport cProfile\nimport pstats\nfrom typing import Any\n\ndef profile_agent_execution(agent: BaseAgent, target: str) -&gt; Any:\n    \"\"\"Profile agent execution for performance analysis.\"\"\"\n\n    profiler = cProfile.Profile()\n    profiler.enable()\n\n    try:\n        result = asyncio.run(agent.run())\n    finally:\n        profiler.disable()\n\n    # Analyze results\n    stats = pstats.Stats(profiler)\n    stats.sort_stats('cumulative')\n    stats.print_stats(20)  # Top 20 functions\n\n    return result\n</code></pre>"},{"location":"documentation/development/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Tool Selection: Use appropriate tools for each task</li> <li>Parallel Execution: Run independent operations concurrently</li> <li>Resource Pooling: Reuse expensive resources like containers</li> <li>Caching: Cache results of expensive computations</li> <li>Memory Management: Monitor and optimize memory usage</li> </ol>"},{"location":"documentation/development/#related-topics","title":"Related Topics","text":"<ul> <li>Architecture Guide - System design and components</li> <li>Installation Guide - Setup and configuration</li> <li>Examples Guide - Practical usage examples</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"documentation/development/#next-steps","title":"Next Steps","text":"<ol> <li>Set up Development Environment: Follow the setup instructions</li> <li>Explore Codebase: Read existing agent implementations</li> <li>Write Tests: Practice with unit test development</li> <li>Create Custom Agent: Develop a specialized agent for your use case</li> <li>Contribute: Submit improvements and new features</li> </ol> <p>For questions or support, please create issues in the GitHub repository or reach out to the maintainers.</p>"},{"location":"documentation/examples/","title":"Examples Guide","text":""},{"location":"documentation/examples/#overview","title":"Overview","text":"<p>This guide provides practical examples and use cases for the IVEXES framework, demonstrating how to use different agents for vulnerability analysis tasks. Examples range from basic vulnerability analysis to complex multi-agent orchestration and custom agent development.</p>"},{"location":"documentation/examples/#basic-vulnerability-analysis","title":"Basic Vulnerability Analysis","text":""},{"location":"documentation/examples/#single-agent-analysis","title":"Single Agent Analysis","text":"<p>The SingleAgent provides comprehensive vulnerability analysis for binary analysis tasks with full tool integration.</p> <pre><code>\"\"\"Basic single agent vulnerability analysis.\"\"\"\n\nimport asyncio\nfrom dotenv import load_dotenv\n\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings, setup_default_logging\n\n# Load environment variables\nload_dotenv(verbose=True, override=True)\nsetup_default_logging()\n\n# Configure analysis settings\nsettings = PartialSettings(\n    trace_name='vulnerability_analysis',\n    model='openai/gpt-4o-mini',\n    model_temperature=0.1,\n    max_turns=25,\n    codebase_path='/path/to/codebase',\n    vulnerable_folder='vulnerable-version',\n    patched_folder='patched-version',\n    setup_archive='/path/to/analysis.tgz'\n)\n\n# Create and run agent\nagent = SingleAgent(\n    bin_path='/usr/bin/target_binary',\n    settings=settings\n)\n\nasync def main():\n    \"\"\"Run basic vulnerability analysis.\"\"\"\n    # Interactive mode for exploration\n    await agent.run_interactive()\n\n    # Or streaming mode for automated processing\n    async for chunk in agent.run_streamed():\n        print(chunk, end='')\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"documentation/examples/#mvp-agent-analysis","title":"MVP Agent Analysis","text":"<p>The MVPAgent provides minimal viable product implementation for quick vulnerability assessment.</p> <pre><code>\"\"\"MVP agent for rapid vulnerability analysis.\"\"\"\n\nimport asyncio\nfrom dotenv import load_dotenv\n\nfrom ivexes.agents import MVPAgent\nfrom ivexes.config import PartialSettings, setup_default_logging\n\nload_dotenv(verbose=True, override=True)\nsetup_default_logging()\n\nsettings = PartialSettings(\n    trace_name='mvp_analysis',\n    model='anthropic/claude-sonnet-4-20250514',\n    model_temperature=0.1,\n    max_turns=50,\n    embedding_model='text-embedding-3-large',\n    embedding_provider='openai',\n    setup_archive='/path/to/screen_analysis/upload.tgz'\n)\n\nagent = MVPAgent(\n    vulnerable_version='vulnerable-screen-4.5.0',\n    patched_version='patched-screen-4.5.1',\n    settings=settings\n)\n\nasync def main():\n    \"\"\"Run MVP vulnerability analysis.\"\"\"\n    result = await agent.run()\n    print(f\"Analysis completed: {result}\")\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"documentation/examples/#multi-agent-orchestration","title":"Multi-Agent Orchestration","text":""},{"location":"documentation/examples/#collaborative-analysis-team","title":"Collaborative Analysis Team","text":"<p>The MultiAgent system orchestrates specialized agents for comprehensive analysis.</p> <pre><code>\"\"\"Multi-agent collaborative vulnerability analysis.\"\"\"\n\nimport asyncio\nfrom dotenv import load_dotenv\n\nfrom ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings, setup_default_logging\n\nload_dotenv(verbose=True, override=True)\nsetup_default_logging('WARNING')  # Reduce log noise\n\nsettings = PartialSettings(\n    trace_name='Multi-Agent Analysis',\n    model='openai/gpt-4o-mini',\n    reasoning_model='openai/o4-mini',\n    model_temperature=0.1,\n    max_turns=50,\n    embedding_provider='local',\n    embedding_model='intfloat/multilingual-e5-large-instruct',\n    setup_archive='/path/to/analysis/upload.tgz',\n    codebase_path='/path/to/codebase',\n    vulnerable_folder='vulnerable-version',\n    patched_folder='patched-version'\n)\n\nagent = MultiAgent(settings=settings)\n\nasync def main():\n    \"\"\"Run multi-agent analysis with report generation.\"\"\"\n    # Generate comprehensive report\n    report, context = await agent.run_ensured_report()\n\n    print(f\"Report generated: {report}\")\n    print(f\"Analysis context: {context}\")\n\n    # Access shared context for detailed insights\n    if context.shared_memory:\n        print(f\"Findings: {context.shared_memory.findings}\")\n        print(f\"Vulnerabilities: {context.shared_memory.vulnerabilities}\")\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"documentation/examples/#specialized-agent-coordination","title":"Specialized Agent Coordination","text":"<pre><code>\"\"\"Advanced multi-agent coordination example.\"\"\"\n\nimport asyncio\nfrom ivexes.agents.multi_agent import MultiAgent, MultiAgentContext\nfrom ivexes.config import PartialSettings\n\nasync def coordinated_analysis():\n    \"\"\"Example of coordinated multi-agent analysis.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=30,\n        codebase_path='/path/to/complex_codebase',\n        vulnerable_folder='v1.0-vulnerable',\n        patched_folder='v1.1-patched'\n    )\n\n    agent = MultiAgent(settings=settings)\n\n    # Custom analysis with specific focus areas\n    context = MultiAgentContext()\n    context.focus_areas = [\n        'buffer overflow vulnerabilities',\n        'authentication bypass',\n        'privilege escalation'\n    ]\n\n    report, final_context = await agent.run_with_context(context)\n\n    # Process results by specialist\n    for specialist_type, findings in final_context.specialist_findings.items():\n        print(f\"{specialist_type} findings:\")\n        for finding in findings:\n            print(f\"  - {finding}\")\n\n    return report, final_context\n\n# Usage\nasyncio.run(coordinated_analysis())\n</code></pre>"},{"location":"documentation/examples/#htb-challenge-analysis","title":"HTB Challenge Analysis","text":""},{"location":"documentation/examples/#hack-the-box-challenge-agent","title":"Hack The Box Challenge Agent","text":"<p>The HTBChallengeAgent is specialized for analyzing Hack The Box challenges.</p> <pre><code>\"\"\"HTB Challenge analysis example.\"\"\"\n\nimport asyncio\nfrom dotenv import load_dotenv\n\nfrom ivexes.agents import HTBChallengeAgent\nfrom ivexes.config import PartialSettings, setup_default_logging\n\nload_dotenv(verbose=True, override=True)\nsetup_default_logging()\n\nsettings = PartialSettings(\n    trace_name='htb_challenge',\n    model='openai/gpt-4.1-mini',\n    model_temperature=0.1,\n    max_turns=25,\n    setup_archive='/path/to/htb_challenge/upload.tgz'\n)\n\nagent = HTBChallengeAgent(\n    program='challenge_binary',\n    challenge='Reverse engineering challenge: find the hidden flag in the binary',\n    settings=settings\n)\n\nasync def main():\n    \"\"\"Analyze HTB challenge.\"\"\"\n    # Interactive mode for step-by-step analysis\n    await agent.run_interactive()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"documentation/examples/#complex-htb-challenge","title":"Complex HTB Challenge","text":"<pre><code>\"\"\"Advanced HTB challenge with custom configuration.\"\"\"\n\nimport asyncio\nfrom ivexes.agents import HTBChallengeAgent\nfrom ivexes.config import PartialSettings\n\nasync def analyze_complex_challenge():\n    \"\"\"Analyze complex HTB challenge with advanced settings.\"\"\"\n\n    settings = PartialSettings(\n        trace_name='complex_htb',\n        model='openai/gpt-4o-mini',\n        reasoning_model='openai/o4-mini',\n        model_temperature=0.05,  # Lower temperature for precision\n        max_turns=40,\n        embedding_provider='openai',\n        embedding_model='text-embedding-3-large',\n        setup_archive='/path/to/complex_challenge.tgz'\n    )\n\n    agent = HTBChallengeAgent(\n        program='advanced_challenge',\n        challenge='''\n        Multi-stage challenge: \n        1. Reverse engineer the protection mechanism\n        2. Find the authentication bypass\n        3. Exploit the buffer overflow\n        4. Extract the final flag\n        ''',\n        settings=settings\n    )\n\n    # Stream results for real-time feedback\n    async for chunk in agent.run_streamed():\n        print(chunk, end='', flush=True)\n\n    return agent\n\n# Usage\nasyncio.run(analyze_complex_challenge())\n</code></pre>"},{"location":"documentation/examples/#custom-agent-development","title":"Custom Agent Development","text":""},{"location":"documentation/examples/#creating-a-specialized-agent","title":"Creating a Specialized Agent","text":"<pre><code>\"\"\"Example of creating a custom specialized agent.\"\"\"\n\nfrom typing import Optional\nfrom agents import Agent\n\nfrom ivexes.agents.base import BaseAgent\nfrom ivexes.config import PartialSettings\nfrom ivexes.sandbox.tools import create_sandbox_tools\nfrom ivexes.vector_db import create_vectordb_tools\n\nclass WebVulnAgent(BaseAgent):\n    \"\"\"Custom agent specialized for web vulnerability analysis.\"\"\"\n\n    def __init__(self, target_url: str, settings: Optional[PartialSettings] = None):\n        \"\"\"Initialize Web Vulnerability Agent.\n\n        Args:\n            target_url: Target web application URL\n            settings: Optional configuration settings\n        \"\"\"\n        self.target_url = target_url\n        super().__init__(settings or {})\n\n    def _setup_agent(self):\n        \"\"\"Set up the web vulnerability agent.\"\"\"\n        # Custom system message for web vulnerabilities\n        self.system_msg = f\"\"\"\n        You are a web vulnerability assessment specialist focused on analyzing\n        web applications for security vulnerabilities including:\n\n        - SQL injection\n        - Cross-site scripting (XSS)\n        - Cross-site request forgery (CSRF)\n        - Authentication and authorization flaws\n        - Input validation issues\n\n        Target URL: {self.target_url}\n\n        Use the available tools to conduct thorough security assessment.\n        \"\"\"\n\n        # Create specialized tool set\n        sandbox_tools = create_sandbox_tools(self.settings)\n        vector_tools = create_vectordb_tools(self.settings)\n\n        # Add web-specific tools\n        web_tools = self._create_web_tools()\n\n        tools = sandbox_tools + vector_tools + web_tools\n\n        self.agent = Agent(\n            model=self.settings.model,\n            tools=tools,\n            system_message=self.system_msg\n        )\n\n    def _create_web_tools(self):\n        \"\"\"Create web-specific analysis tools.\"\"\"\n        # Implementation would include web scanning tools\n        return []\n\n# Usage example\nasync def analyze_web_app():\n    \"\"\"Analyze web application for vulnerabilities.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=20\n    )\n\n    agent = WebVulnAgent(\n        target_url='https://example-vulnerable-app.com',\n        settings=settings\n    )\n\n    await agent.run_interactive()\n\n# Run the analysis\nasyncio.run(analyze_web_app())\n</code></pre>"},{"location":"documentation/examples/#agent-with-custom-tools","title":"Agent with Custom Tools","text":"<pre><code>\"\"\"Custom agent with domain-specific tools.\"\"\"\n\nfrom typing import List, Dict, Any\nfrom agents import Agent, tool\n\nfrom ivexes.agents.base import BaseAgent\nfrom ivexes.config import PartialSettings\n\nclass NetworkSecurityAgent(BaseAgent):\n    \"\"\"Agent specialized for network security analysis.\"\"\"\n\n    def __init__(self, target_network: str, settings: Optional[PartialSettings] = None):\n        self.target_network = target_network\n        super().__init__(settings or {})\n\n    def _setup_agent(self):\n        \"\"\"Set up network security agent with custom tools.\"\"\"\n\n        @tool\n        def scan_network_ports(target: str) -&gt; Dict[str, Any]:\n            \"\"\"Scan network ports for open services.\n\n            Args:\n                target: Network target to scan\n\n            Returns:\n                Dict containing scan results\n            \"\"\"\n            # Implementation would use nmap or similar\n            return {\n                'target': target,\n                'open_ports': [22, 80, 443, 8080],\n                'services': {\n                    '22': 'ssh',\n                    '80': 'http',\n                    '443': 'https',\n                    '8080': 'http-proxy'\n                }\n            }\n\n        @tool\n        def analyze_ssl_configuration(host: str, port: int = 443) -&gt; Dict[str, Any]:\n            \"\"\"Analyze SSL/TLS configuration.\n\n            Args:\n                host: Target hostname\n                port: SSL port (default 443)\n\n            Returns:\n                SSL analysis results\n            \"\"\"\n            # Implementation would use testssl.sh or similar\n            return {\n                'host': host,\n                'port': port,\n                'ssl_version': 'TLSv1.3',\n                'cipher_suites': ['TLS_AES_256_GCM_SHA384'],\n                'vulnerabilities': []\n            }\n\n        tools = [scan_network_ports, analyze_ssl_configuration]\n\n        self.agent = Agent(\n            model=self.settings.model,\n            tools=tools,\n            system_message=f\"\"\"\n            You are a network security specialist analyzing: {self.target_network}\n\n            Focus on:\n            - Open service enumeration\n            - SSL/TLS configuration analysis\n            - Network vulnerability assessment\n            - Security recommendations\n            \"\"\"\n        )\n\n# Usage\nasync def network_security_analysis():\n    \"\"\"Perform network security analysis.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        temperature=0.1,\n        max_turns=15\n    )\n\n    agent = NetworkSecurityAgent(\n        target_network='192.168.1.0/24',\n        settings=settings\n    )\n\n    await agent.run_interactive()\n\nasyncio.run(network_security_analysis())\n</code></pre>"},{"location":"documentation/examples/#integration-examples","title":"Integration Examples","text":""},{"location":"documentation/examples/#vector-database-integration","title":"Vector Database Integration","text":"<pre><code>\"\"\"Example of ChromaDB vector database integration.\"\"\"\n\nfrom typing import cast\nfrom chromadb import EmbeddingFunction, Client\nfrom chromadb.utils.embedding_functions import SentenceTransformerEmbeddingFunction\n\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nasync def vector_db_integration_example():\n    \"\"\"Demonstrate vector database integration.\"\"\"\n\n    # Setup ChromaDB\n    chroma_client = Client()\n\n    ef = SentenceTransformerEmbeddingFunction(\n        model_name='intfloat/multilingual-e5-large-instruct'\n    )\n\n    ef = cast(EmbeddingFunction, ef)\n    collection = chroma_client.create_collection(\n        name='vulnerability_knowledge', \n        embedding_function=ef\n    )\n\n    # Add vulnerability knowledge\n    collection.add(\n        ids=['cve-2021-44228', 'cve-2021-45046'],\n        documents=[\n            'Log4j JNDI injection vulnerability allows remote code execution',\n            'Log4j denial of service vulnerability in message lookup substitution'\n        ],\n        metadatas=[\n            {'severity': 'critical', 'cvss': 10.0},\n            {'severity': 'high', 'cvss': 9.0}\n        ]\n    )\n\n    # Query for related vulnerabilities\n    results = collection.query(\n        query_texts=['remote code execution java logging'],\n        n_results=2\n    )\n\n    print(f\"Related vulnerabilities: {results}\")\n\n    # Use with agent\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        embedding_provider='local',\n        embedding_model='intfloat/multilingual-e5-large-instruct',\n        chroma_path='/tmp/ivexes_vectordb'\n    )\n\n    agent = SingleAgent(\n        bin_path='/usr/bin/java_app',\n        settings=settings\n    )\n\n    await agent.run_interactive()\n\nasyncio.run(vector_db_integration_example())\n</code></pre>"},{"location":"documentation/examples/#sandbox-integration","title":"Sandbox Integration","text":"<pre><code>\"\"\"Example of sandbox integration for dynamic analysis.\"\"\"\n\nimport asyncio\nfrom ivexes.sandbox import Sandbox\nfrom ivexes.config import PartialSettings\n\nasync def sandbox_integration_example():\n    \"\"\"Demonstrate sandbox integration.\"\"\"\n\n    settings = PartialSettings(\n        sandbox_image='kali-ssh:latest',\n        setup_archive='/path/to/analysis_environment.tgz'\n    )\n\n    # Create sandbox environment\n    sandbox = Sandbox(settings)\n\n    try:\n        # Start sandbox\n        await sandbox.start()\n\n        # Execute analysis commands\n        result = await sandbox.execute_command('file /usr/bin/target_binary')\n        print(f\"File analysis: {result}\")\n\n        result = await sandbox.execute_command('strings /usr/bin/target_binary | head -20')\n        print(f\"String analysis: {result}\")\n\n        # Run dynamic analysis\n        result = await sandbox.execute_command('ltrace -c /usr/bin/target_binary')\n        print(f\"Library trace: {result}\")\n\n    finally:\n        # Clean up\n        await sandbox.stop()\n\nasyncio.run(sandbox_integration_example())\n</code></pre>"},{"location":"documentation/examples/#advanced-use-cases","title":"Advanced Use Cases","text":""},{"location":"documentation/examples/#batch-analysis-pipeline","title":"Batch Analysis Pipeline","text":"<pre><code>\"\"\"Batch vulnerability analysis pipeline.\"\"\"\n\nimport asyncio\nfrom pathlib import Path\nfrom typing import List, Dict, Any\n\nfrom ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings\n\nclass BatchAnalysisPipeline:\n    \"\"\"Pipeline for batch vulnerability analysis.\"\"\"\n\n    def __init__(self, settings: PartialSettings):\n        self.settings = settings\n        self.results: List[Dict[str, Any]] = []\n\n    async def analyze_targets(self, targets: List[Dict[str, str]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze multiple targets in batch.\n\n        Args:\n            targets: List of target configurations\n\n        Returns:\n            List of analysis results\n        \"\"\"\n        results = []\n\n        for target in targets:\n            print(f\"Analyzing {target['name']}...\")\n\n            # Configure target-specific settings\n            target_settings = PartialSettings(\n                **self.settings.model_dump(),\n                **target\n            )\n\n            agent = MultiAgent(settings=target_settings)\n\n            try:\n                report, context = await agent.run_ensured_report()\n\n                result = {\n                    'target': target['name'],\n                    'status': 'completed',\n                    'report': report,\n                    'vulnerabilities': len(context.shared_memory.vulnerabilities) if context.shared_memory else 0,\n                    'findings': context.shared_memory.findings if context.shared_memory else []\n                }\n\n            except Exception as e:\n                result = {\n                    'target': target['name'],\n                    'status': 'failed',\n                    'error': str(e)\n                }\n\n            results.append(result)\n\n        return results\n\n    def generate_summary_report(self, results: List[Dict[str, Any]]) -&gt; str:\n        \"\"\"Generate summary report from batch results.\"\"\"\n\n        total_targets = len(results)\n        successful = len([r for r in results if r['status'] == 'completed'])\n        failed = total_targets - successful\n\n        total_vulnerabilities = sum(\n            r.get('vulnerabilities', 0) for r in results \n            if r['status'] == 'completed'\n        )\n\n        summary = f\"\"\"\n# Batch Analysis Summary\n\n## Overview\n- Total targets analyzed: {total_targets}\n- Successful analyses: {successful}\n- Failed analyses: {failed}\n- Total vulnerabilities found: {total_vulnerabilities}\n\n## Detailed Results\n\"\"\"\n\n        for result in results:\n            if result['status'] == 'completed':\n                summary += f\"\"\"\n### {result['target']}\n- Status: \u2705 Completed\n- Vulnerabilities: {result['vulnerabilities']}\n- Key findings: {len(result['findings'])}\n\"\"\"\n            else:\n                summary += f\"\"\"\n### {result['target']}\n- Status: \u274c Failed\n- Error: {result.get('error', 'Unknown error')}\n\"\"\"\n\n        return summary\n\n# Usage example\nasync def run_batch_analysis():\n    \"\"\"Run batch vulnerability analysis.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=30,\n        embedding_provider='local'\n    )\n\n    targets = [\n        {\n            'name': 'screen-vulnerability',\n            'codebase_path': '/path/to/screen/codebase',\n            'vulnerable_folder': 'vulnerable-4.5.0',\n            'patched_folder': 'patched-4.5.1',\n            'setup_archive': '/path/to/screen.tgz'\n        },\n        {\n            'name': 'sudo-vulnerability',\n            'codebase_path': '/path/to/sudo/codebase',\n            'vulnerable_folder': 'vulnerable-1.8.0',\n            'patched_folder': 'patched-1.8.1',\n            'setup_archive': '/path/to/sudo.tgz'\n        }\n    ]\n\n    pipeline = BatchAnalysisPipeline(settings)\n    results = await pipeline.analyze_targets(targets)\n\n    # Generate and save summary\n    summary = pipeline.generate_summary_report(results)\n\n    with open('batch_analysis_summary.md', 'w') as f:\n        f.write(summary)\n\n    print(\"Batch analysis completed. Summary saved to batch_analysis_summary.md\")\n\n    return results\n\n# Run the pipeline\nasyncio.run(run_batch_analysis())\n</code></pre>"},{"location":"documentation/examples/#related-topics","title":"Related Topics","text":"<ul> <li>Architecture Guide - System design and components</li> <li>Installation Guide - Setup and configuration</li> <li>Development Guide - Extending and customizing IVEXES</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"documentation/examples/#next-steps","title":"Next Steps","text":"<ol> <li>Start with Basic Examples: Try the SingleAgent and MVPAgent examples to understand core functionality</li> <li>Explore Multi-Agent: Experiment with MultiAgent coordination for complex analyses</li> <li>Customize Agents: Create specialized agents for your specific use cases</li> <li>Integrate Components: Combine vector database, sandbox, and code browser capabilities</li> <li>Build Pipelines: Develop automated analysis pipelines for batch processing</li> </ol> <p>For more advanced usage patterns and customization options, see the Development Guide and API Reference.</p>"},{"location":"documentation/installation/","title":"Installation Guide","text":""},{"location":"documentation/installation/#overview","title":"Overview","text":"<p>This guide provides comprehensive instructions for installing and setting up IVEXES (Intelligent Vulnerability Extraction &amp; Exploit Synthesis). The installation process involves setting up the Python environment, configuring Docker containers, and initializing the LiteLLM proxy for API access.</p>"},{"location":"documentation/installation/#prerequisites","title":"Prerequisites","text":""},{"location":"documentation/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Operating System: Linux, macOS, or Windows with WSL2</li> <li>Python: Version 3.12 or higher</li> <li>Docker: Version 20.10 or higher with Docker Compose V2</li> <li>Memory: Minimum 8GB RAM (16GB recommended for large analyses)</li> <li>Storage: At least 10GB free space for containers and databases</li> <li>Network: Internet access for downloading models and vulnerability data</li> </ul>"},{"location":"documentation/installation/#required-software","title":"Required Software","text":"<ol> <li> <p>Python 3.12+ <pre><code># Check Python version\npython --version\n# or\npython3 --version\n</code></pre></p> </li> <li> <p>Docker &amp; Docker Compose <pre><code># Check Docker version\ndocker --version\ndocker compose version\n</code></pre></p> </li> <li> <p>Git (for development installation)    <pre><code>git --version\n</code></pre></p> </li> </ol>"},{"location":"documentation/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"documentation/installation/#method-1-quick-setup-recommended","title":"Method 1: Quick Setup (Recommended)","text":"<p>The quickest way to get IVEXES running is using the provided Makefile:</p> <pre><code># Clone the repository\ngit clone https://github.com/LetsDrinkSomeTea/ivexes.git\ncd ivexes\n\n# Run complete setup (builds images, syncs dependencies, starts LiteLLM)\nmake setup\n</code></pre> <p>This command will: 1. Build Docker images for Nvim LSP and Kali sandbox 2. Install Python dependencies using uv 3. Start the LiteLLM proxy server</p>"},{"location":"documentation/installation/#method-2-step-by-step-installation","title":"Method 2: Step-by-Step Installation","text":"<p>For more control over the installation process:</p>"},{"location":"documentation/installation/#step-1-environment-setup","title":"Step 1: Environment Setup","text":"<p>First, set up the Python environment:</p> <pre><code># Option A: Using uv (recommended)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nuv sync --all-extras --all-packages --group dev\n\n# Option B: Using pip (legacy)\npip install -e \".[dev]\"\n</code></pre>"},{"location":"documentation/installation/#step-2-build-container-images","title":"Step 2: Build Container Images","text":"<p>Build the required Docker images:</p> <pre><code># Build all images\nmake build-images\n\n# Or manually:\ndocker compose --profile images build\n</code></pre> <p>This builds: - nvim-lsp:latest - Neovim with LSP support for code analysis - kali-ssh:latest - Kali Linux environment for security testing</p>"},{"location":"documentation/installation/#step-3-start-litellm-proxy","title":"Step 3: Start LiteLLM Proxy","text":"<p>Start the LiteLLM proxy service:</p> <pre><code># Start LiteLLM and database\nmake run-litellm\n\n# Or manually:\ndocker compose up -d\n</code></pre>"},{"location":"documentation/installation/#step-4-environment-configuration","title":"Step 4: Environment Configuration","text":"<p>Create environment configuration files:</p> <pre><code># Create .env file for general settings\ncat &gt; .env &lt;&lt; EOF\nMODEL=openai/gpt-4o-mini\nREASONING_MODEL=openai/o4-mini\nTEMPERATURE=0.3\nMAX_TURNS=10\nLOG_LEVEL=INFO\nEOF\n\n# Create .secrets.env for API keys (never commit this file)\ncat &gt; .secrets.env &lt;&lt; EOF\nOPENAI_API_KEY=your_openai_api_key_here\nLLM_API_KEY=your_llm_api_key_here\nLLM_BASE_URL=http://localhost:4000/v1\nEOF\n</code></pre>"},{"location":"documentation/installation/#configuration","title":"Configuration","text":""},{"location":"documentation/installation/#api-keys","title":"API Keys","text":"<p>IVEXES requires API keys for LLM services:</p>"},{"location":"documentation/installation/#openai-configuration","title":"OpenAI Configuration","text":"<pre><code>export OPENAI_API_KEY=\"sk-your-openai-key\"\nexport LLM_BASE_URL=\"https://api.openai.com/v1\"\n</code></pre>"},{"location":"documentation/installation/#litellm-proxy-configuration","title":"LiteLLM Proxy Configuration","text":"<pre><code>export LLM_API_KEY=\"sk-1234\"  # Default LiteLLM key\nexport LLM_BASE_URL=\"http://localhost:4000/v1\"\n</code></pre>"},{"location":"documentation/installation/#alternative-providers","title":"Alternative Providers","text":"<pre><code># Anthropic Claude\nexport LLM_API_KEY=\"your-anthropic-key\"\nexport LLM_BASE_URL=\"your-litellm-proxy-url\"\n\n# Google Gemini\nexport LLM_API_KEY=\"your-google-key\"\nexport LLM_BASE_URL=\"your-litellm-proxy-url\"\n</code></pre>"},{"location":"documentation/installation/#environment-variables","title":"Environment Variables","text":"<p>Key configuration options:</p> Variable Default Description <code>MODEL</code> <code>openai/gpt-4o-mini</code> Primary LLM model <code>REASONING_MODEL</code> <code>openai/o4-mini</code> Model for reasoning tasks <code>TEMPERATURE</code> <code>0.3</code> Model temperature (0.0-2.0) <code>MAX_TURNS</code> <code>10</code> Maximum agent conversation turns <code>LOG_LEVEL</code> <code>INFO</code> Logging level <code>TRACE_NAME</code> <code>ivexes</code> OpenAI tracing identifier <code>SESSION_DB_PATH</code> <code>./sessions.sqlite</code> Session database path <code>CHROMA_PATH</code> <code>/tmp/ivexes/chromadb</code> Vector database path"},{"location":"documentation/installation/#directory-structure","title":"Directory Structure","text":"<p>After installation, your directory should look like:</p> <pre><code>ivexes/\n\u251c\u2500\u2500 src/ivexes/              # Main package source\n\u251c\u2500\u2500 container/               # Docker configurations\n\u2502   \u251c\u2500\u2500 nvim_lsp/           # Neovim LSP container\n\u2502   \u251c\u2500\u2500 kali_sandbox/       # Kali sandbox container\n\u2502   \u2514\u2500\u2500 litellm/            # LiteLLM configuration\n\u251c\u2500\u2500 docs/                   # Documentation\n\u251c\u2500\u2500 examples/               # Usage examples\n\u251c\u2500\u2500 tests/                  # Test suite\n\u251c\u2500\u2500 .env                    # Environment settings\n\u251c\u2500\u2500 .secrets.env            # API keys (create this)\n\u2514\u2500\u2500 docker-compose.yaml     # Container orchestration\n</code></pre>"},{"location":"documentation/installation/#verification","title":"Verification","text":""},{"location":"documentation/installation/#1-check-installation-status","title":"1. Check Installation Status","text":"<p>Verify that all components are properly installed:</p> <pre><code># Check Python dependencies\nuv run python -c \"import ivexes; print('IVEXES imported successfully')\"\n\n# Check Docker images\ndocker images | grep -E \"(nvim-lsp|kali-ssh)\"\n\n# Check running containers\ndocker compose ps\n</code></pre>"},{"location":"documentation/installation/#2-test-litellm-proxy","title":"2. Test LiteLLM Proxy","text":"<p>Verify the LiteLLM proxy is working:</p> <pre><code># Check health endpoint\ncurl http://localhost:4000/health/liveliness\n\n# Test API endpoint\ncurl -X POST http://localhost:4000/v1/chat/completions \\\n  -H \"Authorization: Bearer sk-1234\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"model\": \"gpt-3.5-turbo\",\n    \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}]\n  }'\n</code></pre>"},{"location":"documentation/installation/#3-run-test-suite","title":"3. Run Test Suite","text":"<p>Execute the test suite to verify functionality:</p> <pre><code># Run all tests\nmake tests\n\n# Or manually:\nuv run python -m unittest discover -s tests -v\n</code></pre>"},{"location":"documentation/installation/#4-basic-functionality-test","title":"4. Basic Functionality Test","text":"<p>Test basic IVEXES functionality:</p> <pre><code># Run a simple example\nuv run python examples/20_mvp_screen.py\n\n# Or test interactively\nuv run python -c \"\nfrom ivexes.agents import MVPAgent\nfrom ivexes.config import PartialSettings\n\nsettings = PartialSettings()\nagent = MVPAgent(settings=settings)\nprint('Agent initialized successfully')\n\"\n</code></pre>"},{"location":"documentation/installation/#docker-services","title":"Docker Services","text":""},{"location":"documentation/installation/#litellm-proxy","title":"LiteLLM Proxy","text":"<p>The LiteLLM proxy provides unified API access to multiple LLM providers:</p> <ul> <li>Service: <code>litellm</code></li> <li>Port: <code>4000</code></li> <li>Health Check: <code>http://localhost:4000/health/liveliness</code></li> <li>API Endpoint: <code>http://localhost:4000/v1</code></li> <li>Master Key: <code>sk-1234</code> (configurable)</li> </ul>"},{"location":"documentation/installation/#postgresql-database","title":"PostgreSQL Database","text":"<p>Database for LiteLLM configuration and logging:</p> <ul> <li>Service: <code>db</code></li> <li>Internal Port: <code>5432</code></li> <li>Database: <code>litellm</code></li> <li>User: <code>llmproxy</code></li> <li>Data Volume: <code>./container/litellm/data/postgres_data</code></li> </ul>"},{"location":"documentation/installation/#container-images","title":"Container Images","text":"<p>Two specialized images are built for analysis:</p> <ol> <li>nvim-lsp:latest</li> <li>Neovim with LSP support</li> <li>Language servers for multiple languages</li> <li> <p>Code analysis and navigation tools</p> </li> <li> <p>kali-ssh:latest</p> </li> <li>Kali Linux security distribution</li> <li>Pre-installed security testing tools</li> <li>SSH server for remote access</li> </ol>"},{"location":"documentation/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"documentation/installation/#common-issues","title":"Common Issues","text":""},{"location":"documentation/installation/#1-docker-permission-issues","title":"1. Docker Permission Issues","text":"<pre><code># Add user to docker group\nsudo usermod -aG docker $USER\n# Logout and login again\n</code></pre>"},{"location":"documentation/installation/#2-port-conflicts","title":"2. Port Conflicts","text":"<pre><code># Check if port 4000 is in use\nlsof -i :4000\n# Stop conflicting services or change port in docker-compose.yaml\n</code></pre>"},{"location":"documentation/installation/#3-python-version-issues","title":"3. Python Version Issues","text":"<pre><code># Install Python 3.12 on Ubuntu/Debian\nsudo apt update\nsudo apt install python3.12 python3.12-venv python3.12-pip\n\n# Or use pyenv\ncurl https://pyenv.run | bash\npyenv install 3.12.0\npyenv global 3.12.0\n</code></pre>"},{"location":"documentation/installation/#4-memory-issues","title":"4. Memory Issues","text":"<pre><code># Increase Docker memory limit\n# Docker Desktop: Settings &gt; Resources &gt; Memory &gt; 8GB+\n# Or add swap space on Linux systems\n</code></pre>"},{"location":"documentation/installation/#5-container-build-failures","title":"5. Container Build Failures","text":"<pre><code># Clean Docker cache and rebuild\ndocker system prune -a\nmake build-images\n</code></pre>"},{"location":"documentation/installation/#6-litellm-startup-issues","title":"6. LiteLLM Startup Issues","text":"<pre><code># Check logs\ndocker compose logs litellm\n\n# Restart services\ndocker compose down\ndocker compose up -d\n</code></pre>"},{"location":"documentation/installation/#dependency-issues","title":"Dependency Issues","text":""},{"location":"documentation/installation/#uv-installation-problems","title":"uv Installation Problems","text":"<pre><code># Alternative uv installation methods\npip install uv\n# or\npipx install uv\n</code></pre>"},{"location":"documentation/installation/#chromadb-issues","title":"ChromaDB Issues","text":"<pre><code># Clear ChromaDB cache\nrm -rf /tmp/ivexes/chromadb\n# Or set custom path\nexport CHROMA_PATH=\"/path/to/your/chromadb\"\n</code></pre>"},{"location":"documentation/installation/#performance-optimization","title":"Performance Optimization","text":""},{"location":"documentation/installation/#for-low-memory-systems","title":"For Low-Memory Systems","text":"<pre><code># Use smaller models\nexport MODEL=\"openai/gpt-4o-mini\"\nexport REASONING_MODEL=\"openai/gpt-4o-mini\"\n\n# Reduce max turns\nexport MAX_TURNS=\"5\"\n</code></pre>"},{"location":"documentation/installation/#for-better-performance","title":"For Better Performance","text":"<pre><code># Use local embedding models\nexport EMBEDDING_PROVIDER=\"local\"\nexport EMBEDDING_MODEL=\"sentence-transformers/all-MiniLM-L6-v2\"\n\n# Enable parallel processing\nexport PARALLEL_PROCESSING=\"true\"\n</code></pre>"},{"location":"documentation/installation/#development-installation","title":"Development Installation","text":"<p>For development work:</p> <pre><code># Install with development dependencies\nuv sync --all-extras --all-packages --group dev\n\n# Install pre-commit hooks\nuv run pre-commit install\n\n# Run development tools\nmake format      # Format code\nmake lint        # Run linter\nmake tests       # Run tests\nmake build-docs  # Build documentation\nmake serve-docs  # Serve docs locally\n</code></pre>"},{"location":"documentation/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Configuration: Review the Configuration Guide for detailed settings</li> <li>Usage: Read the Usage Guide to learn basic workflows</li> <li>Examples: Explore the Examples Guide for practical use cases</li> <li>Development: See the Development Guide for contributing</li> </ol>"},{"location":"documentation/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the troubleshooting section above</li> <li>Review the Configuration Guide for settings issues</li> <li>Examine log files and error messages</li> <li>Search existing GitHub issues</li> <li>Create a new issue with detailed error information</li> </ol>"},{"location":"documentation/installation/#related-topics","title":"Related Topics","text":"<ul> <li>Architecture Guide - System design and components</li> <li>Configuration Guide - Detailed configuration options</li> <li>Usage Guide - Basic usage patterns</li> <li>Development Guide - Development setup and contribution</li> </ul>"},{"location":"documentation/usage/","title":"Usage Guide","text":""},{"location":"documentation/usage/#overview","title":"Overview","text":"<p>This guide covers the core workflows and best practices for using IVEXES effectively. IVEXES provides multiple execution modes and agent types designed for different vulnerability analysis scenarios, from quick assessments to comprehensive multi-agent orchestrations.</p> <p>The framework emphasizes flexibility through its agent-based architecture, allowing you to choose the right tool for your analysis needs while maintaining consistent interfaces across all execution modes.</p>"},{"location":"documentation/usage/#getting-started","title":"Getting Started","text":""},{"location":"documentation/usage/#basic-setup","title":"Basic Setup","text":"<p>Before using IVEXES agents, ensure your environment is properly configured:</p> <pre><code>from dotenv import load_dotenv\nfrom ivexes.config import setup_default_logging\n\n# Load environment variables\nload_dotenv(verbose=True, override=True)\n\n# Configure logging\nsetup_default_logging('INFO')  # DEBUG, INFO, WARNING, ERROR, CRITICAL\n</code></pre>"},{"location":"documentation/usage/#quick-start-example","title":"Quick Start Example","text":"<pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\nimport asyncio\n\n# Configure the agent\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    codebase_path='/path/to/analysis',\n    vulnerable_folder='vulnerable',\n    patched_folder='patched',\n    max_turns=10\n)\n\n# Create and run the agent\nagent = SingleAgent(bin_path='/target/binary', settings=settings)\nresult = await agent.run_interactive()\n</code></pre>"},{"location":"documentation/usage/#agent-execution-modes","title":"Agent Execution Modes","text":"<p>All IVEXES agents support three execution modes, each optimized for different use cases:</p>"},{"location":"documentation/usage/#1-synchronous-mode","title":"1. Synchronous Mode","text":"<p>Best for: Batch processing, automated analysis, scripting</p> <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nagent = SingleAgent(bin_path='/target/binary', settings=settings)\n\n# Basic synchronous execution\nresult = agent.run(\"Analyze this binary for buffer overflow vulnerabilities\")\nprint(\"Analysis result:\", result.data)\nprint(\"Tokens used:\", result.usage.total_tokens)\n\n# With automatic output printing\nagent.run_p(\"Perform security assessment\")\n</code></pre> <p>When to use: Automated security pipelines, batch analysis, CI/CD integration</p>"},{"location":"documentation/usage/#2-streaming-mode","title":"2. Streaming Mode","text":"<p>Best for: Real-time feedback, long-running analysis, user interfaces</p> <pre><code>import asyncio\n\nasync def streaming_analysis():\n    agent = SingleAgent(bin_path='/target/binary', settings=settings)\n\n    # Stream results as they're generated\n    result_stream = agent.run_streamed(\"Comprehensive vulnerability analysis\")\n\n    # Process streaming results\n    async for chunk in result_stream:\n        print(\"Analysis progress:\", chunk)\n\n    # Alternative: Stream with automatic printing\n    await agent.run_streamed_p(\"Analyze binary for memory corruption issues\")\n\n# Run streaming analysis\nasyncio.run(streaming_analysis())\n</code></pre> <p>When to use: Interactive applications, progress monitoring, real-time dashboards</p>"},{"location":"documentation/usage/#3-interactive-mode","title":"3. Interactive Mode","text":"<p>Best for: Exploratory analysis, iterative investigation, learning</p> <pre><code>import asyncio\n\nasync def interactive_session():\n    agent = SingleAgent(bin_path='/target/binary', settings=settings)\n\n    # Start interactive conversation\n    await agent.run_interactive(\"Begin security analysis of this binary\")\n\n    # Session continues until user types 'exit', 'quit', or 'q'\n    # Users can ask follow-up questions and refine analysis\n\n# Custom result processing\ndef save_findings(result):\n    \"\"\"Save important findings to file.\"\"\"\n    with open('vulnerability_findings.txt', 'a') as f:\n        f.write(f\"Finding: {result.data}\\n\")\n        f.write(f\"Tokens: {result.usage.total_tokens}\\n\\n\")\n\nasync def interactive_with_hooks():\n    agent = SingleAgent(bin_path='/target/binary', settings=settings)\n\n    await agent.run_interactive(\n        \"Start vulnerability assessment\",\n        result_hook=save_findings\n    )\n\nasyncio.run(interactive_session())\n</code></pre> <p>When to use: Security research, learning, detailed investigation, hypothesis testing</p>"},{"location":"documentation/usage/#agent-types-and-use-cases","title":"Agent Types and Use Cases","text":""},{"location":"documentation/usage/#singleagent","title":"SingleAgent","text":"<p>Purpose: Comprehensive individual analysis with full toolset integration</p> <p>Best for: - Focused vulnerability analysis - Binary reverse engineering - Code diff analysis - CVE research and correlation</p> <p>Features: - Complete toolset: sandbox, code browser, vector database, CVE search - Isolated execution environment - Source code analysis and comparison - Knowledge base integration</p> <pre><code>from ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\n# Standard configuration\nsettings = PartialSettings(\n    model='openai/gpt-4o-mini',\n    codebase_path='/analysis/project',\n    vulnerable_folder='v1.0-vuln',\n    patched_folder='v1.1-fixed',\n    max_turns=15,\n    model_temperature=0.2\n)\n\nagent = SingleAgent(\n    bin_path='/sandbox/target_binary',\n    settings=settings\n)\n\n# Synchronous analysis\nresult = agent.run(\"Identify memory corruption vulnerabilities\")\n\n# Interactive exploration\nawait agent.run_interactive(\"Investigate potential buffer overflows\")\n</code></pre>"},{"location":"documentation/usage/#multiagent","title":"MultiAgent","text":"<p>Purpose: Coordinated multi-agent analysis for complex scenarios</p> <p>Best for: - Large-scale security assessments - Multi-perspective analysis - Comprehensive reporting - Complex vulnerability chains</p> <p>Architecture: - Planning Agent: Orchestrates the analysis workflow - Security Specialist: CVE, CWE, CAPEC, ATT&amp;CK expertise - Code Analyst: Source code structure and vulnerability analysis - Red Team Operator: Exploitation and penetration testing - Report Journalist: Comprehensive vulnerability reporting</p> <pre><code>from ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings\n\n# High-performance multi-agent setup\nsettings = PartialSettings(\n    model='openai/gpt-4',\n    reasoning_model='openai/o1-mini',\n    model_temperature=0.1,\n    max_turns=25,\n    codebase_path='/large-project',\n    vulnerable_folder='v2.0',\n    patched_folder='v2.1'\n)\n\nmulti_agent = MultiAgent(settings=settings)\n\n# Coordinated analysis with automatic reporting\nreport_data, shared_context = await multi_agent.run_ensured_report()\n\n# Stream coordinated analysis\nawait multi_agent.run_streamed_p(\n    \"Perform comprehensive security assessment with detailed reporting\"\n)\n\n# Access coordination results\nprint(\"Multi-agent analysis complete\")\nprint(\"Usage summary:\", multi_agent.context.get_usage())\nprint(\"Shared findings:\", multi_agent.context.shared_memory.summary())\n</code></pre>"},{"location":"documentation/usage/#mvpagent","title":"MVPAgent","text":"<p>Purpose: Minimal viable product analysis for quick assessments</p> <p>Best for: - Quick vulnerability checks - Proof-of-concept analysis - Resource-constrained environments - Initial assessment before deeper analysis</p> <pre><code>from ivexes.agents import MVPAgent\nfrom ivexes.config import PartialSettings\n\nagent = MVPAgent(\n    vulnerable_version=\"vulnerable-1.0\",\n    patched_version=\"patched-1.1\",\n    settings=PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=5\n    )\n)\n\n# Quick analysis\nresult = agent.run(\"Identify key vulnerabilities and their fixes\")\n</code></pre>"},{"location":"documentation/usage/#htbchallengeagent","title":"HTBChallengeAgent","text":"<p>Purpose: Specialized for Hack The Box and CTF challenges</p> <p>Best for: - Capture The Flag competitions - Binary exploitation challenges - Reverse engineering puzzles - Educational security exercises</p> <pre><code>from ivexes.agents import HTBChallengeAgent\nfrom ivexes.config import PartialSettings\n\nagent = HTBChallengeAgent(\n    program=\"ghost\",\n    challenge=\"Find the hidden flag in this binary\",\n    settings=PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=20\n    )\n)\n\n# CTF analysis\nresult = agent.run(\"Solve this reverse engineering challenge\")\n</code></pre>"},{"location":"documentation/usage/#common-workflows","title":"Common Workflows","text":""},{"location":"documentation/usage/#1-binary-vulnerability-analysis","title":"1. Binary Vulnerability Analysis","text":"<p>Complete workflow for analyzing a vulnerable binary:</p> <pre><code>import asyncio\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nasync def binary_analysis_workflow():\n    \"\"\"Complete binary vulnerability analysis workflow.\"\"\"\n\n    # Configuration for binary analysis\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=20,\n        model_temperature=0.1,  # More deterministic for security analysis\n        setup_archive='/analysis/target.tar.gz',  # Archive to extract\n        codebase_path='/analysis/source',\n        vulnerable_folder='vulnerable',\n        patched_folder='patched'\n    )\n\n    agent = SingleAgent(bin_path='/target/vulnerable_binary', settings=settings)\n\n    # Phase 1: Initial reconnaissance\n    print(\"Phase 1: Binary reconnaissance...\")\n    await agent.run_streamed_p(\n        \"Analyze the binary structure, identify interesting functions and potential attack surfaces\"\n    )\n\n    # Phase 2: Vulnerability identification  \n    print(\"\\nPhase 2: Vulnerability identification...\")\n    await agent.run_streamed_p(\n        \"Identify specific vulnerabilities in the binary, focusing on memory corruption and logic flaws\"\n    )\n\n    # Phase 3: Exploitation assessment\n    print(\"\\nPhase 3: Exploitation assessment...\")\n    await agent.run_streamed_p(\n        \"Assess exploitability of identified vulnerabilities and develop proof-of-concept exploits\"\n    )\n\n    # Phase 4: Mitigation analysis\n    print(\"\\nPhase 4: Mitigation analysis...\")\n    await agent.run_streamed_p(\n        \"Compare vulnerable and patched versions to understand fixes and their effectiveness\"\n    )\n\nasyncio.run(binary_analysis_workflow())\n</code></pre>"},{"location":"documentation/usage/#2-multi-agent-security-assessment","title":"2. Multi-Agent Security Assessment","text":"<p>Comprehensive security assessment using specialized agents:</p> <pre><code>import asyncio\nfrom ivexes.agents import MultiAgent\nfrom ivexes.config import PartialSettings\n\nasync def comprehensive_security_assessment():\n    \"\"\"Multi-perspective security assessment.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4',\n        reasoning_model='openai/o1-mini',\n        model_temperature=0.1,\n        max_turns=30,\n        codebase_path='/project',\n        vulnerable_folder='vulnerable',\n        patched_folder='fixed',\n        trace_name='security-assessment'\n    )\n\n    multi_agent = MultiAgent(settings=settings)\n\n    # Comprehensive analysis with automatic reporting\n    print(\"Starting comprehensive security assessment...\")\n    report_data, context = await multi_agent.run_ensured_report()\n\n    # Extract insights from shared context\n    shared_memory = context.shared_memory\n\n    print(\"\\n=== Analysis Summary ===\")\n    print(f\"Total runtime: {context.start_time}\")\n    print(f\"Report generated: {context.report_generated}\")\n\n    print(\"\\n=== Agent Usage ===\")\n    print(context.get_usage())\n\n    print(\"\\n=== Shared Findings ===\")\n    print(shared_memory.summary())\n\nasyncio.run(comprehensive_security_assessment())\n</code></pre>"},{"location":"documentation/usage/#3-interactive-investigation-session","title":"3. Interactive Investigation Session","text":"<p>Exploratory analysis with iterative questioning:</p> <pre><code>import asyncio\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nclass InvestigationTracker:\n    \"\"\"Track findings during interactive investigation.\"\"\"\n\n    def __init__(self):\n        self.findings = []\n        self.questions = []\n\n    def process_result(self, result):\n        \"\"\"Process and store investigation results.\"\"\"\n        if result.data:\n            self.findings.append({\n                'content': result.data,\n                'tokens': result.usage.total_tokens,\n                'timestamp': result.context_wrapper.start_time\n            })\n\n        # Save to file for persistence\n        with open('investigation_log.txt', 'a') as f:\n            f.write(f\"Result: {result.data}\\n\")\n            f.write(f\"Usage: {result.usage.total_tokens} tokens\\n\\n\")\n\nasync def interactive_investigation():\n    \"\"\"Interactive vulnerability investigation session.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=25,\n        codebase_path='/investigation/target',\n        vulnerable_folder='vulnerable',\n        patched_folder='patched'\n    )\n\n    agent = SingleAgent(bin_path='/target/binary', settings=settings)\n    tracker = InvestigationTracker()\n\n    print(\"Starting interactive investigation session...\")\n    print(\"Commands: 'exit', 'quit', or 'q' to end session\")\n    print(\"Ask questions about vulnerabilities, exploits, or mitigations\\n\")\n\n    await agent.run_interactive(\n        \"Begin detailed vulnerability investigation of this binary\",\n        result_hook=tracker.process_result\n    )\n\n    print(f\"\\nInvestigation complete. Found {len(tracker.findings)} key insights.\")\n\nasyncio.run(interactive_investigation())\n</code></pre>"},{"location":"documentation/usage/#4-automated-security-pipeline","title":"4. Automated Security Pipeline","text":"<p>Integration with CI/CD for automated vulnerability detection:</p> <pre><code>import asyncio\nimport sys\nfrom ivexes.agents import MVPAgent\nfrom ivexes.config import PartialSettings\n\nasync def automated_security_check(project_path, vulnerable_tag, fixed_tag):\n    \"\"\"Automated security check for CI/CD pipeline.\"\"\"\n\n    settings = PartialSettings(\n        model='openai/gpt-4o-mini',\n        max_turns=10,\n        model_temperature=0.0,  # Deterministic for consistent results\n        log_level='WARNING',    # Minimal logging for CI/CD\n        trace_name='ci-security-check'\n    )\n\n    agent = MVPAgent(\n        vulnerable_version=vulnerable_tag,\n        patched_version=fixed_tag,\n        settings=settings\n    )\n\n    try:\n        # Quick security assessment\n        result = agent.run(\n            \"Identify critical security vulnerabilities and assess severity\"\n        )\n\n        # Parse results for CI/CD decisions\n        has_critical_vulns = \"critical\" in result.data.lower()\n\n        if has_critical_vulns:\n            print(\"\u274c Critical vulnerabilities detected\")\n            print(result.data)\n            return 1  # Fail CI/CD pipeline\n        else:\n            print(\"\u2705 No critical vulnerabilities found\")\n            return 0  # Pass CI/CD pipeline\n\n    except Exception as e:\n        print(f\"\u274c Security check failed: {e}\")\n        return 2  # Error status\n\n# Usage in CI/CD\nif __name__ == \"__main__\":\n    if len(sys.argv) != 4:\n        print(\"Usage: script.py &lt;project_path&gt; &lt;vulnerable_tag&gt; &lt;fixed_tag&gt;\")\n        sys.exit(1)\n\n    exit_code = asyncio.run(\n        automated_security_check(sys.argv[1], sys.argv[2], sys.argv[3])\n    )\n    sys.exit(exit_code)\n</code></pre>"},{"location":"documentation/usage/#best-practices","title":"Best Practices","text":""},{"location":"documentation/usage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"documentation/usage/#model-selection","title":"Model Selection","text":"<pre><code># For development and quick analysis\ndevelopment_settings = PartialSettings(\n    model='openai/gpt-4o-mini',  # Fast and cost-effective\n    max_turns=5,                 # Limit conversation length\n    model_temperature=0.3        # Balance creativity and consistency\n)\n\n# For production security analysis\nproduction_settings = PartialSettings(\n    model='openai/gpt-4',             # Most capable model\n    reasoning_model='openai/o1-mini',  # Advanced reasoning\n    max_turns=20,                     # Allow thorough analysis\n    model_temperature=0.1             # More deterministic\n)\n</code></pre>"},{"location":"documentation/usage/#resource-management","title":"Resource Management","text":"<pre><code># Monitor token usage\nresult = agent.run(\"Analyze vulnerabilities\")\nprint(f\"Analysis used {result.usage.total_tokens} tokens\")\n\n# Set reasonable limits\nresource_conscious_settings = PartialSettings(\n    max_turns=10,           # Prevent runaway conversations\n    model_temperature=0.1,  # More predictable output\n    log_level='WARNING'     # Reduce logging overhead\n)\n</code></pre>"},{"location":"documentation/usage/#security-considerations","title":"Security Considerations","text":""},{"location":"documentation/usage/#sandbox-configuration","title":"Sandbox Configuration","text":"<pre><code># Secure sandbox setup\nsecure_settings = PartialSettings(\n    sandbox_image='kali-ssh:latest',  # Use specific image versions\n    setup_archive='/secure/analysis.tar.gz',  # Controlled environment\n    log_level='INFO'  # Audit trail\n)\n</code></pre>"},{"location":"documentation/usage/#api-key-management","title":"API Key Management","text":"<pre><code>import os\nfrom dotenv import load_dotenv\n\n# Load secrets securely\nload_dotenv('.secrets.env')  # Never commit this file\n\n# Validate API key availability\nif not os.environ.get('LLM_API_KEY'):\n    raise ValueError(\"LLM_API_KEY must be set for security analysis\")\n</code></pre>"},{"location":"documentation/usage/#error-handling","title":"Error Handling","text":""},{"location":"documentation/usage/#robust-error-handling","title":"Robust Error Handling","text":"<pre><code>import asyncio\nfrom ivexes.agents import SingleAgent\nfrom ivexes.config import PartialSettings\n\nasync def robust_analysis():\n    \"\"\"Analysis with comprehensive error handling.\"\"\"\n\n    try:\n        settings = PartialSettings(\n            model='openai/gpt-4o-mini',\n            max_turns=10\n        )\n\n        agent = SingleAgent(bin_path='/target/binary', settings=settings)\n        result = agent.run(\"Analyze for vulnerabilities\")\n\n    except ValueError as e:\n        print(f\"Configuration error: {e}\")\n        return None\n\n    except ConnectionError as e:\n        print(f\"API connection failed: {e}\")\n        return None\n\n    except Exception as e:\n        print(f\"Unexpected error during analysis: {e}\")\n        return None\n\n    return result\n\nresult = await robust_analysis()\nif result:\n    print(\"Analysis successful:\", result.data)\nelse:\n    print(\"Analysis failed - check configuration and connectivity\")\n</code></pre>"},{"location":"documentation/usage/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>async def analysis_with_fallback():\n    \"\"\"Analysis with model fallback strategy.\"\"\"\n\n    models_to_try = [\n        'openai/gpt-4',\n        'openai/gpt-4o-mini',\n        'anthropic/claude-3-sonnet'\n    ]\n\n    for model in models_to_try:\n        try:\n            settings = PartialSettings(model=model, max_turns=5)\n            agent = SingleAgent(bin_path='/target', settings=settings)\n            result = agent.run(\"Quick vulnerability scan\")\n\n            print(f\"\u2705 Analysis successful with {model}\")\n            return result\n\n        except Exception as e:\n            print(f\"\u274c Failed with {model}: {e}\")\n            continue\n\n    print(\"\u274c All models failed - check configuration\")\n    return None\n</code></pre>"},{"location":"documentation/usage/#logging-and-monitoring","title":"Logging and Monitoring","text":""},{"location":"documentation/usage/#structured-logging","title":"Structured Logging","text":"<pre><code>import logging\nfrom ivexes.config import setup_default_logging\n\n# Configure structured logging\nsetup_default_logging('INFO')\nlogger = logging.getLogger(__name__)\n\nasync def monitored_analysis():\n    \"\"\"Analysis with comprehensive logging.\"\"\"\n\n    logger.info(\"Starting vulnerability analysis\")\n\n    try:\n        agent = SingleAgent(bin_path='/target', settings=settings)\n\n        logger.info(\"Agent initialized successfully\")\n        result = agent.run(\"Comprehensive security analysis\")\n\n        logger.info(f\"Analysis complete - {result.usage.total_tokens} tokens used\")\n        return result\n\n    except Exception as e:\n        logger.error(f\"Analysis failed: {e}\", exc_info=True)\n        raise\n\nresult = await monitored_analysis()\n</code></pre>"},{"location":"documentation/usage/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>import time\nfrom datetime import datetime\n\nclass PerformanceMonitor:\n    \"\"\"Monitor analysis performance and resource usage.\"\"\"\n\n    def __init__(self):\n        self.start_time = None\n        self.metrics = {}\n\n    def start_analysis(self, analysis_type):\n        self.start_time = time.time()\n        self.metrics['analysis_type'] = analysis_type\n        self.metrics['start_time'] = datetime.now().isoformat()\n\n    def end_analysis(self, result):\n        duration = time.time() - self.start_time\n        self.metrics.update({\n            'duration_seconds': duration,\n            'tokens_used': result.usage.total_tokens,\n            'tokens_per_second': result.usage.total_tokens / duration,\n            'end_time': datetime.now().isoformat()\n        })\n\n        # Log performance metrics\n        print(f\"Analysis completed in {duration:.2f}s\")\n        print(f\"Token usage: {result.usage.total_tokens}\")\n        print(f\"Rate: {self.metrics['tokens_per_second']:.2f} tokens/sec\")\n\n# Usage\nmonitor = PerformanceMonitor()\nmonitor.start_analysis(\"binary_vulnerability_scan\")\nresult = agent.run(\"Analyze binary for vulnerabilities\")\nmonitor.end_analysis(result)\n</code></pre>"},{"location":"documentation/usage/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"documentation/usage/#parallel-analysis","title":"Parallel Analysis","text":"<pre><code>import asyncio\nfrom ivexes.agents import SingleAgent\n\nasync def parallel_binary_analysis(binaries, settings):\n    \"\"\"Analyze multiple binaries in parallel.\"\"\"\n\n    async def analyze_binary(binary_path):\n        agent = SingleAgent(bin_path=binary_path, settings=settings)\n        return await agent.run_streamed(\"Analyze for vulnerabilities\")\n\n    # Create analysis tasks\n    tasks = [analyze_binary(binary) for binary in binaries]\n\n    # Run analyses in parallel\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n\n    # Process results\n    for i, result in enumerate(results):\n        if isinstance(result, Exception):\n            print(f\"Analysis failed for {binaries[i]}: {result}\")\n        else:\n            print(f\"Analysis complete for {binaries[i]}\")\n\n    return results\n\n# Analyze multiple binaries\nbinaries = ['/target/bin1', '/target/bin2', '/target/bin3']\nresults = await parallel_binary_analysis(binaries, settings)\n</code></pre>"},{"location":"documentation/usage/#custom-agent-workflows","title":"Custom Agent Workflows","text":"<pre><code>from ivexes.agents.base import BaseAgent\nfrom ivexes.config import PartialSettings\n\nclass CustomSecurityAgent(BaseAgent):\n    \"\"\"Custom agent with specialized security analysis workflow.\"\"\"\n\n    def __init__(self, target_type, settings):\n        self.target_type = target_type\n        super().__init__(settings)\n\n    def _setup_agent(self):\n        # Configure specialized tools based on target type\n        if self.target_type == 'web_app':\n            # Web application security tools\n            self.user_msg = \"Analyze web application for OWASP Top 10 vulnerabilities\"\n        elif self.target_type == 'binary':\n            # Binary analysis tools\n            self.user_msg = \"Perform binary security analysis focusing on memory corruption\"\n\n        # Setup agent with appropriate tools\n        self.agent = self._create_specialized_agent()\n\n    def _create_specialized_agent(self):\n        # Implementation specific to your needs\n        pass\n\n# Usage\ncustom_agent = CustomSecurityAgent('binary', settings)\nresult = await custom_agent.run_interactive()\n</code></pre>"},{"location":"documentation/usage/#related-topics","title":"Related Topics","text":"<ul> <li>Configuration Guide - Complete configuration reference</li> <li>Installation Guide - Setup and environment preparation</li> <li>Agents API - Detailed API reference for all agent classes</li> <li>Code Browser API - Code analysis capabilities</li> <li>Examples Guide - Additional usage examples and patterns</li> </ul>"},{"location":"documentation/usage/#next-steps","title":"Next Steps","text":"<p>After mastering the core usage patterns:</p> <ol> <li>Explore Advanced Features: Review specialized agent capabilities and custom workflows</li> <li>Integrate with Tools: Connect IVEXES with your existing security toolchain</li> <li>Develop Custom Agents: Create specialized agents for your specific use cases</li> <li>Optimize Performance: Fine-tune settings for your analysis requirements</li> <li>Contribute Back: Share your patterns and improvements with the community</li> </ol>"}]}